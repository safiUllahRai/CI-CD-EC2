import { NgIterable, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';
import { ListRange, RxVirtualScrollStrategy, RxVirtualScrollViewport, RxVirtualViewRepeater } from '../model';
import * as i0 from "@angular/core";
/**
 * @Directive FixedSizeVirtualScrollStrategy
 *
 * @description
 *
 * The `FixedSizeVirtualScrollStrategy` provides a very performant way of rendering
 * items of a given size. It is comparable to \@angular/cdk `FixedSizeVirtualScrollStrategy`, but
 * with a high performant layouting technique.
 *
 * @docsCategory RxVirtualFor
 * @docsPage RxVirtualFor
 * @publicApi
 */
export declare class FixedSizeVirtualScrollStrategy<T, U extends NgIterable<T> = NgIterable<T>> extends RxVirtualScrollStrategy<T, U> implements OnChanges, OnDestroy {
    private readonly defaults?;
    /**
     * @description
     * The size of the items in the virtually scrolled list
     */
    set itemSize(itemSize: number);
    get itemSize(): number;
    private _itemSize;
    /**
     * @description
     * When enabled, the scroll strategy stops removing views from the viewport,
     * instead it only adds views. This setting can be changed on the fly. Views will be added in both directions
     * according to the user interactions.
     */
    appendOnly: boolean;
    /**
     * @description
     * The amount of items to render upfront in scroll direction
     */
    runwayItems: number;
    /**
     * @description
     * The amount of items to render upfront in reverse scroll direction
     */
    runwayItemsOpposite: number;
    /**
     * @description
     * If this flag is true, the virtual scroll strategy maintains the scrolled item when new data
     * is prepended to the list. This is very useful when implementing a reversed infinite scroller, that prepends
     * data instead of appending it
     */
    keepScrolledIndexOnPrepend: boolean;
    /** @internal */
    private readonly runwayStateChanged$;
    private viewport;
    private viewRepeater;
    private readonly _scrolledIndex$;
    readonly scrolledIndex$: import("rxjs").Observable<number>;
    private _scrolledIndex;
    private set scrolledIndex(value);
    private get scrolledIndex();
    private readonly _contentSize$;
    readonly contentSize$: import("rxjs").Observable<number>;
    private _contentSize;
    private set contentSize(value);
    private readonly _renderedRange$;
    renderedRange$: import("rxjs").Observable<ListRange>;
    private _renderedRange;
    private set renderedRange(value);
    private get renderedRange();
    private scrollTop;
    /** @internal */
    private scrollTopWithOutOffset;
    /** @internal */
    private scrollTopAfterOffset;
    /** @internal */
    private viewportOffset;
    /** @internal */
    private containerSize;
    private direction;
    private readonly detached$;
    /** @internal */
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    attach(viewport: RxVirtualScrollViewport, viewRepeater: RxVirtualViewRepeater<T, U>): void;
    detach(): void;
    private positionElements;
    private calcRenderedRange;
    scrollToIndex(index: number, behavior?: ScrollBehavior): void;
    private untilDetached$;
    private _setViewPosition;
    static ɵfac: i0.ɵɵFactoryDeclaration<FixedSizeVirtualScrollStrategy<any, any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FixedSizeVirtualScrollStrategy<any, any>, "rx-virtual-scroll-viewport[itemSize]", never, { "itemSize": { "alias": "itemSize"; "required": false; }; "appendOnly": { "alias": "appendOnly"; "required": false; }; "runwayItems": { "alias": "runwayItems"; "required": false; }; "runwayItemsOpposite": { "alias": "runwayItemsOpposite"; "required": false; }; "keepScrolledIndexOnPrepend": { "alias": "keepScrolledIndexOnPrepend"; "required": false; }; }, {}, never, never, true, never>;
    static ngAcceptInputType_appendOnly: null | boolean | string | undefined;
    static ngAcceptInputType_keepScrolledIndexOnPrepend: null | boolean | string | undefined;
}
