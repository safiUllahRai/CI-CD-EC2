import { ChangeDetectorRef, Directive, inject, Injector, Input, isSignal, NgZone, TemplateRef, ViewContainerRef, } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { coerceAllFactory } from '@rx-angular/cdk/coercing';
import { createTemplateNotifier, } from '@rx-angular/cdk/notifications';
import { RxStrategyProvider, } from '@rx-angular/cdk/render-strategies';
import { createTemplateManager, } from '@rx-angular/cdk/template';
import { merge, NEVER, Observable, ReplaySubject, Subject, Subscription, } from 'rxjs';
import { filter, map, mergeAll } from 'rxjs/operators';
import { RxIfTemplateNames, } from './model/index';
import * as i0 from "@angular/core";
/**
 * @Directive IfDirective
 * @description
 *
 * The `RxIf` directive is drop-in replacement for the `NgIf` directive, but with additional features.
 * `RxIf` allows you to bind observables directly without having the need of using the `async`
 * pipe in addition.
 *
 * This enables `rxIf` to completely operate on its own without having to interact with `NgZone`
 * or triggering global change detection.
 *
 * Read more about the RxIf directive in the [official
 *   docs](https://www.rx-angular.io/docs/template/api/rx-if-directive).
 *
 * @example
 * <app-item *rxIf="show$"></app-item>
 *
 * @docsCategory RxIf
 * @docsPage RxIf
 * @publicApi
 */
export class RxIf {
    templateRef;
    /** @internal */
    strategyProvider = inject(RxStrategyProvider);
    /** @internal */
    cdRef = inject(ChangeDetectorRef);
    /** @internal */
    ngZone = inject(NgZone);
    /** @internal */
    viewContainerRef = inject(ViewContainerRef);
    /** @internal */
    injector = inject(Injector);
    /** @internal */
    subscription = new Subscription();
    /** @internal */
    _renderObserver;
    /** @internal */
    templateManager;
    /**
     * @description
     * The Observable or value to representing the condition.
     *
     * @example
     * showHero = true;
     * showHero$ = new BehaviorSubject<boolean>(true);
     *
     * <ng-container *rxIf="showHero">
     *   <app-hero></app-hero>
     * </ng-container>
     *
     * <ng-container *rxIf="showHero$">
     *   <app-hero></app-hero>
     * </ng-container>
     *
     * @param { ObservableInput<T> | T } rxIf
     */
    rxIf;
    /**
     * @description
     *
     * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxIf`. It accepts
     * an `Observable<RxStrategyNames>` or
     *   [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).
     *
     * The default value for strategy is
     * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/rx-if-directive#use-render-strategies-strategy).
     *
     * @example
     *
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *     <ng-container *rxIf="showHero$; strategy: 'userBlocking'">
     *       <app-hero></app-hero>
     *     </ng-container>
     *
     *     <ng-container *rxIf="showHero$; strategy: strategy$">
     *       <app-hero></app-hero>
     *     </ng-container>
     *   `
     * })
     * export class AppComponent {
     *   strategy$ = of('immediate');
     * }
     *
     * @param { string | Observable<string> | undefined } strategyName
     * @see {@link RxStrategyNames}
     */
    set strategy(strategyName) {
        this.strategyHandler.next(strategyName);
    }
    /**
     * @description
     * Defines the template to be used when the bound value is falsy
     *
     * @example
     * <app-hero *rxIf="show$; else: noHero"></app-hero>
     * <ng-template #noHero><no-hero></no-hero></ng-template>
     */
    else;
    /**
     * @description
     * Defines the template to be used when the bound value is truthy
     *
     * @example
     * <ng-container *rxIf="show$; then: hero"></ng-container>
     * <ng-template #hero><app-hero></app-hero></ng-template>
     */
    then;
    /**
     * @description
     * Defines the template for the suspense state. Will be
     * shown when the bound Observable is in "suspense" state.
     * Suspense state is active when the current value is undefined or no value
     * was ever emitted.
     *
     * Read more about the reactive context in the
     * [official docs](https://www.rx-angular.io/docs/template/concepts/reactive-context).
     *
     * @example
     * <app-hero *rxIf="show$; suspense: suspenseTemplate" ></app-hero>
     * <ng-template #suspenseTemplate>
     *   <mat-progress-spinner></mat-progress-spinner>
     * </ng-template>
     *
     * @param { TemplateRef<RxIfViewContext> } suspense
     */
    suspense;
    /**
     * @description
     * Defines the template for the complete state. Will be
     * shown when the bound Observable is in "complete" state.
     *
     * Read more about the reactive context in the
     * [official docs](https://www.rx-angular.io/docs/template/concepts/reactive-context).
     *
     * @example
     * <app-hero *rxIf="show$; complete: completeTemplate" ></app-hero>
     * <ng-template #completeTemplate>
     *   <icon>thumbs_up</icon>
     * </ng-template>
     *
     * @param { TemplateRef<RxIfViewContext> } suspense
     */
    complete;
    /**
     * @description
     * Defines the template for the error state. Will be
     * shown when the bound Observable is in "error" state.
     *
     * Read more about the reactive context in the
     * [official docs](https://www.rx-angular.io/docs/template/concepts/reactive-context).
     *
     * @example
     * <app-hero *rxIf="show$; error: errorTemplate" ></app-hero>
     * <ng-template #errorTemplate>
     *   <icon>error</icon>
     * </ng-template>
     *
     * @param { TemplateRef<RxIfViewContext> } suspense
     */
    error;
    /**
     * @description
     * A trigger to manually set the active template. It accepts a `RxNotificationKind`
     * which determines what template to display. If no template is given, a context
     * variable resembling the notification state is put into the `Next`
     * template of the directive
     *
     * @example
     * <ng-container
     *  *rxIf="
     *    show$;
     *    let e = error;
     *    contextTrigger: contextTrigger$
     * ">
     *
     *   <app-hero></app-hero>
     *   <error *ngIf="e"></error>
     * </ng-container>
     *
     * // trigger template from component.ts
     * contextTrigger$.next(RxNotificationKind.error)
     *
     * @param { Observable<RxNotificationKind> } contextTrigger
     * @see {@link RxNotificationKind}
     */
    contextTrigger;
    /**
     * @description
     * A trigger to manually activate the default template. It accepts any value,
     * on emission it will switch to the let directives default template.
     *
     * @example
     * <ng-container
     *  *rxIf="
     *    show$;
     *    suspense: suspense
     *    nextTrigger: nextTrigger$
     * ">
     *
     *   <app-hero></app-hero>
     * </ng-container>
     *
     * <ng-template #suspense><loader></loader></ng-template>
     *
     * // trigger template from component.ts
     * nextTrigger$.next()
     *
     * @param { Observable<unknown> } nextTrigger
     */
    nextTrigger;
    /**
     * @description
     * A trigger to manually activate the suspense template. It accepts any value,
     * on emission it will display the suspense template. If no template is given,
     * the suspense context variable will be set to true instead.
     *
     * @example
     * <ng-container
     *  *rxIf="
     *    show$;
     *    let s = suspense;
     *    suspenseTrigger: suspenseTrigger$
     * ">
     *
     *   <app-hero></app-hero>
     *   <loader *ngIf="s"></loader>
     * </ng-container>
     *
     *
     * // trigger template from component.ts
     * suspenseTrigger$.next()
     *
     * @param { Observable<unknown> } suspenseTrigger
     */
    suspenseTrigger;
    /**
     * @description
     * A trigger to manually activate the error template. It accepts any value,
     * on emission it will display the error template. If no template is given,
     * the error context variable will be set to true instead.
     *
     * @example
     * <ng-container
     *  *rxIf="
     *    show$;
     *    let e = error;
     *    errorTrigger: errorTrigger$
     * ">
     *
     *   <app-hero></app-hero>
     *   <error *ngIf="e"></error>
     * </ng-container>
     *
     * // trigger template from component.ts
     * errorTrigger$.next()
     *
     * @param { Observable<unknown> } errorTrigger
     */
    errorTrigger;
    /**
     * @description
     * A trigger to manually activate the complete template. It accepts any value,
     * on emission it will display the error template. If no template is given,
     * the complete context variable will complete set to true instead.
     *
     * @example
     * <ng-container
     *  *rxIf="
     *    show$;
     *    let c = complete;
     *    completeTrigger: completeTrigger$
     * ">
     *
     *   <app-hero></app-hero>
     *   <done *ngIf="c"></done>
     * </ng-container>
     *
     * // trigger template from component.ts
     * completeTrigger$.next()
     *
     * @param { Observable<unknown> } completeTrigger
     */
    completeTrigger;
    /**
     * @description
     *
     * Structural directives maintain `EmbeddedView`s within a components' template.
     * Depending on the bound value as well as the configured `RxRenderStrategy`,
     * updates processed by the `*rxIf` directive might be asynchronous.
     *
     * Whenever a template gets inserted into, or removed from, its parent component, the directive has to inform the
     *   parent in order to update any view- or contentquery (`@ViewChild`, `@ViewChildren`, `@ContentChild`,
     *   `@ContentChildren`).
     *
     * Read more about this in the
     * [official
     *   docs](https://www.rx-angular.io/docs/template/api/rx-if-directive#local-strategies-and-view-content-queries-parent).
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-component>
     *      <app-item
     *        *rxIf="
     *          show$;
     *          parent: true;
     *        "
     *      >
     *      </app-item>
     *    </app-component>
     *   `
     * })
     * export class AppComponent {
     *   show$ = state.select('showItem');
     * }
     *
     * @param {boolean} renderParent
     *
     * @deprecated this flag will be dropped soon, as it is no longer required when using signal based view & content queries
     */
    renderParent = this.strategyProvider.config.parent;
    /**
     * @description
     * A flag to control whether `*rxIf` templates are created within `NgZone` or not.
     * The default value is `true, `*rxIf` will create its `EmbeddedView` inside `NgZone`.
     *
     * Event listeners normally trigger zone.
     * Especially high frequency events can cause performance issues.
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#working-with-event-listeners-patchzone).
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-component>
     *      <app-item
     *        *rxIf="
     *          show$;
     *          patchZone: false;
     *        "
     *        (drag)="itemDrag($event)"
     *      >
     *      </app-item>
     *    </app-component>
     *   `
     * })
     * export class AppComponent {
     *   show$ = state.select('showItem');
     * }
     *
     * @param {boolean} patchZone
     */
    patchZone = this.strategyProvider.config.patchZone;
    /**
     * @description
     * A `Subject` which emits whenever `*rxIf` rendered a change to the view.
     * This enables developers to perform actions when rendering has been done.
     * The `renderCallback` is useful in situations where you
     * rely on specific DOM properties like the dimensions of an item after it got rendered.
     *
     * The `renderCallback` emits the latest value causing the view to update.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-component>
     *      <app-item
     *        *rxIf="
     *          show$;
     *          renderCallback: rendered;
     *        "
     *      >
     *      </app-item>
     *    </app-component>
     *   `
     * })
     * export class AppComponent {
     *  show$ = state.select('showItem');
     *  // this emits whenever rxIf finished rendering changes
     *  rendered = new Subject<boolean>();
     *
     *   constructor(elementRef: ElementRef<HTMLElement>) {
     *     rendered.subscribe(() => {
     *       // item is rendered, we can access its dom now
     *     })
     *   }
     * }
     *
     * @param {Subject<boolean>} callback
     */
    set renderCallback(callback) {
        this._renderObserver = callback;
    }
    /** @internal */
    triggerHandler = new ReplaySubject(1);
    /** @internal */
    templateNotifier = createTemplateNotifier();
    /** @internal */
    strategyHandler = coerceAllFactory(() => new ReplaySubject(1), mergeAll());
    /** @internal */
    rendered$ = new Subject();
    /** @internal */
    get thenTemplate() {
        return this.then ? this.then : this.templateRef;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    /** @internal */
    ngOnInit() {
        this.subscription.add(merge(this.contextTrigger || NEVER, this.nextTrigger?.pipe(map(() => "next" /* RxNotificationKind.Next */)) || NEVER, this.suspenseTrigger?.pipe(map(() => "suspense" /* RxNotificationKind.Suspense */)) ||
            NEVER, this.completeTrigger?.pipe(map(() => "complete" /* RxNotificationKind.Complete */)) ||
            NEVER, this.errorTrigger?.pipe(map(() => "error" /* RxNotificationKind.Error */)) || NEVER)
            .pipe(filter((v) => !!v))
            .subscribe((t) => this.triggerHandler.next(t)));
        this.subscription.add(this.templateManager
            .render(this.templateNotifier.values$)
            .subscribe((n) => {
            this.rendered$.next(n);
            this._renderObserver?.next(n);
        }));
    }
    /** @internal */
    ngOnChanges(changes) {
        if (!this.templateManager) {
            this._createTemplateManager();
        }
        if (changes.then && !changes.then.firstChange) {
            this.templateManager.addTemplateRef(RxIfTemplateNames.then, this.thenTemplate);
        }
        if (changes.else) {
            this.templateManager.addTemplateRef(RxIfTemplateNames.else, this.else);
        }
        if (changes.complete) {
            this.templateManager.addTemplateRef(RxIfTemplateNames.complete, this.complete);
        }
        if (changes.suspense) {
            this.templateManager.addTemplateRef(RxIfTemplateNames.suspense, this.suspense);
            this.templateNotifier.withInitialSuspense(!!this.suspense);
        }
        if (changes.error) {
            this.templateManager.addTemplateRef(RxIfTemplateNames.error, this.error);
        }
        if (changes.rxIf) {
            if (isSignal(this.rxIf)) {
                this.templateNotifier.next(toObservable(this.rxIf, { injector: this.injector }));
            }
            else {
                this.templateNotifier.next(this.rxIf);
            }
        }
    }
    /** @internal */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /** @internal */
    _createTemplateManager() {
        const getNextTemplate = (value) => {
            return value
                ? RxIfTemplateNames.then
                : this.else
                    ? RxIfTemplateNames.else
                    : undefined;
        };
        this.templateManager = createTemplateManager({
            templateSettings: {
                viewContainerRef: this.viewContainerRef,
                customContext: (rxIf) => ({ rxIf }),
            },
            renderSettings: {
                cdRef: this.cdRef,
                parent: coerceBooleanProperty(this.renderParent),
                patchZone: this.patchZone ? this.ngZone : false,
                defaultStrategyName: this.strategyProvider.primaryStrategy,
                strategies: this.strategyProvider.strategies,
            },
            notificationToTemplateName: {
                ["suspense" /* RxNotificationKind.Suspense */]: (value) => this.suspense ? RxIfTemplateNames.suspense : getNextTemplate(value),
                ["next" /* RxNotificationKind.Next */]: (value) => getNextTemplate(value),
                ["error" /* RxNotificationKind.Error */]: (value) => this.error ? RxIfTemplateNames.error : getNextTemplate(value),
                ["complete" /* RxNotificationKind.Complete */]: (value) => this.complete ? RxIfTemplateNames.complete : getNextTemplate(value),
            },
            templateTrigger$: this.triggerHandler,
        });
        this.templateManager.addTemplateRef(RxIfTemplateNames.then, this.thenTemplate);
        this.templateManager.nextStrategy(this.strategyHandler.values$);
    }
    /** @internal */
    static rxIfUseIfTypeGuard;
    /**
     * Assert the correct type of the expression bound to the `ngIf` input within the template.
     *
     * The presence of this static field is a signal to the Ivy template type check compiler that
     * when the `NgIf` structural directive renders its template, the type of the expression bound
     * to `ngIf` should be narrowed in some way. For `NgIf`, the binding expression itself is used to
     * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `NgIf`.
     */
    static ngTemplateGuard_rxIf;
    /**
     * Asserts the correct type of the context for the template that `NgIf` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `NgIf` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxIf, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: RxIf, isStandalone: true, selector: "[rxIf]", inputs: { rxIf: "rxIf", strategy: ["rxIfStrategy", "strategy"], else: ["rxIfElse", "else"], then: ["rxIfThen", "then"], suspense: ["rxIfSuspense", "suspense"], complete: ["rxIfComplete", "complete"], error: ["rxIfError", "error"], contextTrigger: ["rxIfContextTrigger", "contextTrigger"], nextTrigger: ["rxIfNextTrigger", "nextTrigger"], suspenseTrigger: ["rxIfSuspenseTrigger", "suspenseTrigger"], errorTrigger: ["rxIfErrorTrigger", "errorTrigger"], completeTrigger: ["rxIfCompleteTrigger", "completeTrigger"], renderParent: ["rxIfParent", "renderParent"], patchZone: ["rxIfPatchZone", "patchZone"], renderCallback: ["rxIfRenderCallback", "renderCallback"] }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxIf, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rxIf]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }], propDecorators: { rxIf: [{
                type: Input
            }], strategy: [{
                type: Input,
                args: ['rxIfStrategy']
            }], else: [{
                type: Input,
                args: ['rxIfElse']
            }], then: [{
                type: Input,
                args: ['rxIfThen']
            }], suspense: [{
                type: Input,
                args: ['rxIfSuspense']
            }], complete: [{
                type: Input,
                args: ['rxIfComplete']
            }], error: [{
                type: Input,
                args: ['rxIfError']
            }], contextTrigger: [{
                type: Input,
                args: ['rxIfContextTrigger']
            }], nextTrigger: [{
                type: Input,
                args: ['rxIfNextTrigger']
            }], suspenseTrigger: [{
                type: Input,
                args: ['rxIfSuspenseTrigger']
            }], errorTrigger: [{
                type: Input,
                args: ['rxIfErrorTrigger']
            }], completeTrigger: [{
                type: Input,
                args: ['rxIfCompleteTrigger']
            }], renderParent: [{
                type: Input,
                args: ['rxIfParent']
            }], patchZone: [{
                type: Input,
                args: ['rxIfPatchZone']
            }], renderCallback: [{
                type: Input,
                args: ['rxIfRenderCallback']
            }] } });
/**
 * @internal
 * @description
 * Coerces a data-bound value (typically a string) to a boolean.
 *
 */
function coerceBooleanProperty(value) {
    return value != null && `${value}` !== 'false';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy90ZW1wbGF0ZS9pZi9zcmMvbGliL2lmLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxNQUFNLEVBQ04sUUFBUSxFQUNSLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQU1OLFdBQVcsRUFDWCxnQkFBZ0IsR0FDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzFELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzVELE9BQU8sRUFDTCxzQkFBc0IsR0FFdkIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2QyxPQUFPLEVBRUwsa0JBQWtCLEdBQ25CLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUNMLHFCQUFxQixHQUV0QixNQUFNLDBCQUEwQixDQUFDO0FBQ2xDLE9BQU8sRUFDTCxLQUFLLEVBQ0wsS0FBSyxFQUVMLFVBQVUsRUFFVixhQUFhLEVBQ2IsT0FBTyxFQUNQLFlBQVksR0FDYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZELE9BQU8sRUFDTCxpQkFBaUIsR0FHbEIsTUFBTSxlQUFlLENBQUM7O0FBRXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUtILE1BQU0sT0FBTyxJQUFJO0lBdWFjO0lBcGE3QixnQkFBZ0I7SUFDUixnQkFBZ0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUN0RCxnQkFBZ0I7SUFDUixLQUFLLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDMUMsZ0JBQWdCO0lBQ1IsTUFBTSxHQUFHLE1B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Q2pCO2dGQTJDVSxJQUFJO3NCQUFaLEtBQUs7Z0JBcUNGLFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxjQUFjO2dCQWFGLElBQUk7c0JBQXRCLEtBQUs7dUJBQUMsVUFBVTtnQkFVRSxJQUFJO3NCQUF0QixLQUFLO3VCQUFDLFVBQVU7Z0JBb0JNLFFBQVE7c0JBQTlCLEtBQUs7dUJBQUMsY0FBYztnQkFrQkUsUUFBUTtzQkFBOUIsS0FBSzt1QkFBQyxjQUFjO2dCQWtCRCxLQUFLO3NCQUF4QixLQUFLO3VCQUFDLFdBQVc7Z0JBMkJXLGNBQWM7c0JBQTFDLEtBQUs7dUJBQUMsb0JBQW9CO2dCQXlCRCxXQUFXO3NCQUFwQyxLQUFLO3VCQUFDLGlCQUFpQjtnQkEwQk0sZUFBZTtzQkFBNUMsS0FBSzt1QkFBQyxxQkFBcUI7Z0JBeUJELFlBQVk7c0JBQXRDLEtBQUs7dUJBQUMsa0JBQWtCO2dCQXlCSyxlQUFlO3NCQUE1QyxLQUFLO3VCQUFDLHFCQUFxQjtnQkF3Q1AsWUFBWTtzQkFBaEMsS0FBSzt1QkFBQyxZQUFZO2dCQW1DSyxTQUFTO3NCQUFoQyxLQUFLO3VCQUFDLGVBQWU7Z0JBeUNsQixjQUFjO3NCQURqQixLQUFLO3VCQUFDLG9CQUFvQjs7QUEySzdCOzs7OztHQUtHO0FBQ0gsU0FBUyxxQkFBcUIsQ0FBQyxLQUFjO0lBQzNDLE9BQU8sS0FBSyxJQUFJLElBQUksSUFBSSxHQUFHLEtBQUssRUFBRSxLQUFLLE9BQU8sQ0FBQztBQUNqRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIERpcmVjdGl2ZSxcbiAgaW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIGlzU2lnbmFsLFxuICBOZ1pvbmUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFNpZ25hbCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdG9PYnNlcnZhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuaW1wb3J0IHsgY29lcmNlQWxsRmFjdG9yeSB9IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9jb2VyY2luZyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW1wbGF0ZU5vdGlmaWVyLFxuICBSeE5vdGlmaWNhdGlvbktpbmQsXG59IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7XG4gIFJ4U3RyYXRlZ3lOYW1lcyxcbiAgUnhTdHJhdGVneVByb3ZpZGVyLFxufSBmcm9tICdAcngtYW5ndWxhci9jZGsvcmVuZGVyLXN0cmF0ZWdpZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVtcGxhdGVNYW5hZ2VyLFxuICBSeFRlbXBsYXRlTWFuYWdlcixcbn0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3RlbXBsYXRlJztcbmltcG9ydCB7XG4gIG1lcmdlLFxuICBORVZFUixcbiAgTmV4dE9ic2VydmVyLFxuICBPYnNlcnZhYmxlLFxuICBPYnNlcnZhYmxlSW5wdXQsXG4gIFJlcGxheVN1YmplY3QsXG4gIFN1YmplY3QsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgbWVyZ2VBbGwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBSeElmVGVtcGxhdGVOYW1lcyxcbiAgcnhJZlRlbXBsYXRlTmFtZXMsXG4gIFJ4SWZWaWV3Q29udGV4dCxcbn0gZnJvbSAnLi9tb2RlbC9pbmRleCc7XG5cbi8qKlxuICogQERpcmVjdGl2ZSBJZkRpcmVjdGl2ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVGhlIGBSeElmYCBkaXJlY3RpdmUgaXMgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIGBOZ0lmYCBkaXJlY3RpdmUsIGJ1dCB3aXRoIGFkZGl0aW9uYWwgZmVhdHVyZXMuXG4gKiBgUnhJZmAgYWxsb3dzIHlvdSB0byBiaW5kIG9ic2VydmFibGVzIGRpcmVjdGx5IHdpdGhvdXQgaGF2aW5nIHRoZSBuZWVkIG9mIHVzaW5nIHRoZSBgYXN5bmNgXG4gKiBwaXBlIGluIGFkZGl0aW9uLlxuICpcbiAqIFRoaXMgZW5hYmxlcyBgcnhJZmAgdG8gY29tcGxldGVseSBvcGVyYXRlIG9uIGl0cyBvd24gd2l0aG91dCBoYXZpbmcgdG8gaW50ZXJhY3Qgd2l0aCBgTmdab25lYFxuICogb3IgdHJpZ2dlcmluZyBnbG9iYWwgY2hhbmdlIGRldGVjdGlvbi5cbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgdGhlIFJ4SWYgZGlyZWN0aXZlIGluIHRoZSBbb2ZmaWNpYWxcbiAqICAgZG9jc10oaHR0cHM6Ly93d3cucngtYW5ndWxhci5pby9kb2NzL3RlbXBsYXRlL2FwaS9yeC1pZi1kaXJlY3RpdmUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8YXBwLWl0ZW0gKnJ4SWY9XCJzaG93JFwiPjwvYXBwLWl0ZW0+XG4gKlxuICogQGRvY3NDYXRlZ29yeSBSeElmXG4gKiBAZG9jc1BhZ2UgUnhJZlxuICogQHB1YmxpY0FwaVxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcnhJZl0nLFxuICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBSeElmPFQgPSB1bmtub3duPlxuICBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uQ2hhbmdlc1xue1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RyYXRlZ3lQcm92aWRlciA9IGluamVjdChSeFN0cmF0ZWd5UHJvdmlkZXIpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgY2RSZWYgPSBpbmplY3QoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgbmdab25lID0gaW5qZWN0KE5nWm9uZSk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmID0gaW5qZWN0KFZpZXdDb250YWluZXJSZWYpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgaW5qZWN0b3IgPSBpbmplY3QoSW5qZWN0b3IpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3JlbmRlck9ic2VydmVyOiBOZXh0T2JzZXJ2ZXI8dW5rbm93bj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB0ZW1wbGF0ZU1hbmFnZXI6IFJ4VGVtcGxhdGVNYW5hZ2VyPFxuICAgIFQsXG4gICAgUnhJZlZpZXdDb250ZXh0PFQ+LFxuICAgIHJ4SWZUZW1wbGF0ZU5hbWVzXG4gID47XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgT2JzZXJ2YWJsZSBvciB2YWx1ZSB0byByZXByZXNlbnRpbmcgdGhlIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogc2hvd0hlcm8gPSB0cnVlO1xuICAgKiBzaG93SGVybyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRydWUpO1xuICAgKlxuICAgKiA8bmctY29udGFpbmVyICpyeElmPVwic2hvd0hlcm9cIj5cbiAgICogICA8YXBwLWhlcm8+PC9hcHAtaGVybz5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIDxuZy1jb250YWluZXIgKnJ4SWY9XCJzaG93SGVybyRcIj5cbiAgICogICA8YXBwLWhlcm8+PC9hcHAtaGVybz5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIEBwYXJhbSB7IE9ic2VydmFibGVJbnB1dDxUPiB8IFQgfSByeElmXG4gICAqL1xuICBASW5wdXQoKSByeElmOiBPYnNlcnZhYmxlSW5wdXQ8VD4gfCBTaWduYWw8VD4gfCBUO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogWW91IGNhbiBjaGFuZ2UgdGhlIHVzZWQgYFJlbmRlclN0cmF0ZWd5YCBieSB1c2luZyB0aGUgYHN0cmF0ZWd5YCBpbnB1dCBvZiB0aGUgYCpyeElmYC4gSXQgYWNjZXB0c1xuICAgKiBhbiBgT2JzZXJ2YWJsZTxSeFN0cmF0ZWd5TmFtZXM+YCBvclxuICAgKiAgIFtgUnhTdHJhdGVneU5hbWVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3J4LWFuZ3VsYXIvcngtYW5ndWxhci9ibG9iL2IwNjMwZjY5MDE3Y2MxODcxZDA5M2U5NzYwMDYwNjZkNWYyMDA1YjkvbGlicy9jZGsvcmVuZGVyLXN0cmF0ZWdpZXMvc3JjL2xpYi9tb2RlbC50cyNMNTIpLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3Igc3RyYXRlZ3kgaXNcbiAgICogW2Bub3JtYWxgXShodHRwczovL3d3dy5yeC1hbmd1bGFyLmlvL2RvY3MvdGVtcGxhdGUvY2RrL3JlbmRlci1zdHJhdGVnaWVzL3N0cmF0ZWdpZXMvY29uY3VycmVudC1zdHJhdGVnaWVzKS5cbiAgICpcbiAgICogUmVhZCBtb3JlIGFib3V0IHRoaXMgaW4gdGhlXG4gICAqIFtvZmZpY2lhbCBkb2NzXShodHRwczovL3d3dy5yeC1hbmd1bGFyLmlvL2RvY3MvdGVtcGxhdGUvYXBpL3J4LWlmLWRpcmVjdGl2ZSN1c2UtcmVuZGVyLXN0cmF0ZWdpZXMtc3RyYXRlZ3kpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgICA8bmctY29udGFpbmVyICpyeElmPVwic2hvd0hlcm8kOyBzdHJhdGVneTogJ3VzZXJCbG9ja2luZydcIj5cbiAgICogICAgICAgPGFwcC1oZXJvPjwvYXBwLWhlcm8+XG4gICAqICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICpcbiAgICogICAgIDxuZy1jb250YWluZXIgKnJ4SWY9XCJzaG93SGVybyQ7IHN0cmF0ZWd5OiBzdHJhdGVneSRcIj5cbiAgICogICAgICAgPGFwcC1oZXJvPjwvYXBwLWhlcm8+XG4gICAqICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICogICBgXG4gICAqIH0pXG4gICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgKiAgIHN0cmF0ZWd5JCA9IG9mKCdpbW1lZGlhdGUnKTtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4gfCB1bmRlZmluZWQgfSBzdHJhdGVneU5hbWVcbiAgICogQHNlZSB7QGxpbmsgUnhTdHJhdGVneU5hbWVzfVxuICAgKi9cbiAgQElucHV0KCdyeElmU3RyYXRlZ3knKVxuICBzZXQgc3RyYXRlZ3koc3RyYXRlZ3lOYW1lOiBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz4gfCBSeFN0cmF0ZWd5TmFtZXMpIHtcbiAgICB0aGlzLnN0cmF0ZWd5SGFuZGxlci5uZXh0KHN0cmF0ZWd5TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIHRvIGJlIHVzZWQgd2hlbiB0aGUgYm91bmQgdmFsdWUgaXMgZmFsc3lcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPGFwcC1oZXJvICpyeElmPVwic2hvdyQ7IGVsc2U6IG5vSGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqIDxuZy10ZW1wbGF0ZSAjbm9IZXJvPjxuby1oZXJvPjwvbm8taGVybz48L25nLXRlbXBsYXRlPlxuICAgKi9cbiAgQElucHV0KCdyeElmRWxzZScpIGVsc2U6IFRlbXBsYXRlUmVmPFJ4SWZWaWV3Q29udGV4dDxUPj47XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSB0byBiZSB1c2VkIHdoZW4gdGhlIGJvdW5kIHZhbHVlIGlzIHRydXRoeVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8bmctY29udGFpbmVyICpyeElmPVwic2hvdyQ7IHRoZW46IGhlcm9cIj48L25nLWNvbnRhaW5lcj5cbiAgICogPG5nLXRlbXBsYXRlICNoZXJvPjxhcHAtaGVybz48L2FwcC1oZXJvPjwvbmctdGVtcGxhdGU+XG4gICAqL1xuICBASW5wdXQoJ3J4SWZUaGVuJykgdGhlbjogVGVtcGxhdGVSZWY8UnhJZlZpZXdDb250ZXh0PFQ+PjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciB0aGUgc3VzcGVuc2Ugc3RhdGUuIFdpbGwgYmVcbiAgICogc2hvd24gd2hlbiB0aGUgYm91bmQgT2JzZXJ2YWJsZSBpcyBpbiBcInN1c3BlbnNlXCIgc3RhdGUuXG4gICAqIFN1c3BlbnNlIHN0YXRlIGlzIGFjdGl2ZSB3aGVuIHRoZSBjdXJyZW50IHZhbHVlIGlzIHVuZGVmaW5lZCBvciBubyB2YWx1ZVxuICAgKiB3YXMgZXZlciBlbWl0dGVkLlxuICAgKlxuICAgKiBSZWFkIG1vcmUgYWJvdXQgdGhlIHJlYWN0aXZlIGNvbnRleHQgaW4gdGhlXG4gICAqIFtvZmZpY2lhbCBkb2NzXShodHRwczovL3d3dy5yeC1hbmd1bGFyLmlvL2RvY3MvdGVtcGxhdGUvY29uY2VwdHMvcmVhY3RpdmUtY29udGV4dCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxhcHAtaGVybyAqcnhJZj1cInNob3ckOyBzdXNwZW5zZTogc3VzcGVuc2VUZW1wbGF0ZVwiID48L2FwcC1oZXJvPlxuICAgKiA8bmctdGVtcGxhdGUgI3N1c3BlbnNlVGVtcGxhdGU+XG4gICAqICAgPG1hdC1wcm9ncmVzcy1zcGlubmVyPjwvbWF0LXByb2dyZXNzLXNwaW5uZXI+XG4gICAqIDwvbmctdGVtcGxhdGU+XG4gICAqXG4gICAqIEBwYXJhbSB7IFRlbXBsYXRlUmVmPFJ4SWZWaWV3Q29udGV4dD4gfSBzdXNwZW5zZVxuICAgKi9cbiAgQElucHV0KCdyeElmU3VzcGVuc2UnKSBzdXNwZW5zZTogVGVtcGxhdGVSZWY8UnhJZlZpZXdDb250ZXh0PFQ+PjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciB0aGUgY29tcGxldGUgc3RhdGUuIFdpbGwgYmVcbiAgICogc2hvd24gd2hlbiB0aGUgYm91bmQgT2JzZXJ2YWJsZSBpcyBpbiBcImNvbXBsZXRlXCIgc3RhdGUuXG4gICAqXG4gICAqIFJlYWQgbW9yZSBhYm91dCB0aGUgcmVhY3RpdmUgY29udGV4dCBpbiB0aGVcbiAgICogW29mZmljaWFsIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9jb25jZXB0cy9yZWFjdGl2ZS1jb250ZXh0KS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPGFwcC1oZXJvICpyeElmPVwic2hvdyQ7IGNvbXBsZXRlOiBjb21wbGV0ZVRlbXBsYXRlXCIgPjwvYXBwLWhlcm8+XG4gICAqIDxuZy10ZW1wbGF0ZSAjY29tcGxldGVUZW1wbGF0ZT5cbiAgICogICA8aWNvbj50aHVtYnNfdXA8L2ljb24+XG4gICAqIDwvbmctdGVtcGxhdGU+XG4gICAqXG4gICAqIEBwYXJhbSB7IFRlbXBsYXRlUmVmPFJ4SWZWaWV3Q29udGV4dD4gfSBzdXNwZW5zZVxuICAgKi9cbiAgQElucHV0KCdyeElmQ29tcGxldGUnKSBjb21wbGV0ZTogVGVtcGxhdGVSZWY8UnhJZlZpZXdDb250ZXh0PFQ+PjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciB0aGUgZXJyb3Igc3RhdGUuIFdpbGwgYmVcbiAgICogc2hvd24gd2hlbiB0aGUgYm91bmQgT2JzZXJ2YWJsZSBpcyBpbiBcImVycm9yXCIgc3RhdGUuXG4gICAqXG4gICAqIFJlYWQgbW9yZSBhYm91dCB0aGUgcmVhY3RpdmUgY29udGV4dCBpbiB0aGVcbiAgICogW29mZmljaWFsIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9jb25jZXB0cy9yZWFjdGl2ZS1jb250ZXh0KS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPGFwcC1oZXJvICpyeElmPVwic2hvdyQ7IGVycm9yOiBlcnJvclRlbXBsYXRlXCIgPjwvYXBwLWhlcm8+XG4gICAqIDxuZy10ZW1wbGF0ZSAjZXJyb3JUZW1wbGF0ZT5cbiAgICogICA8aWNvbj5lcnJvcjwvaWNvbj5cbiAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICpcbiAgICogQHBhcmFtIHsgVGVtcGxhdGVSZWY8UnhJZlZpZXdDb250ZXh0PiB9IHN1c3BlbnNlXG4gICAqL1xuICBASW5wdXQoJ3J4SWZFcnJvcicpIGVycm9yOiBUZW1wbGF0ZVJlZjxSeElmVmlld0NvbnRleHQ8VD4+O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSB0cmlnZ2VyIHRvIG1hbnVhbGx5IHNldCB0aGUgYWN0aXZlIHRlbXBsYXRlLiBJdCBhY2NlcHRzIGEgYFJ4Tm90aWZpY2F0aW9uS2luZGBcbiAgICogd2hpY2ggZGV0ZXJtaW5lcyB3aGF0IHRlbXBsYXRlIHRvIGRpc3BsYXkuIElmIG5vIHRlbXBsYXRlIGlzIGdpdmVuLCBhIGNvbnRleHRcbiAgICogdmFyaWFibGUgcmVzZW1ibGluZyB0aGUgbm90aWZpY2F0aW9uIHN0YXRlIGlzIHB1dCBpbnRvIHRoZSBgTmV4dGBcbiAgICogdGVtcGxhdGUgb2YgdGhlIGRpcmVjdGl2ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8bmctY29udGFpbmVyXG4gICAqICAqcnhJZj1cIlxuICAgKiAgICBzaG93JDtcbiAgICogICAgbGV0IGUgPSBlcnJvcjtcbiAgICogICAgY29udGV4dFRyaWdnZXI6IGNvbnRleHRUcmlnZ2VyJFxuICAgKiBcIj5cbiAgICpcbiAgICogICA8YXBwLWhlcm8+PC9hcHAtaGVybz5cbiAgICogICA8ZXJyb3IgKm5nSWY9XCJlXCI+PC9lcnJvcj5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIC8vIHRyaWdnZXIgdGVtcGxhdGUgZnJvbSBjb21wb25lbnQudHNcbiAgICogY29udGV4dFRyaWdnZXIkLm5leHQoUnhOb3RpZmljYXRpb25LaW5kLmVycm9yKVxuICAgKlxuICAgKiBAcGFyYW0geyBPYnNlcnZhYmxlPFJ4Tm90aWZpY2F0aW9uS2luZD4gfSBjb250ZXh0VHJpZ2dlclxuICAgKiBAc2VlIHtAbGluayBSeE5vdGlmaWNhdGlvbktpbmR9XG4gICAqL1xuICBASW5wdXQoJ3J4SWZDb250ZXh0VHJpZ2dlcicpIGNvbnRleHRUcmlnZ2VyPzogT2JzZXJ2YWJsZTxSeE5vdGlmaWNhdGlvbktpbmQ+O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSB0cmlnZ2VyIHRvIG1hbnVhbGx5IGFjdGl2YXRlIHRoZSBkZWZhdWx0IHRlbXBsYXRlLiBJdCBhY2NlcHRzIGFueSB2YWx1ZSxcbiAgICogb24gZW1pc3Npb24gaXQgd2lsbCBzd2l0Y2ggdG8gdGhlIGxldCBkaXJlY3RpdmVzIGRlZmF1bHQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxuZy1jb250YWluZXJcbiAgICogICpyeElmPVwiXG4gICAqICAgIHNob3ckO1xuICAgKiAgICBzdXNwZW5zZTogc3VzcGVuc2VcbiAgICogICAgbmV4dFRyaWdnZXI6IG5leHRUcmlnZ2VyJFxuICAgKiBcIj5cbiAgICpcbiAgICogICA8YXBwLWhlcm8+PC9hcHAtaGVybz5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIDxuZy10ZW1wbGF0ZSAjc3VzcGVuc2U+PGxvYWRlcj48L2xvYWRlcj48L25nLXRlbXBsYXRlPlxuICAgKlxuICAgKiAvLyB0cmlnZ2VyIHRlbXBsYXRlIGZyb20gY29tcG9uZW50LnRzXG4gICAqIG5leHRUcmlnZ2VyJC5uZXh0KClcbiAgICpcbiAgICogQHBhcmFtIHsgT2JzZXJ2YWJsZTx1bmtub3duPiB9IG5leHRUcmlnZ2VyXG4gICAqL1xuICBASW5wdXQoJ3J4SWZOZXh0VHJpZ2dlcicpIG5leHRUcmlnZ2VyPzogT2JzZXJ2YWJsZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgdHJpZ2dlciB0byBtYW51YWxseSBhY3RpdmF0ZSB0aGUgc3VzcGVuc2UgdGVtcGxhdGUuIEl0IGFjY2VwdHMgYW55IHZhbHVlLFxuICAgKiBvbiBlbWlzc2lvbiBpdCB3aWxsIGRpc3BsYXkgdGhlIHN1c3BlbnNlIHRlbXBsYXRlLiBJZiBubyB0ZW1wbGF0ZSBpcyBnaXZlbixcbiAgICogdGhlIHN1c3BlbnNlIGNvbnRleHQgdmFyaWFibGUgd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8bmctY29udGFpbmVyXG4gICAqICAqcnhJZj1cIlxuICAgKiAgICBzaG93JDtcbiAgICogICAgbGV0IHMgPSBzdXNwZW5zZTtcbiAgICogICAgc3VzcGVuc2VUcmlnZ2VyOiBzdXNwZW5zZVRyaWdnZXIkXG4gICAqIFwiPlxuICAgKlxuICAgKiAgIDxhcHAtaGVybz48L2FwcC1oZXJvPlxuICAgKiAgIDxsb2FkZXIgKm5nSWY9XCJzXCI+PC9sb2FkZXI+XG4gICAqIDwvbmctY29udGFpbmVyPlxuICAgKlxuICAgKlxuICAgKiAvLyB0cmlnZ2VyIHRlbXBsYXRlIGZyb20gY29tcG9uZW50LnRzXG4gICAqIHN1c3BlbnNlVHJpZ2dlciQubmV4dCgpXG4gICAqXG4gICAqIEBwYXJhbSB7IE9ic2VydmFibGU8dW5rbm93bj4gfSBzdXNwZW5zZVRyaWdnZXJcbiAgICovXG4gIEBJbnB1dCgncnhJZlN1c3BlbnNlVHJpZ2dlcicpIHN1c3BlbnNlVHJpZ2dlcj86IE9ic2VydmFibGU8dW5rbm93bj47XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHRyaWdnZXIgdG8gbWFudWFsbHkgYWN0aXZhdGUgdGhlIGVycm9yIHRlbXBsYXRlLiBJdCBhY2NlcHRzIGFueSB2YWx1ZSxcbiAgICogb24gZW1pc3Npb24gaXQgd2lsbCBkaXNwbGF5IHRoZSBlcnJvciB0ZW1wbGF0ZS4gSWYgbm8gdGVtcGxhdGUgaXMgZ2l2ZW4sXG4gICAqIHRoZSBlcnJvciBjb250ZXh0IHZhcmlhYmxlIHdpbGwgYmUgc2V0IHRvIHRydWUgaW5zdGVhZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPG5nLWNvbnRhaW5lclxuICAgKiAgKnJ4SWY9XCJcbiAgICogICAgc2hvdyQ7XG4gICAqICAgIGxldCBlID0gZXJyb3I7XG4gICAqICAgIGVycm9yVHJpZ2dlcjogZXJyb3JUcmlnZ2VyJFxuICAgKiBcIj5cbiAgICpcbiAgICogICA8YXBwLWhlcm8+PC9hcHAtaGVybz5cbiAgICogICA8ZXJyb3IgKm5nSWY9XCJlXCI+PC9lcnJvcj5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIC8vIHRyaWdnZXIgdGVtcGxhdGUgZnJvbSBjb21wb25lbnQudHNcbiAgICogZXJyb3JUcmlnZ2VyJC5uZXh0KClcbiAgICpcbiAgICogQHBhcmFtIHsgT2JzZXJ2YWJsZTx1bmtub3duPiB9IGVycm9yVHJpZ2dlclxuICAgKi9cbiAgQElucHV0KCdyeElmRXJyb3JUcmlnZ2VyJykgZXJyb3JUcmlnZ2VyPzogT2JzZXJ2YWJsZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgdHJpZ2dlciB0byBtYW51YWxseSBhY3RpdmF0ZSB0aGUgY29tcGxldGUgdGVtcGxhdGUuIEl0IGFjY2VwdHMgYW55IHZhbHVlLFxuICAgKiBvbiBlbWlzc2lvbiBpdCB3aWxsIGRpc3BsYXkgdGhlIGVycm9yIHRlbXBsYXRlLiBJZiBubyB0ZW1wbGF0ZSBpcyBnaXZlbixcbiAgICogdGhlIGNvbXBsZXRlIGNvbnRleHQgdmFyaWFibGUgd2lsbCBjb21wbGV0ZSBzZXQgdG8gdHJ1ZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8bmctY29udGFpbmVyXG4gICAqICAqcnhJZj1cIlxuICAgKiAgICBzaG93JDtcbiAgICogICAgbGV0IGMgPSBjb21wbGV0ZTtcbiAgICogICAgY29tcGxldGVUcmlnZ2VyOiBjb21wbGV0ZVRyaWdnZXIkXG4gICAqIFwiPlxuICAgKlxuICAgKiAgIDxhcHAtaGVybz48L2FwcC1oZXJvPlxuICAgKiAgIDxkb25lICpuZ0lmPVwiY1wiPjwvZG9uZT5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIC8vIHRyaWdnZXIgdGVtcGxhdGUgZnJvbSBjb21wb25lbnQudHNcbiAgICogY29tcGxldGVUcmlnZ2VyJC5uZXh0KClcbiAgICpcbiAgICogQHBhcmFtIHsgT2JzZXJ2YWJsZTx1bmtub3duPiB9IGNvbXBsZXRlVHJpZ2dlclxuICAgKi9cbiAgQElucHV0KCdyeElmQ29tcGxldGVUcmlnZ2VyJykgY29tcGxldGVUcmlnZ2VyPzogT2JzZXJ2YWJsZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFN0cnVjdHVyYWwgZGlyZWN0aXZlcyBtYWludGFpbiBgRW1iZWRkZWRWaWV3YHMgd2l0aGluIGEgY29tcG9uZW50cycgdGVtcGxhdGUuXG4gICAqIERlcGVuZGluZyBvbiB0aGUgYm91bmQgdmFsdWUgYXMgd2VsbCBhcyB0aGUgY29uZmlndXJlZCBgUnhSZW5kZXJTdHJhdGVneWAsXG4gICAqIHVwZGF0ZXMgcHJvY2Vzc2VkIGJ5IHRoZSBgKnJ4SWZgIGRpcmVjdGl2ZSBtaWdodCBiZSBhc3luY2hyb25vdXMuXG4gICAqXG4gICAqIFdoZW5ldmVyIGEgdGVtcGxhdGUgZ2V0cyBpbnNlcnRlZCBpbnRvLCBvciByZW1vdmVkIGZyb20sIGl0cyBwYXJlbnQgY29tcG9uZW50LCB0aGUgZGlyZWN0aXZlIGhhcyB0byBpbmZvcm0gdGhlXG4gICAqICAgcGFyZW50IGluIG9yZGVyIHRvIHVwZGF0ZSBhbnkgdmlldy0gb3IgY29udGVudHF1ZXJ5IChgQFZpZXdDaGlsZGAsIGBAVmlld0NoaWxkcmVuYCwgYEBDb250ZW50Q2hpbGRgLFxuICAgKiAgIGBAQ29udGVudENoaWxkcmVuYCkuXG4gICAqXG4gICAqIFJlYWQgbW9yZSBhYm91dCB0aGlzIGluIHRoZVxuICAgKiBbb2ZmaWNpYWxcbiAgICogICBkb2NzXShodHRwczovL3d3dy5yeC1hbmd1bGFyLmlvL2RvY3MvdGVtcGxhdGUvYXBpL3J4LWlmLWRpcmVjdGl2ZSNsb2NhbC1zdHJhdGVnaWVzLWFuZC12aWV3LWNvbnRlbnQtcXVlcmllcy1wYXJlbnQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgIDxhcHAtY29tcG9uZW50PlxuICAgKiAgICAgIDxhcHAtaXRlbVxuICAgKiAgICAgICAgKnJ4SWY9XCJcbiAgICogICAgICAgICAgc2hvdyQ7XG4gICAqICAgICAgICAgIHBhcmVudDogdHJ1ZTtcbiAgICogICAgICAgIFwiXG4gICAqICAgICAgPlxuICAgKiAgICAgIDwvYXBwLWl0ZW0+XG4gICAqICAgIDwvYXBwLWNvbXBvbmVudD5cbiAgICogICBgXG4gICAqIH0pXG4gICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgKiAgIHNob3ckID0gc3RhdGUuc2VsZWN0KCdzaG93SXRlbScpO1xuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyUGFyZW50XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHRoaXMgZmxhZyB3aWxsIGJlIGRyb3BwZWQgc29vbiwgYXMgaXQgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIHdoZW4gdXNpbmcgc2lnbmFsIGJhc2VkIHZpZXcgJiBjb250ZW50IHF1ZXJpZXNcbiAgICovXG4gIEBJbnB1dCgncnhJZlBhcmVudCcpIHJlbmRlclBhcmVudCA9IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5jb25maWcucGFyZW50O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBmbGFnIHRvIGNvbnRyb2wgd2hldGhlciBgKnJ4SWZgIHRlbXBsYXRlcyBhcmUgY3JlYXRlZCB3aXRoaW4gYE5nWm9uZWAgb3Igbm90LlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZSwgYCpyeElmYCB3aWxsIGNyZWF0ZSBpdHMgYEVtYmVkZGVkVmlld2AgaW5zaWRlIGBOZ1pvbmVgLlxuICAgKlxuICAgKiBFdmVudCBsaXN0ZW5lcnMgbm9ybWFsbHkgdHJpZ2dlciB6b25lLlxuICAgKiBFc3BlY2lhbGx5IGhpZ2ggZnJlcXVlbmN5IGV2ZW50cyBjYW4gY2F1c2UgcGVyZm9ybWFuY2UgaXNzdWVzLlxuICAgKlxuICAgKiBSZWFkIG1vcmUgYWJvdXQgdGhpcyBpbiB0aGVcbiAgICogW29mZmljaWFsIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9hcGkvbGV0LWRpcmVjdGl2ZSN3b3JraW5nLXdpdGgtZXZlbnQtbGlzdGVuZXJzLXBhdGNoem9uZSkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFxcQENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdhcHAtcm9vdCcsXG4gICAqICAgdGVtcGxhdGU6IGBcbiAgICogICAgPGFwcC1jb21wb25lbnQ+XG4gICAqICAgICAgPGFwcC1pdGVtXG4gICAqICAgICAgICAqcnhJZj1cIlxuICAgKiAgICAgICAgICBzaG93JDtcbiAgICogICAgICAgICAgcGF0Y2hab25lOiBmYWxzZTtcbiAgICogICAgICAgIFwiXG4gICAqICAgICAgICAoZHJhZyk9XCJpdGVtRHJhZygkZXZlbnQpXCJcbiAgICogICAgICA+XG4gICAqICAgICAgPC9hcHAtaXRlbT5cbiAgICogICAgPC9hcHAtY29tcG9uZW50PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgc2hvdyQgPSBzdGF0ZS5zZWxlY3QoJ3Nob3dJdGVtJyk7XG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXRjaFpvbmVcbiAgICovXG4gIEBJbnB1dCgncnhJZlBhdGNoWm9uZScpIHBhdGNoWm9uZSA9IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5jb25maWcucGF0Y2hab25lO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBgU3ViamVjdGAgd2hpY2ggZW1pdHMgd2hlbmV2ZXIgYCpyeElmYCByZW5kZXJlZCBhIGNoYW5nZSB0byB0aGUgdmlldy5cbiAgICogVGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gcGVyZm9ybSBhY3Rpb25zIHdoZW4gcmVuZGVyaW5nIGhhcyBiZWVuIGRvbmUuXG4gICAqIFRoZSBgcmVuZGVyQ2FsbGJhY2tgIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdVxuICAgKiByZWx5IG9uIHNwZWNpZmljIERPTSBwcm9wZXJ0aWVzIGxpa2UgdGhlIGRpbWVuc2lvbnMgb2YgYW4gaXRlbSBhZnRlciBpdCBnb3QgcmVuZGVyZWQuXG4gICAqXG4gICAqIFRoZSBgcmVuZGVyQ2FsbGJhY2tgIGVtaXRzIHRoZSBsYXRlc3QgdmFsdWUgY2F1c2luZyB0aGUgdmlldyB0byB1cGRhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFxcQENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdhcHAtcm9vdCcsXG4gICAqICAgdGVtcGxhdGU6IGBcbiAgICogICAgPGFwcC1jb21wb25lbnQ+XG4gICAqICAgICAgPGFwcC1pdGVtXG4gICAqICAgICAgICAqcnhJZj1cIlxuICAgKiAgICAgICAgICBzaG93JDtcbiAgICogICAgICAgICAgcmVuZGVyQ2FsbGJhY2s6IHJlbmRlcmVkO1xuICAgKiAgICAgICAgXCJcbiAgICogICAgICA+XG4gICAqICAgICAgPC9hcHAtaXRlbT5cbiAgICogICAgPC9hcHAtY29tcG9uZW50PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICBzaG93JCA9IHN0YXRlLnNlbGVjdCgnc2hvd0l0ZW0nKTtcbiAgICogIC8vIHRoaXMgZW1pdHMgd2hlbmV2ZXIgcnhJZiBmaW5pc2hlZCByZW5kZXJpbmcgY2hhbmdlc1xuICAgKiAgcmVuZGVyZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+KSB7XG4gICAqICAgICByZW5kZXJlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgKiAgICAgICAvLyBpdGVtIGlzIHJlbmRlcmVkLCB3ZSBjYW4gYWNjZXNzIGl0cyBkb20gbm93XG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge1N1YmplY3Q8Ym9vbGVhbj59IGNhbGxiYWNrXG4gICAqL1xuICBASW5wdXQoJ3J4SWZSZW5kZXJDYWxsYmFjaycpXG4gIHNldCByZW5kZXJDYWxsYmFjayhjYWxsYmFjazogTmV4dE9ic2VydmVyPGJvb2xlYW4+KSB7XG4gICAgdGhpcy5fcmVuZGVyT2JzZXJ2ZXIgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB0cmlnZ2VySGFuZGxlciA9IG5ldyBSZXBsYXlTdWJqZWN0PFJ4Tm90aWZpY2F0aW9uS2luZD4oMSk7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHRlbXBsYXRlTm90aWZpZXIgPSBjcmVhdGVUZW1wbGF0ZU5vdGlmaWVyPFQ+KCk7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHN0cmF0ZWd5SGFuZGxlciA9IGNvZXJjZUFsbEZhY3Rvcnk8UnhTdHJhdGVneU5hbWVzPihcbiAgICAoKSA9PiBuZXcgUmVwbGF5U3ViamVjdDxSeFN0cmF0ZWd5TmFtZXMgfCBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz4+KDEpLFxuICAgIG1lcmdlQWxsKCksXG4gICk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJlZCQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgZ2V0IHRoZW5UZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxSeElmVmlld0NvbnRleHQ8VD4+IHtcbiAgICByZXR1cm4gdGhpcy50aGVuID8gdGhpcy50aGVuIDogdGhpcy50ZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPFJ4SWZWaWV3Q29udGV4dDxUPj4pIHt9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGQoXG4gICAgICBtZXJnZShcbiAgICAgICAgdGhpcy5jb250ZXh0VHJpZ2dlciB8fCBORVZFUixcbiAgICAgICAgdGhpcy5uZXh0VHJpZ2dlcj8ucGlwZShtYXAoKCkgPT4gUnhOb3RpZmljYXRpb25LaW5kLk5leHQpKSB8fCBORVZFUixcbiAgICAgICAgdGhpcy5zdXNwZW5zZVRyaWdnZXI/LnBpcGUobWFwKCgpID0+IFJ4Tm90aWZpY2F0aW9uS2luZC5TdXNwZW5zZSkpIHx8XG4gICAgICAgICAgTkVWRVIsXG4gICAgICAgIHRoaXMuY29tcGxldGVUcmlnZ2VyPy5waXBlKG1hcCgoKSA9PiBSeE5vdGlmaWNhdGlvbktpbmQuQ29tcGxldGUpKSB8fFxuICAgICAgICAgIE5FVkVSLFxuICAgICAgICB0aGlzLmVycm9yVHJpZ2dlcj8ucGlwZShtYXAoKCkgPT4gUnhOb3RpZmljYXRpb25LaW5kLkVycm9yKSkgfHwgTkVWRVIsXG4gICAgICApXG4gICAgICAgIC5waXBlKGZpbHRlcigodikgPT4gISF2KSlcbiAgICAgICAgLnN1YnNjcmliZSgodCkgPT4gdGhpcy50cmlnZ2VySGFuZGxlci5uZXh0KHQpKSxcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyXG4gICAgICAgIC5yZW5kZXIodGhpcy50ZW1wbGF0ZU5vdGlmaWVyLnZhbHVlcyQpXG4gICAgICAgIC5zdWJzY3JpYmUoKG4pID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkJC5uZXh0KG4pO1xuICAgICAgICAgIHRoaXMuX3JlbmRlck9ic2VydmVyPy5uZXh0KG4pO1xuICAgICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRlbXBsYXRlTWFuYWdlcikge1xuICAgICAgdGhpcy5fY3JlYXRlVGVtcGxhdGVNYW5hZ2VyKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMudGhlbiAmJiAhY2hhbmdlcy50aGVuLmZpcnN0Q2hhbmdlKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlTWFuYWdlci5hZGRUZW1wbGF0ZVJlZihcbiAgICAgICAgUnhJZlRlbXBsYXRlTmFtZXMudGhlbixcbiAgICAgICAgdGhpcy50aGVuVGVtcGxhdGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmVsc2UpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyLmFkZFRlbXBsYXRlUmVmKFJ4SWZUZW1wbGF0ZU5hbWVzLmVsc2UsIHRoaXMuZWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuY29tcGxldGUpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyLmFkZFRlbXBsYXRlUmVmKFxuICAgICAgICBSeElmVGVtcGxhdGVOYW1lcy5jb21wbGV0ZSxcbiAgICAgICAgdGhpcy5jb21wbGV0ZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuc3VzcGVuc2UpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyLmFkZFRlbXBsYXRlUmVmKFxuICAgICAgICBSeElmVGVtcGxhdGVOYW1lcy5zdXNwZW5zZSxcbiAgICAgICAgdGhpcy5zdXNwZW5zZSxcbiAgICAgICk7XG4gICAgICB0aGlzLnRlbXBsYXRlTm90aWZpZXIud2l0aEluaXRpYWxTdXNwZW5zZSghIXRoaXMuc3VzcGVuc2UpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmVycm9yKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlTWFuYWdlci5hZGRUZW1wbGF0ZVJlZihSeElmVGVtcGxhdGVOYW1lcy5lcnJvciwgdGhpcy5lcnJvcik7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VzLnJ4SWYpIHtcbiAgICAgIGlmIChpc1NpZ25hbCh0aGlzLnJ4SWYpKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVOb3RpZmllci5uZXh0KFxuICAgICAgICAgIHRvT2JzZXJ2YWJsZSh0aGlzLnJ4SWYsIHsgaW5qZWN0b3I6IHRoaXMuaW5qZWN0b3IgfSksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlbXBsYXRlTm90aWZpZXIubmV4dCh0aGlzLnJ4SWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlVGVtcGxhdGVNYW5hZ2VyKCk6IHZvaWQge1xuICAgIGNvbnN0IGdldE5leHRUZW1wbGF0ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gUnhJZlRlbXBsYXRlTmFtZXMudGhlblxuICAgICAgICA6IHRoaXMuZWxzZVxuICAgICAgICAgID8gUnhJZlRlbXBsYXRlTmFtZXMuZWxzZVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdGhpcy50ZW1wbGF0ZU1hbmFnZXIgPSBjcmVhdGVUZW1wbGF0ZU1hbmFnZXI8XG4gICAgICBULFxuICAgICAgUnhJZlZpZXdDb250ZXh0PFQ+LFxuICAgICAgcnhJZlRlbXBsYXRlTmFtZXNcbiAgICA+KHtcbiAgICAgIHRlbXBsYXRlU2V0dGluZ3M6IHtcbiAgICAgICAgdmlld0NvbnRhaW5lclJlZjogdGhpcy52aWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBjdXN0b21Db250ZXh0OiAocnhJZikgPT4gKHsgcnhJZiB9KSxcbiAgICAgIH0sXG4gICAgICByZW5kZXJTZXR0aW5nczoge1xuICAgICAgICBjZFJlZjogdGhpcy5jZFJlZixcbiAgICAgICAgcGFyZW50OiBjb2VyY2VCb29sZWFuUHJvcGVydHkodGhpcy5yZW5kZXJQYXJlbnQpLFxuICAgICAgICBwYXRjaFpvbmU6IHRoaXMucGF0Y2hab25lID8gdGhpcy5uZ1pvbmUgOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFN0cmF0ZWd5TmFtZTogdGhpcy5zdHJhdGVneVByb3ZpZGVyLnByaW1hcnlTdHJhdGVneSxcbiAgICAgICAgc3RyYXRlZ2llczogdGhpcy5zdHJhdGVneVByb3ZpZGVyLnN0cmF0ZWdpZXMsXG4gICAgICB9LFxuICAgICAgbm90aWZpY2F0aW9uVG9UZW1wbGF0ZU5hbWU6IHtcbiAgICAgICAgW1J4Tm90aWZpY2F0aW9uS2luZC5TdXNwZW5zZV06ICh2YWx1ZSkgPT5cbiAgICAgICAgICB0aGlzLnN1c3BlbnNlID8gUnhJZlRlbXBsYXRlTmFtZXMuc3VzcGVuc2UgOiBnZXROZXh0VGVtcGxhdGUodmFsdWUpLFxuICAgICAgICBbUnhOb3RpZmljYXRpb25LaW5kLk5leHRdOiAodmFsdWUpID0+IGdldE5leHRUZW1wbGF0ZSh2YWx1ZSksXG4gICAgICAgIFtSeE5vdGlmaWNhdGlvbktpbmQuRXJyb3JdOiAodmFsdWUpID0+XG4gICAgICAgICAgdGhpcy5lcnJvciA/IFJ4SWZUZW1wbGF0ZU5hbWVzLmVycm9yIDogZ2V0TmV4dFRlbXBsYXRlKHZhbHVlKSxcbiAgICAgICAgW1J4Tm90aWZpY2F0aW9uS2luZC5Db21wbGV0ZV06ICh2YWx1ZSkgPT5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID8gUnhJZlRlbXBsYXRlTmFtZXMuY29tcGxldGUgOiBnZXROZXh0VGVtcGxhdGUodmFsdWUpLFxuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlVHJpZ2dlciQ6IHRoaXMudHJpZ2dlckhhbmRsZXIsXG4gICAgfSk7XG4gICAgdGhpcy50ZW1wbGF0ZU1hbmFnZXIuYWRkVGVtcGxhdGVSZWYoXG4gICAgICBSeElmVGVtcGxhdGVOYW1lcy50aGVuLFxuICAgICAgdGhpcy50aGVuVGVtcGxhdGUsXG4gICAgKTtcbiAgICB0aGlzLnRlbXBsYXRlTWFuYWdlci5uZXh0U3RyYXRlZ3kodGhpcy5zdHJhdGVneUhhbmRsZXIudmFsdWVzJCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBzdGF0aWMgcnhJZlVzZUlmVHlwZUd1YXJkOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhlIGNvcnJlY3QgdHlwZSBvZiB0aGUgZXhwcmVzc2lvbiBib3VuZCB0byB0aGUgYG5nSWZgIGlucHV0IHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gICAqXG4gICAqIFRoZSBwcmVzZW5jZSBvZiB0aGlzIHN0YXRpYyBmaWVsZCBpcyBhIHNpZ25hbCB0byB0aGUgSXZ5IHRlbXBsYXRlIHR5cGUgY2hlY2sgY29tcGlsZXIgdGhhdFxuICAgKiB3aGVuIHRoZSBgTmdJZmAgc3RydWN0dXJhbCBkaXJlY3RpdmUgcmVuZGVycyBpdHMgdGVtcGxhdGUsIHRoZSB0eXBlIG9mIHRoZSBleHByZXNzaW9uIGJvdW5kXG4gICAqIHRvIGBuZ0lmYCBzaG91bGQgYmUgbmFycm93ZWQgaW4gc29tZSB3YXkuIEZvciBgTmdJZmAsIHRoZSBiaW5kaW5nIGV4cHJlc3Npb24gaXRzZWxmIGlzIHVzZWQgdG9cbiAgICogbmFycm93IGl0cyB0eXBlLCB3aGljaCBhbGxvd3MgdGhlIHN0cmljdE51bGxDaGVja3MgZmVhdHVyZSBvZiBUeXBlU2NyaXB0IHRvIHdvcmsgd2l0aCBgTmdJZmAuXG4gICAqL1xuICBzdGF0aWMgbmdUZW1wbGF0ZUd1YXJkX3J4SWY6ICdiaW5kaW5nJztcblxuICAvKipcbiAgICogQXNzZXJ0cyB0aGUgY29ycmVjdCB0eXBlIG9mIHRoZSBjb250ZXh0IGZvciB0aGUgdGVtcGxhdGUgdGhhdCBgTmdJZmAgd2lsbCByZW5kZXIuXG4gICAqXG4gICAqIFRoZSBwcmVzZW5jZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHNpZ25hbCB0byB0aGUgSXZ5IHRlbXBsYXRlIHR5cGUtY2hlY2sgY29tcGlsZXIgdGhhdCB0aGVcbiAgICogYE5nSWZgIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHJlbmRlcnMgaXRzIHRlbXBsYXRlIHdpdGggYSBzcGVjaWZpYyBjb250ZXh0IHR5cGUuXG4gICAqL1xuICBzdGF0aWMgbmdUZW1wbGF0ZUNvbnRleHRHdWFyZDxUPihcbiAgICBkaXI6IFJ4SWY8VD4sXG4gICAgY3R4OiBhbnksXG4gICk6IGN0eCBpcyBSeElmVmlld0NvbnRleHQ8RXhjbHVkZTxULCBmYWxzZSB8IDAgfCAnJyB8IG51bGwgfCB1bmRlZmluZWQ+PiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBkZXNjcmlwdGlvblxuICogQ29lcmNlcyBhIGRhdGEtYm91bmQgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZykgdG8gYSBib29sZWFuLlxuICpcbiAqL1xuZnVuY3Rpb24gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGAke3ZhbHVlfWAgIT09ICdmYWxzZSc7XG59XG4iXX0=