import { ChangeDetectorRef, Directive, ErrorHandler, inject, Injector, Input, isSignal, IterableDiffers, NgZone, TemplateRef, ViewContainerRef, } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { coerceDistinctWith, coerceObservableWith, } from '@rx-angular/cdk/coercing';
import { RxStrategyProvider, } from '@rx-angular/cdk/render-strategies';
import { createListTemplateManager, } from '@rx-angular/cdk/template';
import { isObservable, ReplaySubject, Subject, Subscription, } from 'rxjs';
import { shareReplay, switchAll } from 'rxjs/operators';
import { RxForViewContext } from './for-view-context';
import * as i0 from "@angular/core";
/**
 * @Directive RxFor
 *
 * @description
 *
 * The most common way to render lists in angular is by using the `*ngFor` structural directive. `*ngFor` is able
 * to take an arbitrary list of data and repeat a defined template per item of the list. However, it can
 * only do it synchronously.
 *
 * Compared to the `NgFor`, `RxFor` treats each child template as single renderable unit.
 * The change detection of the child templates get prioritized, scheduled and executed by
 * leveraging `RenderStrategies` under the hood.
 * This technique enables non-blocking rendering of lists and can be referred to as `concurrent mode`.
 *
 * Read more about this in the [strategies
 * section](https://www.rx-angular.io/docs/template/api/rx-for-directive#rxfor-with-concurrent-strategies).
 *
 * Furthermore, `RxFor` provides hooks to react to rendered items in form of a `renderCallback: Subject`.
 *
 * Together with the `RxRenderStrategies`, this makes the rendering behavior extremely versatile
 * and transparent for the developer.
 * Each instance of `RxFor` can be configured to render with different settings.
 *
 * Read more in the [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive)
 *
 * @docsCategory RxFor
 * @docsPage RxFor
 * @publicApi
 */
export class RxFor {
    templateRef;
    /** @internal */
    iterableDiffers = inject(IterableDiffers);
    /** @internal */
    cdRef = inject(ChangeDetectorRef);
    /** @internal */
    ngZone = inject(NgZone);
    /** @internal */
    injector = inject(Injector);
    /** @internal */
    viewContainerRef = inject(ViewContainerRef);
    /** @internal */
    strategyProvider = inject(RxStrategyProvider);
    /** @internal */
    errorHandler = inject(ErrorHandler);
    /** @internal */
    staticValue;
    /** @internal */
    renderStatic = false;
    /**
     * @description
     * The iterable input
     *
     * @example
     * <ng-container *rxFor="heroes$; let hero">
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     *
     * @param { Observable<(U & NgIterable<T>) | undefined | null>
     *       | Signal<(U & NgIterable<T>) | undefined | null>
     *       | (U & NgIterable<T>)
     *       | null
     *       | undefined } potentialSignalOrObservable
     */
    set rxForOf(potentialSignalOrObservable) {
        if (isSignal(potentialSignalOrObservable)) {
            this.staticValue = undefined;
            this.renderStatic = false;
            this.observables$.next(toObservable(potentialSignalOrObservable, { injector: this.injector }));
        }
        else if (!isObservable(potentialSignalOrObservable)) {
            this.staticValue = potentialSignalOrObservable;
            this.renderStatic = true;
        }
        else {
            this.staticValue = undefined;
            this.renderStatic = false;
            this.observables$.next(potentialSignalOrObservable);
        }
    }
    /**
     * @internal
     * A reference to the template that is created for each item in the iterable.
     * @see [template reference variable](guide/template-reference-variables)
     * (inspired by @angular/common `ng_for_of.ts`)
     */
    _template;
    set rxForTemplate(value) {
        this._template = value;
    }
    /**
     * @description
     *
     * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxFor`. It accepts
     * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).
     *
     * The default value for strategy is
     * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive#use-render-strategies-strategy).
     *
     * @example
     *
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *     <ng-container *rxFor="let hero of heroes$; strategy: strategy">
     *       <app-hero [hero]="hero"></app-hero>
     *     </ng-container>
     *
     *     <ng-container *rxFor="let hero of heroes$; strategy: strategy$">
     *       <app-hero [hero]="hero"></app-hero>
     *     </ng-container>
     *   `
     * })
     * export class AppComponent {
     *   strategy = 'low';
     *   strategy$ = of('immediate');
     * }
     *
     * @param {string | Observable<string> | undefined} strategyName
     * @see {@link strategies}
     */
    set rxForStrategy(strategyName) {
        this.strategyInput$.next(strategyName);
    }
    /**
     * @description
     *
     * When local rendering strategies are used, we need to treat view and content queries in a
     * special way.
     * To make `*rxFor` in such situations, a certain mechanism is implemented to
     * execute change detection on the parent (`parent`).
     *
     * This is required if your components state is dependent on its view or content children:
     *
     * - `@ViewChild`
     * - `@ViewChildren`
     * - `@ContentChild`
     * - `@ContentChildren`
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive#local-strategies-and-view-content-queries-parent).
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-list-component>
     *      <app-list-item
     *        *rxFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *          parent: true;
     *        "
     *      >
     *        <div>{{ item.name }}</div>
     *      </app-list-item>
     *    </app-list-component>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     * }
     *
     * @param {boolean} renderParent
     *
     * @deprecated this flag will be dropped soon, as it is no longer required when using signal based view & content queries
     */
    renderParent = this.strategyProvider.config.parent;
    /**
     * @description
     *
     * A flag to control whether *rxFor templates are created within `NgZone` or not.
     * The default value is `true, `*rxFor` will create it's `EmbeddedViews` inside `NgZone`.
     *
     * Event listeners normally trigger zone. Especially high frequently events cause performance issues.
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive#working-with-event-listeners-patchzone).
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-list-component>
     *      <app-list-item
     *        *rxFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *          patchZone: false;
     *        "
     *      >
     *        <div>{{ item.name }}</div>
     *      </app-list-item>
     *    </app-list-component>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     * }
     *
     * @param {boolean} patchZone
     */
    patchZone = this.strategyProvider.config.patchZone;
    /**
     * @description
     * A function or key that defines how to track changes for items in the iterable.
     *
     * When items are added, moved, or removed in the iterable,
     * the directive must re-render the appropriate DOM nodes.
     * To minimize churn in the DOM, only nodes that have changed
     * are re-rendered.
     *
     * By default, rxFor assumes that the object instance identifies the node in the iterable (equality check `===`).
     * When a function or key is supplied, rxFor uses the result to identify the item node.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-list-component>
     *      <app-list-item
     *        *rxFor="
     *          let item of items$;
     *          trackBy: 'id';
     *        "
     *      >
     *        <div>{{ item.name }}</div>
     *      </app-list-item>
     *    </app-list-component>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     * }
     *
     * // OR
     *
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-list-component>
     *      <app-list-item
     *        *rxFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *        "
     *      >
     *        <div>{{ item.name }}</div>
     *      </app-list-item>
     *    </app-list-component>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     *   trackItem = (idx, item) => item.id;
     * }
     *
     * @param trackByFnOrKey
     */
    set trackBy(trackByFnOrKey) {
        if ((typeof ngDevMode === 'undefined' || ngDevMode) &&
            trackByFnOrKey != null &&
            typeof trackByFnOrKey !== 'string' &&
            typeof trackByFnOrKey !== 'function') {
            console.warn(`trackBy must be a function, but received ${JSON.stringify(trackByFnOrKey)}.`);
        }
        if (trackByFnOrKey == null) {
            this._trackBy = null;
        }
        else {
            this._trackBy =
                typeof trackByFnOrKey !== 'function'
                    ? (i, a) => a[trackByFnOrKey]
                    : trackByFnOrKey;
        }
    }
    /**
     * @description
     * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.
     * This enables developers to perform actions when a list has finished rendering.
     * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a
     * table after all items got rendered.
     * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This
     * way developers can hide a list as long as it has not finished rendering.
     *
     * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.
     *
     * @example
     * \Component({
     *   selector: 'app-root',
     *   template: `
     *   <app-list-component>
     *     <app-list-item
     *       *rxFor="
     *         let item of items$;
     *         trackBy: trackItem;
     *         renderCallback: itemsRendered;
     *       ">
     *       <div>{{ item.name }}</div>
     *     </app-list-item>
     *   </app-list-component>
     * `
     * })
     * export class AppComponent {
     *   items$: Observable<Item[]> = itemService.getItems();
     *   trackItem = (idx, item) => item.id;
     *   // this emits whenever rxFor finished rendering changes
     *   itemsRendered = new Subject<Item[]>();
     *
     *   constructor(elementRef: ElementRef<HTMLElement>) {
     *     itemsRendered.subscribe(() => {
     *       // items are rendered, we can now scroll
     *       elementRef.scrollTo({bottom: 0});
     *     })
     *   }
     * }
     *
     * @param {Subject<U>} renderCallback
     */
    set renderCallback(renderCallback) {
        this._renderCallback = renderCallback;
    }
    get template() {
        return this._template || this.templateRef;
    }
    /** @internal */
    strategyInput$ = new ReplaySubject(1);
    /** @internal */
    observables$ = new ReplaySubject(1);
    /** @internal */
    _renderCallback;
    /** @internal */
    values$ = this.observables$.pipe(coerceObservableWith(), switchAll(), shareReplay({ refCount: true, bufferSize: 1 }));
    /** @internal */
    values = null;
    /** @internal */
    strategy$ = this.strategyInput$.pipe(coerceDistinctWith());
    /** @internal */
    listManager;
    /** @internal */
    _subscription = new Subscription();
    /** @internal */
    _trackBy;
    /** @internal */
    _distinctBy = (a, b) => a === b;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    /** @internal */
    ngOnInit() {
        this._subscription.add(this.values$.subscribe((v) => (this.values = v)));
        this.listManager = createListTemplateManager({
            iterableDiffers: this.iterableDiffers,
            renderSettings: {
                cdRef: this.cdRef,
                strategies: this.strategyProvider.strategies, // TODO: move strategyProvider
                defaultStrategyName: this.strategyProvider.primaryStrategy,
                parent: !!this.renderParent,
                patchZone: this.patchZone ? this.ngZone : false,
                errorHandler: this.errorHandler,
            },
            templateSettings: {
                viewContainerRef: this.viewContainerRef,
                templateRef: this.template,
                createViewContext: this.createViewContext.bind(this),
                updateViewContext: this.updateViewContext.bind(this),
            },
            trackBy: this._trackBy,
        });
        this.listManager.nextStrategy(this.strategy$);
        this._subscription.add(this.listManager
            .render(this.values$)
            .subscribe((v) => this._renderCallback?.next(v)));
    }
    /** @internal */
    createViewContext(item, computedContext) {
        return new RxForViewContext(item, this.values, computedContext);
    }
    /** @internal */
    updateViewContext(item, view, computedContext) {
        view.context.updateContext(computedContext);
        view.context.rxForOf = this.values;
        view.context.$implicit = item;
    }
    /** @internal */
    ngDoCheck() {
        if (this.renderStatic) {
            this.observables$.next(this.staticValue);
        }
    }
    /** @internal */
    ngOnDestroy() {
        this._subscription.unsubscribe();
        this.viewContainerRef.clear();
    }
    /** @internal */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxFor, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: RxFor, isStandalone: true, selector: "[rxFor][rxForOf]", inputs: { rxForOf: "rxForOf", rxForTemplate: "rxForTemplate", rxForStrategy: "rxForStrategy", renderParent: ["rxForParent", "renderParent"], patchZone: ["rxForPatchZone", "patchZone"], trackBy: ["rxForTrackBy", "trackBy"], renderCallback: ["rxForRenderCallback", "renderCallback"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxFor, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rxFor][rxForOf]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }], propDecorators: { rxForOf: [{
                type: Input
            }], rxForTemplate: [{
                type: Input
            }], rxForStrategy: [{
                type: Input
            }], renderParent: [{
                type: Input,
                args: ['rxForParent']
            }], patchZone: [{
                type: Input,
                args: ['rxForPatchZone']
            }], trackBy: [{
                type: Input,
                args: ['rxForTrackBy']
            }], renderCallback: [{
                type: Input,
                args: ['rxForRenderCallback']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvdGVtcGxhdGUvZm9yL3NyYy9saWIvZm9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFNBQVMsRUFHVCxZQUFZLEVBQ1osTUFBTSxFQUNOLFFBQVEsRUFDUixLQUFLLEVBQ0wsUUFBUSxFQUNSLGVBQWUsRUFFZixNQUFNLEVBSU4sV0FBVyxFQUVYLGdCQUFnQixHQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDMUQsT0FBTyxFQUNMLGtCQUFrQixFQUNsQixvQkFBb0IsR0FDckIsTUFBTSwwQkFBMEIsQ0FBQztBQUNsQyxPQUFPLEVBRUwsa0JBQWtCLEdBQ25CLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUNMLHlCQUF5QixHQUcxQixNQUFNLDBCQUEwQixDQUFDO0FBQ2xDLE9BQU8sRUFDTCxZQUFZLEVBRVosYUFBYSxFQUNiLE9BQU8sRUFDUCxZQUFZLEdBQ2IsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQVF0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRCRztBQUtILE1BQU0sT0FBTyxLQUFLO0lBNldHO0lBMVduQixnQkFBZ0I7SUFDUixlQUFlLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ2xELGdCQUFnQjtJQUNSLEtBQUssR0FBRyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUMxQyxnQkFBZ0I7SUFDUixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLGdCQUFn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cGJVLEtBQUs7OEdBQUwsS0FBSzs7MkZBQUwsS0FBSztrQkFKakIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsa0JBQWtCO29CQUM1QixVQUFVLEVBQUUsSUFBSTtpQkFDakI7Z0ZBd0NLLE9BQU87c0JBRFYsS0FBSztnQkFpQ0YsYUFBYTtzQkFEaEIsS0FBSztnQkF3Q0YsYUFBYTtzQkFEaEIsS0FBSztnQkFrRGdCLFlBQVk7c0JBQWpDLEtBQUs7dUJBQUMsYUFBYTtnQkFvQ0ssU0FBUztzQkFBakMsS0FBSzt1QkFBQyxnQkFBZ0I7Z0JBNERuQixPQUFPO3NCQUZWLEtBQUs7dUJBQUMsY0FBYztnQkFvRWEsY0FBYztzQkFBL0MsS0FBSzt1QkFBQyxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRGlyZWN0aXZlLFxuICBEb0NoZWNrLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIEVycm9ySGFuZGxlcixcbiAgaW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIGlzU2lnbmFsLFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIE5nSXRlcmFibGUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFNpZ25hbCxcbiAgVGVtcGxhdGVSZWYsXG4gIFRyYWNrQnlGdW5jdGlvbixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0b09ic2VydmFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQge1xuICBjb2VyY2VEaXN0aW5jdFdpdGgsXG4gIGNvZXJjZU9ic2VydmFibGVXaXRoLFxufSBmcm9tICdAcngtYW5ndWxhci9jZGsvY29lcmNpbmcnO1xuaW1wb3J0IHtcbiAgUnhTdHJhdGVneU5hbWVzLFxuICBSeFN0cmF0ZWd5UHJvdmlkZXIsXG59IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9yZW5kZXItc3RyYXRlZ2llcyc7XG5pbXBvcnQge1xuICBjcmVhdGVMaXN0VGVtcGxhdGVNYW5hZ2VyLFxuICBSeExpc3RNYW5hZ2VyLFxuICBSeExpc3RWaWV3Q29tcHV0ZWRDb250ZXh0LFxufSBmcm9tICdAcngtYW5ndWxhci9jZGsvdGVtcGxhdGUnO1xuaW1wb3J0IHtcbiAgaXNPYnNlcnZhYmxlLFxuICBPYnNlcnZhYmxlLFxuICBSZXBsYXlTdWJqZWN0LFxuICBTdWJqZWN0LFxuICBTdWJzY3JpcHRpb24sXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2hhcmVSZXBsYXksIHN3aXRjaEFsbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFJ4Rm9yVmlld0NvbnRleHQgfSBmcm9tICcuL2Zvci12aWV3LWNvbnRleHQnO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBXaWxsIGJlIHByb3ZpZGVkIHRocm91Z2ggVGVyc2VyIGdsb2JhbCBkZWZpbml0aW9ucyBieSBBbmd1bGFyIENMSVxuICogZHVyaW5nIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLlxuICovXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuLyoqXG4gKiBARGlyZWN0aXZlIFJ4Rm9yXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIHdheSB0byByZW5kZXIgbGlzdHMgaW4gYW5ndWxhciBpcyBieSB1c2luZyB0aGUgYCpuZ0ZvcmAgc3RydWN0dXJhbCBkaXJlY3RpdmUuIGAqbmdGb3JgIGlzIGFibGVcbiAqIHRvIHRha2UgYW4gYXJiaXRyYXJ5IGxpc3Qgb2YgZGF0YSBhbmQgcmVwZWF0IGEgZGVmaW5lZCB0ZW1wbGF0ZSBwZXIgaXRlbSBvZiB0aGUgbGlzdC4gSG93ZXZlciwgaXQgY2FuXG4gKiBvbmx5IGRvIGl0IHN5bmNocm9ub3VzbHkuXG4gKlxuICogQ29tcGFyZWQgdG8gdGhlIGBOZ0ZvcmAsIGBSeEZvcmAgdHJlYXRzIGVhY2ggY2hpbGQgdGVtcGxhdGUgYXMgc2luZ2xlIHJlbmRlcmFibGUgdW5pdC5cbiAqIFRoZSBjaGFuZ2UgZGV0ZWN0aW9uIG9mIHRoZSBjaGlsZCB0ZW1wbGF0ZXMgZ2V0IHByaW9yaXRpemVkLCBzY2hlZHVsZWQgYW5kIGV4ZWN1dGVkIGJ5XG4gKiBsZXZlcmFnaW5nIGBSZW5kZXJTdHJhdGVnaWVzYCB1bmRlciB0aGUgaG9vZC5cbiAqIFRoaXMgdGVjaG5pcXVlIGVuYWJsZXMgbm9uLWJsb2NraW5nIHJlbmRlcmluZyBvZiBsaXN0cyBhbmQgY2FuIGJlIHJlZmVycmVkIHRvIGFzIGBjb25jdXJyZW50IG1vZGVgLlxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCB0aGlzIGluIHRoZSBbc3RyYXRlZ2llc1xuICogc2VjdGlvbl0oaHR0cHM6Ly93d3cucngtYW5ndWxhci5pby9kb2NzL3RlbXBsYXRlL2FwaS9yeC1mb3ItZGlyZWN0aXZlI3J4Zm9yLXdpdGgtY29uY3VycmVudC1zdHJhdGVnaWVzKS5cbiAqXG4gKiBGdXJ0aGVybW9yZSwgYFJ4Rm9yYCBwcm92aWRlcyBob29rcyB0byByZWFjdCB0byByZW5kZXJlZCBpdGVtcyBpbiBmb3JtIG9mIGEgYHJlbmRlckNhbGxiYWNrOiBTdWJqZWN0YC5cbiAqXG4gKiBUb2dldGhlciB3aXRoIHRoZSBgUnhSZW5kZXJTdHJhdGVnaWVzYCwgdGhpcyBtYWtlcyB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIGV4dHJlbWVseSB2ZXJzYXRpbGVcbiAqIGFuZCB0cmFuc3BhcmVudCBmb3IgdGhlIGRldmVsb3Blci5cbiAqIEVhY2ggaW5zdGFuY2Ugb2YgYFJ4Rm9yYCBjYW4gYmUgY29uZmlndXJlZCB0byByZW5kZXIgd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3MuXG4gKlxuICogUmVhZCBtb3JlIGluIHRoZSBbb2ZmaWNpYWwgZG9jc10oaHR0cHM6Ly93d3cucngtYW5ndWxhci5pby9kb2NzL3RlbXBsYXRlL2FwaS9yeC1mb3ItZGlyZWN0aXZlKVxuICpcbiAqIEBkb2NzQ2F0ZWdvcnkgUnhGb3JcbiAqIEBkb2NzUGFnZSBSeEZvclxuICogQHB1YmxpY0FwaVxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcnhGb3JdW3J4Rm9yT2ZdJyxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgUnhGb3I8VCwgVSBleHRlbmRzIE5nSXRlcmFibGU8VD4gPSBOZ0l0ZXJhYmxlPFQ+PlxuICBpbXBsZW1lbnRzIE9uSW5pdCwgRG9DaGVjaywgT25EZXN0cm95XG57XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBpdGVyYWJsZURpZmZlcnMgPSBpbmplY3QoSXRlcmFibGVEaWZmZXJzKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGNkUmVmID0gaW5qZWN0KENoYW5nZURldGVjdG9yUmVmKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgaW5qZWN0b3IgPSBpbmplY3QoSW5qZWN0b3IpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZiA9IGluamVjdChWaWV3Q29udGFpbmVyUmVmKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0cmF0ZWd5UHJvdmlkZXIgPSBpbmplY3QoUnhTdHJhdGVneVByb3ZpZGVyKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGVycm9ySGFuZGxlciA9IGluamVjdChFcnJvckhhbmRsZXIpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWNWYWx1ZT86IFU7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSByZW5kZXJTdGF0aWMgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpdGVyYWJsZSBpbnB1dFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8bmctY29udGFpbmVyICpyeEZvcj1cImhlcm9lcyQ7IGxldCBoZXJvXCI+XG4gICAqICAgPGFwcC1oZXJvIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiA8L25nLWNvbnRhaW5lcj5cbiAgICpcbiAgICogQHBhcmFtIHsgT2JzZXJ2YWJsZTwoVSAmIE5nSXRlcmFibGU8VD4pIHwgdW5kZWZpbmVkIHwgbnVsbD5cbiAgICogICAgICAgfCBTaWduYWw8KFUgJiBOZ0l0ZXJhYmxlPFQ+KSB8IHVuZGVmaW5lZCB8IG51bGw+XG4gICAqICAgICAgIHwgKFUgJiBOZ0l0ZXJhYmxlPFQ+KVxuICAgKiAgICAgICB8IG51bGxcbiAgICogICAgICAgfCB1bmRlZmluZWQgfSBwb3RlbnRpYWxTaWduYWxPck9ic2VydmFibGVcbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCByeEZvck9mKFxuICAgIHBvdGVudGlhbFNpZ25hbE9yT2JzZXJ2YWJsZTpcbiAgICAgIHwgT2JzZXJ2YWJsZTwoVSAmIE5nSXRlcmFibGU8VD4pIHwgdW5kZWZpbmVkIHwgbnVsbD5cbiAgICAgIHwgU2lnbmFsPChVICYgTmdJdGVyYWJsZTxUPikgfCB1bmRlZmluZWQgfCBudWxsPlxuICAgICAgfCAoVSAmIE5nSXRlcmFibGU8VD4pXG4gICAgICB8IG51bGxcbiAgICAgIHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICBpZiAoaXNTaWduYWwocG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlKSkge1xuICAgICAgdGhpcy5zdGF0aWNWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVuZGVyU3RhdGljID0gZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmFibGVzJC5uZXh0KFxuICAgICAgICB0b09ic2VydmFibGUocG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlLCB7IGluamVjdG9yOiB0aGlzLmluamVjdG9yIH0pLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc09ic2VydmFibGUocG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlKSkge1xuICAgICAgdGhpcy5zdGF0aWNWYWx1ZSA9IHBvdGVudGlhbFNpZ25hbE9yT2JzZXJ2YWJsZTtcbiAgICAgIHRoaXMucmVuZGVyU3RhdGljID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0aWNWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVuZGVyU3RhdGljID0gZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmFibGVzJC5uZXh0KHBvdGVudGlhbFNpZ25hbE9yT2JzZXJ2YWJsZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgdGVtcGxhdGUgdGhhdCBpcyBjcmVhdGVkIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGl0ZXJhYmxlLlxuICAgKiBAc2VlIFt0ZW1wbGF0ZSByZWZlcmVuY2UgdmFyaWFibGVdKGd1aWRlL3RlbXBsYXRlLXJlZmVyZW5jZS12YXJpYWJsZXMpXG4gICAqIChpbnNwaXJlZCBieSBAYW5ndWxhci9jb21tb24gYG5nX2Zvcl9vZi50c2ApXG4gICAqL1xuICBwcml2YXRlIF90ZW1wbGF0ZTogVGVtcGxhdGVSZWY8UnhGb3JWaWV3Q29udGV4dDxULCBVPj47XG4gIEBJbnB1dCgpXG4gIHNldCByeEZvclRlbXBsYXRlKHZhbHVlOiBUZW1wbGF0ZVJlZjxSeEZvclZpZXdDb250ZXh0PFQsIFU+Pikge1xuICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFlvdSBjYW4gY2hhbmdlIHRoZSB1c2VkIGBSZW5kZXJTdHJhdGVneWAgYnkgdXNpbmcgdGhlIGBzdHJhdGVneWAgaW5wdXQgb2YgdGhlIGAqcnhGb3JgLiBJdCBhY2NlcHRzXG4gICAqIGFuIGBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz5gIG9yIFtgUnhTdHJhdGVneU5hbWVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3J4LWFuZ3VsYXIvcngtYW5ndWxhci9ibG9iL2IwNjMwZjY5MDE3Y2MxODcxZDA5M2U5NzYwMDYwNjZkNWYyMDA1YjkvbGlicy9jZGsvcmVuZGVyLXN0cmF0ZWdpZXMvc3JjL2xpYi9tb2RlbC50cyNMNTIpLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3Igc3RyYXRlZ3kgaXNcbiAgICogW2Bub3JtYWxgXShodHRwczovL3d3dy5yeC1hbmd1bGFyLmlvL2RvY3MvdGVtcGxhdGUvY2RrL3JlbmRlci1zdHJhdGVnaWVzL3N0cmF0ZWdpZXMvY29uY3VycmVudC1zdHJhdGVnaWVzKS5cbiAgICpcbiAgICogUmVhZCBtb3JlIGFib3V0IHRoaXMgaW4gdGhlXG4gICAqIFtvZmZpY2lhbCBkb2NzXShodHRwczovL3d3dy5yeC1hbmd1bGFyLmlvL2RvY3MvdGVtcGxhdGUvYXBpL3J4LWZvci1kaXJlY3RpdmUjdXNlLXJlbmRlci1zdHJhdGVnaWVzLXN0cmF0ZWd5KS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXFxAQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgICogICB0ZW1wbGF0ZTogYFxuICAgKiAgICAgPG5nLWNvbnRhaW5lciAqcnhGb3I9XCJsZXQgaGVybyBvZiBoZXJvZXMkOyBzdHJhdGVneTogc3RyYXRlZ3lcIj5cbiAgICogICAgICAgPGFwcC1oZXJvIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiAgICAgPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqICAgICA8bmctY29udGFpbmVyICpyeEZvcj1cImxldCBoZXJvIG9mIGhlcm9lcyQ7IHN0cmF0ZWd5OiBzdHJhdGVneSRcIj5cbiAgICogICAgICAgPGFwcC1oZXJvIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiAgICAgPC9uZy1jb250YWluZXI+XG4gICAqICAgYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICBzdHJhdGVneSA9ICdsb3cnO1xuICAgKiAgIHN0cmF0ZWd5JCA9IG9mKCdpbW1lZGlhdGUnKTtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPiB8IHVuZGVmaW5lZH0gc3RyYXRlZ3lOYW1lXG4gICAqIEBzZWUge0BsaW5rIHN0cmF0ZWdpZXN9XG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgcnhGb3JTdHJhdGVneShcbiAgICBzdHJhdGVneU5hbWU6IFJ4U3RyYXRlZ3lOYW1lcyB8IE9ic2VydmFibGU8UnhTdHJhdGVneU5hbWVzPiB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgdGhpcy5zdHJhdGVneUlucHV0JC5uZXh0KHN0cmF0ZWd5TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFdoZW4gbG9jYWwgcmVuZGVyaW5nIHN0cmF0ZWdpZXMgYXJlIHVzZWQsIHdlIG5lZWQgdG8gdHJlYXQgdmlldyBhbmQgY29udGVudCBxdWVyaWVzIGluIGFcbiAgICogc3BlY2lhbCB3YXkuXG4gICAqIFRvIG1ha2UgYCpyeEZvcmAgaW4gc3VjaCBzaXR1YXRpb25zLCBhIGNlcnRhaW4gbWVjaGFuaXNtIGlzIGltcGxlbWVudGVkIHRvXG4gICAqIGV4ZWN1dGUgY2hhbmdlIGRldGVjdGlvbiBvbiB0aGUgcGFyZW50IChgcGFyZW50YCkuXG4gICAqXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgaWYgeW91ciBjb21wb25lbnRzIHN0YXRlIGlzIGRlcGVuZGVudCBvbiBpdHMgdmlldyBvciBjb250ZW50IGNoaWxkcmVuOlxuICAgKlxuICAgKiAtIGBAVmlld0NoaWxkYFxuICAgKiAtIGBAVmlld0NoaWxkcmVuYFxuICAgKiAtIGBAQ29udGVudENoaWxkYFxuICAgKiAtIGBAQ29udGVudENoaWxkcmVuYFxuICAgKlxuICAgKiBSZWFkIG1vcmUgYWJvdXQgdGhpcyBpbiB0aGVcbiAgICogW29mZmljaWFsIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9hcGkvcngtZm9yLWRpcmVjdGl2ZSNsb2NhbC1zdHJhdGVnaWVzLWFuZC12aWV3LWNvbnRlbnQtcXVlcmllcy1wYXJlbnQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgIDxhcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgICpyeEZvcj1cIlxuICAgKiAgICAgICAgICBsZXQgaXRlbSBvZiBpdGVtcyQ7XG4gICAqICAgICAgICAgIHRyYWNrQnk6IHRyYWNrSXRlbTtcbiAgICogICAgICAgICAgcGFyZW50OiB0cnVlO1xuICAgKiAgICAgICAgXCJcbiAgICogICAgICA+XG4gICAqICAgICAgICA8ZGl2Pnt7IGl0ZW0ubmFtZSB9fTwvZGl2PlxuICAgKiAgICAgIDwvYXBwLWxpc3QtaXRlbT5cbiAgICogICAgPC9hcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICBpdGVtcyQgPSBpdGVtU2VydmljZS5nZXRJdGVtcygpO1xuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyUGFyZW50XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHRoaXMgZmxhZyB3aWxsIGJlIGRyb3BwZWQgc29vbiwgYXMgaXQgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIHdoZW4gdXNpbmcgc2lnbmFsIGJhc2VkIHZpZXcgJiBjb250ZW50IHF1ZXJpZXNcbiAgICovXG4gIEBJbnB1dCgncnhGb3JQYXJlbnQnKSByZW5kZXJQYXJlbnQgPSB0aGlzLnN0cmF0ZWd5UHJvdmlkZXIuY29uZmlnLnBhcmVudDtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIEEgZmxhZyB0byBjb250cm9sIHdoZXRoZXIgKnJ4Rm9yIHRlbXBsYXRlcyBhcmUgY3JlYXRlZCB3aXRoaW4gYE5nWm9uZWAgb3Igbm90LlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZSwgYCpyeEZvcmAgd2lsbCBjcmVhdGUgaXQncyBgRW1iZWRkZWRWaWV3c2AgaW5zaWRlIGBOZ1pvbmVgLlxuICAgKlxuICAgKiBFdmVudCBsaXN0ZW5lcnMgbm9ybWFsbHkgdHJpZ2dlciB6b25lLiBFc3BlY2lhbGx5IGhpZ2ggZnJlcXVlbnRseSBldmVudHMgY2F1c2UgcGVyZm9ybWFuY2UgaXNzdWVzLlxuICAgKlxuICAgKiBSZWFkIG1vcmUgYWJvdXQgdGhpcyBpbiB0aGVcbiAgICogW29mZmljaWFsIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9hcGkvcngtZm9yLWRpcmVjdGl2ZSN3b3JraW5nLXdpdGgtZXZlbnQtbGlzdGVuZXJzLXBhdGNoem9uZSkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFxcQENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdhcHAtcm9vdCcsXG4gICAqICAgdGVtcGxhdGU6IGBcbiAgICogICAgPGFwcC1saXN0LWNvbXBvbmVudD5cbiAgICogICAgICA8YXBwLWxpc3QtaXRlbVxuICAgKiAgICAgICAgKnJ4Rm9yPVwiXG4gICAqICAgICAgICAgIGxldCBpdGVtIG9mIGl0ZW1zJDtcbiAgICogICAgICAgICAgdHJhY2tCeTogdHJhY2tJdGVtO1xuICAgKiAgICAgICAgICBwYXRjaFpvbmU6IGZhbHNlO1xuICAgKiAgICAgICAgXCJcbiAgICogICAgICA+XG4gICAqICAgICAgICA8ZGl2Pnt7IGl0ZW0ubmFtZSB9fTwvZGl2PlxuICAgKiAgICAgIDwvYXBwLWxpc3QtaXRlbT5cbiAgICogICAgPC9hcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICBpdGVtcyQgPSBpdGVtU2VydmljZS5nZXRJdGVtcygpO1xuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGF0Y2hab25lXG4gICAqL1xuICBASW5wdXQoJ3J4Rm9yUGF0Y2hab25lJykgcGF0Y2hab25lID0gdGhpcy5zdHJhdGVneVByb3ZpZGVyLmNvbmZpZy5wYXRjaFpvbmU7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGZ1bmN0aW9uIG9yIGtleSB0aGF0IGRlZmluZXMgaG93IHRvIHRyYWNrIGNoYW5nZXMgZm9yIGl0ZW1zIGluIHRoZSBpdGVyYWJsZS5cbiAgICpcbiAgICogV2hlbiBpdGVtcyBhcmUgYWRkZWQsIG1vdmVkLCBvciByZW1vdmVkIGluIHRoZSBpdGVyYWJsZSxcbiAgICogdGhlIGRpcmVjdGl2ZSBtdXN0IHJlLXJlbmRlciB0aGUgYXBwcm9wcmlhdGUgRE9NIG5vZGVzLlxuICAgKiBUbyBtaW5pbWl6ZSBjaHVybiBpbiB0aGUgRE9NLCBvbmx5IG5vZGVzIHRoYXQgaGF2ZSBjaGFuZ2VkXG4gICAqIGFyZSByZS1yZW5kZXJlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgcnhGb3IgYXNzdW1lcyB0aGF0IHRoZSBvYmplY3QgaW5zdGFuY2UgaWRlbnRpZmllcyB0aGUgbm9kZSBpbiB0aGUgaXRlcmFibGUgKGVxdWFsaXR5IGNoZWNrIGA9PT1gKS5cbiAgICogV2hlbiBhIGZ1bmN0aW9uIG9yIGtleSBpcyBzdXBwbGllZCwgcnhGb3IgdXNlcyB0aGUgcmVzdWx0IHRvIGlkZW50aWZ5IHRoZSBpdGVtIG5vZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFxcQENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdhcHAtcm9vdCcsXG4gICAqICAgdGVtcGxhdGU6IGBcbiAgICogICAgPGFwcC1saXN0LWNvbXBvbmVudD5cbiAgICogICAgICA8YXBwLWxpc3QtaXRlbVxuICAgKiAgICAgICAgKnJ4Rm9yPVwiXG4gICAqICAgICAgICAgIGxldCBpdGVtIG9mIGl0ZW1zJDtcbiAgICogICAgICAgICAgdHJhY2tCeTogJ2lkJztcbiAgICogICAgICAgIFwiXG4gICAqICAgICAgPlxuICAgKiAgICAgICAgPGRpdj57eyBpdGVtLm5hbWUgfX08L2Rpdj5cbiAgICogICAgICA8L2FwcC1saXN0LWl0ZW0+XG4gICAqICAgIDwvYXBwLWxpc3QtY29tcG9uZW50PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgaXRlbXMkID0gaXRlbVNlcnZpY2UuZ2V0SXRlbXMoKTtcbiAgICogfVxuICAgKlxuICAgKiAvLyBPUlxuICAgKlxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgIDxhcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgICpyeEZvcj1cIlxuICAgKiAgICAgICAgICBsZXQgaXRlbSBvZiBpdGVtcyQ7XG4gICAqICAgICAgICAgIHRyYWNrQnk6IHRyYWNrSXRlbTtcbiAgICogICAgICAgIFwiXG4gICAqICAgICAgPlxuICAgKiAgICAgICAgPGRpdj57eyBpdGVtLm5hbWUgfX08L2Rpdj5cbiAgICogICAgICA8L2FwcC1saXN0LWl0ZW0+XG4gICAqICAgIDwvYXBwLWxpc3QtY29tcG9uZW50PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgaXRlbXMkID0gaXRlbVNlcnZpY2UuZ2V0SXRlbXMoKTtcbiAgICogICB0cmFja0l0ZW0gPSAoaWR4LCBpdGVtKSA9PiBpdGVtLmlkO1xuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB0cmFja0J5Rm5PcktleVxuICAgKi9cbiAgQElucHV0KCdyeEZvclRyYWNrQnknKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzZXQgdHJhY2tCeSh0cmFja0J5Rm5PcktleToga2V5b2YgVCB8ICgoaWR4OiBudW1iZXIsIGk6IFQpID0+IGFueSkpIHtcbiAgICBpZiAoXG4gICAgICAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSAmJlxuICAgICAgdHJhY2tCeUZuT3JLZXkgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHRyYWNrQnlGbk9yS2V5ICE9PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIHRyYWNrQnlGbk9yS2V5ICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGB0cmFja0J5IG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgdHJhY2tCeUZuT3JLZXksXG4gICAgICAgICl9LmAsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJhY2tCeUZuT3JLZXkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdHJhY2tCeSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RyYWNrQnkgPVxuICAgICAgICB0eXBlb2YgdHJhY2tCeUZuT3JLZXkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IChpLCBhKSA9PiBhW3RyYWNrQnlGbk9yS2V5XVxuICAgICAgICAgIDogdHJhY2tCeUZuT3JLZXk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGBTdWJqZWN0YCB3aGljaCBlbWl0cyB3aGVuZXZlciAqcnhGb3IgZmluaXNoZWQgcmVuZGVyaW5nIGEgc2V0IGNoYW5nZXMgdG8gdGhlIHZpZXcuXG4gICAqIFRoaXMgZW5hYmxlcyBkZXZlbG9wZXJzIHRvIHBlcmZvcm0gYWN0aW9ucyB3aGVuIGEgbGlzdCBoYXMgZmluaXNoZWQgcmVuZGVyaW5nLlxuICAgKiBUaGUgYHJlbmRlckNhbGxiYWNrYCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgcmVseSBvbiBzcGVjaWZpYyBET00gcHJvcGVydGllcyBsaWtlIHRoZSBgaGVpZ2h0YCBhXG4gICAqIHRhYmxlIGFmdGVyIGFsbCBpdGVtcyBnb3QgcmVuZGVyZWQuXG4gICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIHRoZSByZW5kZXJDYWxsYmFjayBpbiBvcmRlciB0byBkZXRlcm1pbmUgaWYgYSB2aWV3IHNob3VsZCBiZSB2aXNpYmxlIG9yIG5vdC4gVGhpc1xuICAgKiB3YXkgZGV2ZWxvcGVycyBjYW4gaGlkZSBhIGxpc3QgYXMgbG9uZyBhcyBpdCBoYXMgbm90IGZpbmlzaGVkIHJlbmRlcmluZy5cbiAgICpcbiAgICogVGhlIHJlc3VsdCBvZiB0aGUgYHJlbmRlckNhbGxiYWNrYCB3aWxsIGNvbnRhaW4gdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZXQgb2YgaXRlbXMgaW4gdGhlIGl0ZXJhYmxlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcXENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdhcHAtcm9vdCcsXG4gICAqICAgdGVtcGxhdGU6IGBcbiAgICogICA8YXBwLWxpc3QtY29tcG9uZW50PlxuICAgKiAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgKnJ4Rm9yPVwiXG4gICAqICAgICAgICAgbGV0IGl0ZW0gb2YgaXRlbXMkO1xuICAgKiAgICAgICAgIHRyYWNrQnk6IHRyYWNrSXRlbTtcbiAgICogICAgICAgICByZW5kZXJDYWxsYmFjazogaXRlbXNSZW5kZXJlZDtcbiAgICogICAgICAgXCI+XG4gICAqICAgICAgIDxkaXY+e3sgaXRlbS5uYW1lIH19PC9kaXY+XG4gICAqICAgICA8L2FwcC1saXN0LWl0ZW0+XG4gICAqICAgPC9hcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgaXRlbXMkOiBPYnNlcnZhYmxlPEl0ZW1bXT4gPSBpdGVtU2VydmljZS5nZXRJdGVtcygpO1xuICAgKiAgIHRyYWNrSXRlbSA9IChpZHgsIGl0ZW0pID0+IGl0ZW0uaWQ7XG4gICAqICAgLy8gdGhpcyBlbWl0cyB3aGVuZXZlciByeEZvciBmaW5pc2hlZCByZW5kZXJpbmcgY2hhbmdlc1xuICAgKiAgIGl0ZW1zUmVuZGVyZWQgPSBuZXcgU3ViamVjdDxJdGVtW10+KCk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4pIHtcbiAgICogICAgIGl0ZW1zUmVuZGVyZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICogICAgICAgLy8gaXRlbXMgYXJlIHJlbmRlcmVkLCB3ZSBjYW4gbm93IHNjcm9sbFxuICAgKiAgICAgICBlbGVtZW50UmVmLnNjcm9sbFRvKHtib3R0b206IDB9KTtcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7U3ViamVjdDxVPn0gcmVuZGVyQ2FsbGJhY2tcbiAgICovXG4gIEBJbnB1dCgncnhGb3JSZW5kZXJDYWxsYmFjaycpIHNldCByZW5kZXJDYWxsYmFjayhyZW5kZXJDYWxsYmFjazogU3ViamVjdDxVPikge1xuICAgIHRoaXMuX3JlbmRlckNhbGxiYWNrID0gcmVuZGVyQ2FsbGJhY2s7XG4gIH1cblxuICBwcml2YXRlIGdldCB0ZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxSeEZvclZpZXdDb250ZXh0PFQsIFU+PiB7XG4gICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlIHx8IHRoaXMudGVtcGxhdGVSZWY7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RyYXRlZ3lJbnB1dCQgPSBuZXcgUmVwbGF5U3ViamVjdDxcbiAgICBSeFN0cmF0ZWd5TmFtZXMgfCBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz5cbiAgPigxKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb2JzZXJ2YWJsZXMkID0gbmV3IFJlcGxheVN1YmplY3Q8T2JzZXJ2YWJsZTxVPiB8IFU+KDEpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcmVuZGVyQ2FsbGJhY2s6IFN1YmplY3Q8YW55PjtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVhZG9ubHkgdmFsdWVzJCA9IHRoaXMub2JzZXJ2YWJsZXMkLnBpcGUoXG4gICAgY29lcmNlT2JzZXJ2YWJsZVdpdGgoKSxcbiAgICBzd2l0Y2hBbGwoKSxcbiAgICBzaGFyZVJlcGxheSh7IHJlZkNvdW50OiB0cnVlLCBidWZmZXJTaXplOiAxIH0pLFxuICApO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB2YWx1ZXM6IFUgfCB1bmRlZmluZWQgfCBudWxsID0gbnVsbDtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RyYXRlZ3kkID0gdGhpcy5zdHJhdGVneUlucHV0JC5waXBlKGNvZXJjZURpc3RpbmN0V2l0aCgpKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgbGlzdE1hbmFnZXI6IFJ4TGlzdE1hbmFnZXI8VD47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdHJhY2tCeTogVHJhY2tCeUZ1bmN0aW9uPFQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9kaXN0aW5jdEJ5ID0gKGE6IFQsIGI6IFQpID0+IGEgPT09IGI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8UnhGb3JWaWV3Q29udGV4dDxULCBVPj4sXG4gICkge31cblxuICAvKiogQGludGVybmFsICovXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy52YWx1ZXMkLnN1YnNjcmliZSgodikgPT4gKHRoaXMudmFsdWVzID0gdikpKTtcbiAgICB0aGlzLmxpc3RNYW5hZ2VyID0gY3JlYXRlTGlzdFRlbXBsYXRlTWFuYWdlcjxULCBSeEZvclZpZXdDb250ZXh0PFQ+Pih7XG4gICAgICBpdGVyYWJsZURpZmZlcnM6IHRoaXMuaXRlcmFibGVEaWZmZXJzLFxuICAgICAgcmVuZGVyU2V0dGluZ3M6IHtcbiAgICAgICAgY2RSZWY6IHRoaXMuY2RSZWYsXG4gICAgICAgIHN0cmF0ZWdpZXM6IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5zdHJhdGVnaWVzIGFzIGFueSwgLy8gVE9ETzogbW92ZSBzdHJhdGVneVByb3ZpZGVyXG4gICAgICAgIGRlZmF1bHRTdHJhdGVneU5hbWU6IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5wcmltYXJ5U3RyYXRlZ3ksXG4gICAgICAgIHBhcmVudDogISF0aGlzLnJlbmRlclBhcmVudCxcbiAgICAgICAgcGF0Y2hab25lOiB0aGlzLnBhdGNoWm9uZSA/IHRoaXMubmdab25lIDogZmFsc2UsXG4gICAgICAgIGVycm9ySGFuZGxlcjogdGhpcy5lcnJvckhhbmRsZXIsXG4gICAgICB9LFxuICAgICAgdGVtcGxhdGVTZXR0aW5nczoge1xuICAgICAgICB2aWV3Q29udGFpbmVyUmVmOiB0aGlzLnZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHRlbXBsYXRlUmVmOiB0aGlzLnRlbXBsYXRlLFxuICAgICAgICBjcmVhdGVWaWV3Q29udGV4dDogdGhpcy5jcmVhdGVWaWV3Q29udGV4dC5iaW5kKHRoaXMpLFxuICAgICAgICB1cGRhdGVWaWV3Q29udGV4dDogdGhpcy51cGRhdGVWaWV3Q29udGV4dC5iaW5kKHRoaXMpLFxuICAgICAgfSxcbiAgICAgIHRyYWNrQnk6IHRoaXMuX3RyYWNrQnksXG4gICAgfSk7XG4gICAgdGhpcy5saXN0TWFuYWdlci5uZXh0U3RyYXRlZ3kodGhpcy5zdHJhdGVneSQpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICB0aGlzLmxpc3RNYW5hZ2VyXG4gICAgICAgIC5yZW5kZXIodGhpcy52YWx1ZXMkKVxuICAgICAgICAuc3Vic2NyaWJlKCh2KSA9PiB0aGlzLl9yZW5kZXJDYWxsYmFjaz8ubmV4dCh2KSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY3JlYXRlVmlld0NvbnRleHQoXG4gICAgaXRlbTogVCxcbiAgICBjb21wdXRlZENvbnRleHQ6IFJ4TGlzdFZpZXdDb21wdXRlZENvbnRleHQsXG4gICk6IFJ4Rm9yVmlld0NvbnRleHQ8VCwgVT4ge1xuICAgIHJldHVybiBuZXcgUnhGb3JWaWV3Q29udGV4dDxULCBVPihpdGVtLCB0aGlzLnZhbHVlcywgY29tcHV0ZWRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlVmlld0NvbnRleHQoXG4gICAgaXRlbTogVCxcbiAgICB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8UnhGb3JWaWV3Q29udGV4dDxUPj4sXG4gICAgY29tcHV0ZWRDb250ZXh0OiBSeExpc3RWaWV3Q29tcHV0ZWRDb250ZXh0LFxuICApOiB2b2lkIHtcbiAgICB2aWV3LmNvbnRleHQudXBkYXRlQ29udGV4dChjb21wdXRlZENvbnRleHQpO1xuICAgIHZpZXcuY29udGV4dC5yeEZvck9mID0gdGhpcy52YWx1ZXM7XG4gICAgdmlldy5jb250ZXh0LiRpbXBsaWNpdCA9IGl0ZW07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJTdGF0aWMpIHtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMkLm5leHQodGhpcy5zdGF0aWNWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIG5nVGVtcGxhdGVDb250ZXh0R3VhcmQ8XG4gICAgVCxcbiAgICBVIGV4dGVuZHMgTmdJdGVyYWJsZTxUPiA9IE5nSXRlcmFibGU8VD4sXG4gICAgSyA9IGtleW9mIFQsXG4gID4oZGlyOiBSeEZvcjxULCBVPiwgY3R4OiBhbnkpOiBjdHggaXMgUnhGb3JWaWV3Q29udGV4dDxULCBVLCBLPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdfQ==