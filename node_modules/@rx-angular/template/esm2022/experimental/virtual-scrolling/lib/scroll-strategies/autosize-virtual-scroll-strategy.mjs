import { Directive, inject, Input, } from '@angular/core';
import { coalesceWith } from '@rx-angular/cdk/coalescing';
import { combineLatest, merge, pairwise, ReplaySubject, Subject, } from 'rxjs';
import { distinctUntilChanged, exhaustMap, filter, finalize, groupBy, map, mergeMap, startWith, switchMap, takeUntil, takeWhile, tap, } from 'rxjs/operators';
import { RxVirtualScrollStrategy, } from '../model';
import { calculateVisibleContainerSize, parseScrollTopBoundaries, toBoolean, unpatchedMicroTask, } from '../util';
import { RX_VIRTUAL_SCROLL_DEFAULT_OPTIONS } from '../virtual-scroll.config';
import { RxaResizeObserver } from './resize-observer';
import * as i0 from "@angular/core";
const defaultSizeExtract = (entry) => entry.borderBoxSize[0].blockSize;
/**
 * @Directive AutosizeVirtualScrollStrategy
 *
 * @description
 *
 * The `AutosizeVirtualScrollStrategy` provides a twitter-like virtual-scrolling
 * experience. It is able to render and position items based on their individual
 * size. It is comparable to \@angular/cdk/experimental `AutosizeVirtualScrollStrategy`, but
 * with a high performant layouting technique and more features.
 *
 * On top of this the `AutosizeVirtualScrollStrategy` is leveraging the native
 * `ResizeObserver` in order to detect size changes for each individual view
 * rendered to the DOM and properly re-position accordingly.
 *
 * In order to provide top-notch runtime performance the `AutosizeVirtualScrollStrategy`
 * builds up caches that prevent DOM interactions whenever possible. Once a view
 * was visited, its properties will be stored instead of re-read from the DOM again as
 * this can potentially lead to unwanted forced reflows.
 *
 * @docsCategory RxVirtualFor
 * @docsPage RxVirtualFor
 * @publicApi
 */
export class AutoSizeVirtualScrollStrategy extends RxVirtualScrollStrategy {
    defaults = inject(RX_VIRTUAL_SCROLL_DEFAULT_OPTIONS, {
        optional: true,
    });
    /**
     * @description
     * The amount of items to render upfront in scroll direction
     */
    runwayItems = this.defaults?.runwayItems ?? 10;
    /**
     * @description
     * The amount of items to render upfront in reverse scroll direction
     */
    runwayItemsOpposite = this.defaults?.runwayItemsOpposite ?? 2;
    /**
     * @description
     * The default size of the items being rendered. The autosized strategy will assume
     * this size for items it doesn't know yet. For the smoothest experience,
     * you provide the mean size of all items being rendered - if possible of course.
     *
     * As soon as rxVirtualFor is able to also render actual tombstone items, this
     * will be the size of a tombstone item being rendered before the actual item
     * is inserted into its position.
     */
    tombstoneSize = this.defaults?.itemSize ?? 50;
    /**
     * @description
     * The autosized strategy uses the native ResizeObserver in order to determine
     * if an item changed in size to afterwards properly position the views.
     * You can customize the config passed to the ResizeObserver as well as determine
     * which result property to use when determining the views size.
     */
    resizeObserverConfig;
    /**
     * @description
     * When enabled, the autosized scroll strategy attaches a `ResizeObserver`
     * to every view within the given renderedRange. If your views receive
     * dimension changes that are not caused by list updates, this is a way to
     * still track height changes. This also applies to resize events of the whole
     * document.
     */
    withResizeObserver = true;
    /**
     * @description
     * When enabled, the scroll strategy stops removing views from the viewport,
     * instead it only adds views. This setting can be changed on the fly. Views will be added in both directions
     * according to the user interactions.
     */
    appendOnly = false;
    /**
     * @description
     * When enabled, the autosized scroll strategy removes css styles that
     * prevent the scrollbar from being in sync with the input device.
     * Use with caution, as this can lead to extremely weird scroll behavior
     * on chromium based browsers when the rendered views differ
     * in dimensions too much or change dimensions heavily.
     */
    withSyncScrollbar = false;
    /**
     * @description
     * If this flag is true, the virtual scroll strategy maintains the scrolled item when new data
     * is prepended to the list. This is very useful when implementing a reversed infinite scroller, that prepends
     * data instead of appending it
     */
    keepScrolledIndexOnPrepend = false;
    /** @internal */
    viewport = null;
    /** @internal */
    viewRepeater = null;
    /** @internal */
    _contentSize$ = new ReplaySubject(1);
    /** @internal */
    contentSize$ = this._contentSize$.asObservable();
    /** @internal */
    _contentSize = 0;
    /** @internal */
    set contentSize(size) {
        this._contentSize = size;
        this._contentSize$.next(size);
    }
    get contentSize() {
        return this._contentSize;
    }
    /** @internal */
    _renderedRange$ = new Subject();
    /** @internal */
    renderedRange$ = this._renderedRange$.asObservable();
    /** @internal */
    _renderedRange = { start: 0, end: 0 };
    /** @internal */
    set renderedRange(range) {
        if (this._renderedRange.start !== range.start ||
            this._renderedRange.end !== range.end) {
            this._renderedRange = range;
            this._renderedRange$.next(range);
        }
    }
    /** @internal */
    get renderedRange() {
        return this._renderedRange;
    }
    /** @internal */
    positionedRange = { start: 0, end: 0 };
    /** @internal */
    _scrolledIndex$ = new ReplaySubject(1);
    /** @internal */
    scrolledIndex$ = this._scrolledIndex$.pipe(distinctUntilChanged());
    /** @internal */
    _scrolledIndex = 0;
    /** @internal */
    get scrolledIndex() {
        return this._scrolledIndex;
    }
    /** @internal */
    set scrolledIndex(index) {
        this._scrolledIndex = index;
        this._scrolledIndex$.next(index);
    }
    /**
     * is set, when scrollToIndex is called
     * @internal
     * */
    _scrollToIndex = null;
    /** @internal */
    containerSize = 0;
    /** @internal */
    contentLength = 0;
    /** @internal */
    _virtualItems = [];
    /** @internal */
    scrollTop = 0;
    /** @internal */
    scrollTopWithOutOffset = 0;
    /** @internal */
    scrollTopAfterOffset = 0;
    /** @internal */
    viewportOffset = 0;
    /** @internal */
    direction = 'down';
    /** @internal */
    anchorScrollTop = 0;
    /** @internal */
    anchorItem = {
        index: 0,
        offset: 0,
    };
    /** @internal */
    lastScreenItem = {
        index: 0,
        offset: 0,
    };
    /** @internal */
    waitForScroll = false;
    /** @internal */
    isStable$ = new ReplaySubject(1);
    /** @internal */
    detached$ = new Subject();
    /** @internal */
    resizeObserver = inject(RxaResizeObserver, { self: true });
    /** @internal */
    recalculateRange$ = new Subject();
    /** @internal */
    until$() {
        return (o$) => o$.pipe(takeUntil(this.detached$));
    }
    /** @internal */
    get extractSize() {
        return this.resizeObserverConfig?.extractSize ?? defaultSizeExtract;
    }
    /** @internal */
    get isStable() {
        return this.isStable$.pipe(filter((w) => w));
    }
    /** @internal */
    ngOnChanges(changes) {
        if ((changes['runwayItemsOpposite'] &&
            !changes['runwayItemsOpposite'].firstChange) ||
            (changes['runwayItems'] && !changes['runwayItems'].firstChange)) {
            this.recalculateRange$.next();
        }
        if (changes['withSyncScrollbar']) {
            this.updateScrollElementClass();
        }
    }
    /** @internal */
    ngOnDestroy() {
        this.detach();
    }
    /** @internal */
    attach(viewport, viewRepeater) {
        this.viewport = viewport;
        this.viewRepeater = viewRepeater;
        this.updateScrollElementClass();
        this.maintainVirtualItems();
        this.calcRenderedRange();
        this.positionElements();
    }
    /** @internal */
    detach() {
        this.updateScrollElementClass(false);
        this.viewport = null;
        this.viewRepeater = null;
        this._virtualItems = [];
        this.resizeObserver.destroy();
        this.detached$.next();
    }
    scrollToIndex(index, behavior) {
        const _index = Math.min(Math.max(index, 0), this.contentLength - 1);
        if (_index !== this.scrolledIndex) {
            const scrollTop = this.calcInitialPosition(_index);
            this._scrollToIndex = _index;
            this.scrollTo(scrollTop, behavior);
        }
    }
    scrollTo(scrollTo, behavior) {
        this.waitForScroll =
            scrollTo !== this.scrollTop && this.contentSize > this.containerSize;
        if (this.waitForScroll) {
            this.isStable$.next(false);
        }
        this.viewport.scrollTo(this.viewportOffset + scrollTo, behavior);
    }
    /**
     * starts the subscriptions that maintain the virtualItems array on changes
     * to the underlying dataset
     * @internal
     */
    maintainVirtualItems() {
        // reset virtual viewport when opposite orientation to the scroll direction
        // changes, as we have to expect dimension changes for all items when this
        // happens. This could also be configurable as it maybe costs performance
        this.viewport.containerRect$.pipe(map(({ width }) => width), distinctUntilChanged(), filter(() => this.renderedRange.end > 0 && this._virtualItems.length > 0), this.until$()).subscribe(() => {
            // reset because we have no idea how items will behave
            let i = 0;
            while (i < this.renderedRange.start) {
                this._virtualItems[i].cached = false;
                i++;
            }
            i = this.renderedRange.end;
            while (i < this.contentLength - 1) {
                this._virtualItems[i].cached = false;
                i++;
            }
        });
        // synchronises the values with the virtual viewport we've built up
        // it might get costy when having > 100k elements, it's still faster than
        // the IterableDiffer approach, especially on move operations
        const itemCache = new Map();
        const trackBy = this.viewRepeater._trackBy ?? ((i, item) => item);
        this.renderedRange$
            .pipe(pairwise(), this.until$())
            .subscribe(([oldRange, newRange]) => {
            for (let i = oldRange.start; i < oldRange.end; i++) {
                if (i < newRange.start || i >= newRange.end) {
                    this._virtualItems[i].position = undefined;
                }
            }
        });
        this.viewRepeater.values$.pipe(this.until$(), tap((values) => {
            const dataArr = Array.isArray(values)
                ? values
                : values
                    ? Array.from(values)
                    : [];
            const existingIds = new Set();
            let size = 0;
            const dataLength = dataArr.length;
            const virtualItems = new Array(dataLength);
            let anchorItemIndex = this.anchorItem.index;
            const keepScrolledIndexOnPrepend = this.keepScrolledIndexOnPrepend &&
                dataArr.length > 0 &&
                itemCache.size > 0;
            for (let i = 0; i < dataLength; i++) {
                const item = dataArr[i];
                const id = trackBy(i, item);
                const cachedItem = itemCache.get(id);
                if (cachedItem === undefined) {
                    // add
                    virtualItems[i] = { size: 0 };
                    itemCache.set(id, { item: dataArr[i], index: i });
                    if (i <= anchorItemIndex) {
                        anchorItemIndex++;
                    }
                }
                else if (cachedItem.index !== i) {
                    // move
                    virtualItems[i] = this._virtualItems[cachedItem.index];
                    virtualItems[i].position = undefined;
                    itemCache.set(id, { item: dataArr[i], index: i });
                }
                else {
                    // update
                    // todo: properly determine update (Object.is?)
                    virtualItems[i] = this._virtualItems[i];
                    // if index is not part of rendered range, remove cache
                    if (!this.withResizeObserver ||
                        i < this.renderedRange.start ||
                        i >= this.renderedRange.end) {
                        virtualItems[i].cached = false;
                    }
                    itemCache.set(id, { item: dataArr[i], index: i });
                }
                existingIds.add(id);
                size += virtualItems[i].size || this.tombstoneSize;
            }
            this._virtualItems = virtualItems;
            // sync delete operations
            if (itemCache.size > dataLength) {
                itemCache.forEach((v, k) => {
                    if (!existingIds.has(k)) {
                        itemCache.delete(k);
                    }
                });
            }
            existingIds.clear();
            this.contentLength = dataLength;
            if (keepScrolledIndexOnPrepend &&
                this.anchorItem.index !== anchorItemIndex) {
                this.scrollToIndex(anchorItemIndex);
            }
            else if (dataLength < this._renderedRange.end) {
                const rangeDiff = this._renderedRange.end - this._renderedRange.start;
                const anchorDiff = this.anchorItem.index - this._renderedRange.start;
                this._renderedRange.end = Math.min(dataLength, this._renderedRange.end);
                this._renderedRange.start = Math.max(0, this._renderedRange.end - rangeDiff);
                // this.anchorItem.offset = 0;
                this.anchorItem.index = Math.max(0, this._renderedRange.start + anchorDiff);
                this.calcAnchorScrollTop();
            }
            this.contentSize = size;
        }), finalize(() => itemCache.clear())).subscribe();
    }
    /**
     * listen to triggers that should change the renderedRange
     * @internal
     */
    calcRenderedRange() {
        let removeScrollAnchorOnNextScroll = false;
        const onlyTriggerWhenStable = () => (o$) => o$.pipe(filter(() => this.renderedRange.end === 0 ||
            (this.scrollTop === this.anchorScrollTop &&
                this._scrollToIndex === null)));
        combineLatest([
            this.viewport.containerRect$.pipe(map(({ height }) => {
                this.containerSize = height;
                return height;
            }), distinctUntilChanged(), onlyTriggerWhenStable()),
            this.viewport.elementScrolled$.pipe(startWith(void 0), tap(() => {
                this.viewportOffset = this.viewport.measureOffset();
                const { scrollTop, scrollTopWithOutOffset, scrollTopAfterOffset } = parseScrollTopBoundaries(this.viewport.getScrollTop(), this.viewportOffset, this._contentSize, this.containerSize);
                this.direction =
                    scrollTopWithOutOffset > this.scrollTopWithOutOffset
                        ? 'down'
                        : 'up';
                this.scrollTopWithOutOffset = scrollTopWithOutOffset;
                this.scrollTopAfterOffset = scrollTopAfterOffset;
                this.scrollTop = scrollTop;
                if (removeScrollAnchorOnNextScroll) {
                    this._scrollToIndex = null;
                    removeScrollAnchorOnNextScroll = false;
                }
                else {
                    removeScrollAnchorOnNextScroll = this._scrollToIndex !== null;
                }
                this.waitForScroll = false;
            })),
            this._contentSize$.pipe(distinctUntilChanged(), onlyTriggerWhenStable()),
            this.recalculateRange$.pipe(onlyTriggerWhenStable(), startWith(void 0)),
        ])
            .pipe(
        // make sure to not over calculate things by coalescing all triggers to the next microtask
        coalesceWith(unpatchedMicroTask()), map(() => {
            const range = { start: 0, end: 0 };
            const delta = this.scrollTop - this.anchorScrollTop;
            if (this.scrollTop == 0) {
                this.anchorItem = { index: 0, offset: 0 };
            }
            else {
                this.anchorItem = this.calculateAnchoredItem(this.anchorItem, delta);
            }
            this.anchorScrollTop = this.scrollTop;
            this.scrolledIndex = this.anchorItem.index;
            this.lastScreenItem = this.calculateAnchoredItem(this.anchorItem, calculateVisibleContainerSize(this.containerSize, this.scrollTopWithOutOffset, this.scrollTopAfterOffset));
            if (this.direction === 'up') {
                range.start = Math.max(0, this.anchorItem.index - this.runwayItems);
                range.end = Math.min(this.contentLength, this.lastScreenItem.index + this.runwayItemsOpposite);
            }
            else {
                range.start = Math.max(0, this.anchorItem.index - this.runwayItemsOpposite);
                range.end = Math.min(this.contentLength, this.lastScreenItem.index + this.runwayItems);
            }
            if (this.appendOnly) {
                range.start = Math.min(this._renderedRange.start, range.start);
                range.end = Math.max(this._renderedRange.end, range.end);
            }
            return range;
        }))
            .pipe(this.until$())
            .subscribe((range) => {
            this.renderedRange = range;
            this.isStable$.next(!this.waitForScroll);
        });
    }
    /**
     * position elements after they are created/updated/moved or their dimensions
     * change from other sources
     * @internal
     */
    positionElements() {
        const viewsToObserve$ = new Subject();
        const positionByIterableChange$ = this.viewRepeater.renderingStart$.pipe(switchMap((batchedUpdates) => {
            // initialIndex tells us what will be the first index to be change detected
            // if it's not the first one, we maybe have to adjust the position
            // of all items in the viewport before this index
            const initialIndex = batchedUpdates.size
                ? batchedUpdates.values().next().value + this.renderedRange.start
                : this.renderedRange.start;
            let position = 0;
            let scrollToAnchorPosition = null;
            return this.viewRepeater.viewRendered$.pipe(tap(({ view, index: viewIndex, item }) => {
                const itemIndex = view.context.index;
                // this most of the time causes a forced reflow per rendered view.
                // it doesn't sound good, but it's still way more stable than
                // having one large reflow in a microtask after the actual
                // scheduler tick.
                // Right here, we can insert work into the task which is currently
                // executed as part of the concurrent scheduler tick.
                // causing the forced reflow here, also makes it count for the
                // schedulers frame budget. This way we will always run with the
                // configured FPS. The only case where this is not true is when rendering 1 single view
                // already explodes the budget
                const [, sizeDiff] = this.updateElementSize(view, itemIndex);
                const virtualItem = this._virtualItems[itemIndex];
                // before positioning the first view of this batch, calculate the
                // anchorScrollTop & initial position of the view
                if (itemIndex === initialIndex) {
                    this.calcAnchorScrollTop();
                    position = this.calcInitialPosition(itemIndex);
                    // if we receive a partial update and the current views position is
                    // new, we can safely assume that all positions from views before the current
                    // index are also off. We need to adjust them
                    if (initialIndex > this.renderedRange.start &&
                        virtualItem.position !== position) {
                        let beforePosition = position;
                        let i = initialIndex - 1;
                        while (i >= this.renderedRange.start) {
                            const view = this.getViewRef(i - this.renderedRange.start);
                            const virtualItem = this._virtualItems[i];
                            const element = this.getElement(view);
                            beforePosition -= virtualItem.size;
                            virtualItem.position = beforePosition;
                            this.positionElement(element, beforePosition);
                            i--;
                        }
                    }
                }
                else if (itemIndex < this.anchorItem.index && sizeDiff) {
                    this.anchorScrollTop += sizeDiff;
                }
                const size = virtualItem.size;
                // position current element if we need to
                if (virtualItem.position !== position) {
                    const element = this.getElement(view);
                    this.positionElement(element, position);
                    virtualItem.position = position;
                }
                if (this._scrollToIndex === itemIndex) {
                    scrollToAnchorPosition = position;
                }
                position += size;
                // immediately activate the ResizeObserver after initial positioning
                viewsToObserve$.next(view);
                this.viewRenderCallback.next({
                    index: itemIndex,
                    view,
                    item,
                });
                // after positioning the actual view, we also need to position all
                // views from the current index on until either the renderedRange.end
                // is hit or we hit an index that will anyway receive an update.
                // we can derive that information from the batchedUpdates index Set
                const { lastPositionedIndex: lastIndex, position: newPosition } = this.positionUnchangedViews({
                    viewIndex,
                    itemIndex,
                    batchedUpdates,
                    position,
                });
                position = newPosition;
                this.positionedRange.start = this.renderedRange.start;
                this.positionedRange.end = lastIndex + 1;
            }), coalesceWith(unpatchedMicroTask()), tap(() => {
                this.adjustContentSize(position);
                if (this._scrollToIndex === null) {
                    this.maybeAdjustScrollPosition();
                }
                else if (scrollToAnchorPosition != null) {
                    if (scrollToAnchorPosition !== this.anchorScrollTop) {
                        if (scrollToAnchorPosition >
                            this.contentSize - this.containerSize) {
                            // if the anchorItemPosition is larger than the maximum scrollPos,
                            // we want to scroll until the bottom.
                            // of course, we need to be sure all the items until the end are positioned
                            // until we are sure that we need to scroll to the bottom
                            if (this.renderedRange.end === this.positionedRange.end) {
                                this._scrollToIndex = null;
                                this.scrollTo(this.contentSize);
                            }
                        }
                        else {
                            this._scrollToIndex = null;
                            this.scrollTo(scrollToAnchorPosition);
                        }
                    }
                    else {
                        this._scrollToIndex = null;
                        this.maybeAdjustScrollPosition();
                    }
                }
            }));
        }));
        const positionByResizeObserver$ = viewsToObserve$.pipe(filter(() => this.withResizeObserver), groupBy((viewRef) => viewRef), mergeMap((o$) => o$.pipe(exhaustMap((viewRef) => this.observeViewSize$(viewRef)), tap(([index, viewIndex]) => {
            this.calcAnchorScrollTop();
            let position = this.calcInitialPosition(index);
            let viewIdx = viewIndex;
            if (this._virtualItems[index].position !== position) {
                // we want to reposition the whole viewport, when the current position has changed
                while (viewIdx > 0) {
                    viewIdx--;
                    position -=
                        this._virtualItems[this.getViewRef(viewIdx).context.index]
                            .size;
                }
            }
            else {
                // we only need to reposition everything from the next viewIndex on
                viewIdx++;
                position += this._virtualItems[index].size;
            }
            // position all views from the specified viewIndex
            while (viewIdx < this.viewRepeater.viewContainer.length) {
                const view = this.getViewRef(viewIdx);
                const itemIndex = view.context.index;
                const virtualItem = this._virtualItems[itemIndex];
                const element = this.getElement(view);
                virtualItem.position = position;
                this.positionElement(element, position);
                position += virtualItem.size;
                viewIdx++;
            }
            this.maybeAdjustScrollPosition();
        }))));
        merge(positionByIterableChange$, positionByResizeObserver$)
            .pipe(this.until$())
            .subscribe();
    }
    /** @internal */
    adjustContentSize(position) {
        let newContentSize = position;
        for (let i = this.positionedRange.end; i < this._virtualItems.length; i++) {
            newContentSize += this.getItemSize(i);
        }
        this.contentSize = newContentSize;
    }
    /** @internal */
    observeViewSize$(viewRef) {
        const element = this.getElement(viewRef);
        return this.resizeObserver
            .observeElement(element, this.resizeObserverConfig?.options)
            .pipe(takeWhile((event) => event.target.isConnected), map((event) => {
            const index = viewRef.context.index;
            const size = Math.round(this.extractSize(event));
            const diff = size - this._virtualItems[index].size;
            if (diff !== 0) {
                this._virtualItems[index].size = size;
                this._virtualItems[index].cached = true;
                this.contentSize += diff;
                return [index, this.viewRepeater.viewContainer.indexOf(viewRef)];
            }
            return null;
        }), filter((diff) => diff !== null &&
            diff[0] >= this.positionedRange.start &&
            diff[0] < this.positionedRange.end), takeUntil(merge(this.viewRepeater.viewRendered$, this.viewRepeater.renderingStart$).pipe(tap(() => {
            // we need to clean up the position property for views
            // that fall out of the renderedRange.
            const index = viewRef.context.index;
            if (this._virtualItems[index] &&
                (index < this.renderedRange.start ||
                    index >= this.renderedRange.end)) {
                this._virtualItems[index].position = undefined;
            }
        }), filter(() => this.viewRepeater.viewContainer.indexOf(viewRef) === -1))));
    }
    /**
     * @internal
     * heavily inspired by
     *   https://github.com/GoogleChromeLabs/ui-element-samples/blob/gh-pages/infinite-scroller/scripts/infinite-scroll.js
     */
    calculateAnchoredItem(initialAnchor, delta) {
        if (delta === 0)
            return initialAnchor;
        delta += initialAnchor.offset;
        let i = initialAnchor.index;
        const items = this._virtualItems;
        if (delta < 0) {
            while (delta < 0 && i > 0) {
                delta += this.getItemSize(i - 1);
                i--;
            }
        }
        else {
            while (delta > 0 && i < items.length && this.getItemSize(i) <= delta) {
                delta -= this.getItemSize(i);
                i++;
            }
        }
        return {
            index: Math.min(i, items.length),
            offset: delta,
        };
    }
    /** @internal */
    positionUnchangedViews({ viewIndex, itemIndex, batchedUpdates, position, }) {
        let _viewIndex = viewIndex + 1;
        let index = itemIndex + 1;
        let lastPositionedIndex = itemIndex;
        while (!batchedUpdates.has(_viewIndex) && index < this.renderedRange.end) {
            const virtualItem = this._virtualItems[index];
            if (position !== virtualItem.position) {
                const view = this.getViewRef(_viewIndex);
                const element = this.getElement(view);
                this.positionElement(element, position);
                virtualItem.position = position;
            }
            position += virtualItem.size;
            lastPositionedIndex = index;
            index++;
            _viewIndex++;
        }
        return { position, lastPositionedIndex };
    }
    /**
     * Adjust the scroll position when the anchorScrollTop differs from
     * the actual scrollTop.
     * Trigger a range recalculation if there is empty space
     *
     * @internal
     */
    maybeAdjustScrollPosition() {
        if (this.anchorScrollTop !== this.scrollTop) {
            this.scrollTo(this.anchorScrollTop);
        }
    }
    /** @internal */
    calcAnchorScrollTop() {
        this.anchorScrollTop = 0;
        for (let i = 0; i < this.anchorItem.index; i++) {
            this.anchorScrollTop += this.getItemSize(i);
        }
        this.anchorScrollTop += this.anchorItem.offset;
    }
    /** @internal */
    calcInitialPosition(start) {
        // Calculate position of starting node
        let pos = this.anchorScrollTop - this.anchorItem.offset;
        let i = this.anchorItem.index;
        while (i > start) {
            const itemSize = this.getItemSize(i - 1);
            pos -= itemSize;
            i--;
        }
        while (i < start) {
            const itemSize = this.getItemSize(i);
            pos += itemSize;
            i++;
        }
        return pos;
    }
    /** @internal */
    getViewRef(index) {
        return (this.viewRepeater.viewContainer.get(index));
    }
    /** @internal */
    updateElementSize(view, index) {
        const oldSize = this.getItemSize(index);
        const isCached = this._virtualItems[index].cached;
        const size = isCached
            ? oldSize
            : this.getElementSize(this.getElement(view));
        this._virtualItems[index].size = size;
        this._virtualItems[index].cached = true;
        return [size, size - oldSize];
    }
    /** @internal */
    getItemSize(index) {
        return this._virtualItems[index].size || this.tombstoneSize;
    }
    /** @internal */
    getElementSize(element) {
        return element.offsetHeight;
    }
    /** @internal */
    positionElement(element, scrollTop) {
        element.style.position = 'absolute';
        element.style.transform = `translateY(${scrollTop}px)`;
    }
    /** @internal */
    updateScrollElementClass(force = this.withSyncScrollbar) {
        const scrollElement = this.viewport?.getScrollElement?.();
        if (!!scrollElement &&
            scrollElement.classList.contains('rx-virtual-scroll-element')) {
            scrollElement.classList.toggle('rx-virtual-scroll-element--withSyncScrollbar', force);
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: AutoSizeVirtualScrollStrategy, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.0.1", type: AutoSizeVirtualScrollStrategy, isStandalone: true, selector: "rx-virtual-scroll-viewport[autosize]", inputs: { runwayItems: "runwayItems", runwayItemsOpposite: "runwayItemsOpposite", tombstoneSize: "tombstoneSize", resizeObserverConfig: "resizeObserverConfig", withResizeObserver: ["withResizeObserver", "withResizeObserver", toBoolean], appendOnly: ["appendOnly", "appendOnly", toBoolean], withSyncScrollbar: ["withSyncScrollbar", "withSyncScrollbar", toBoolean], keepScrolledIndexOnPrepend: ["keepScrolledIndexOnPrepend", "keepScrolledIndexOnPrepend", toBoolean] }, providers: [
            {
                provide: RxVirtualScrollStrategy,
                useExisting: AutoSizeVirtualScrollStrategy,
            },
            RxaResizeObserver,
        ], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: AutoSizeVirtualScrollStrategy, decorators: [{
            type: Directive,
            args: [{
                    selector: 'rx-virtual-scroll-viewport[autosize]',
                    providers: [
                        {
                            provide: RxVirtualScrollStrategy,
                            useExisting: AutoSizeVirtualScrollStrategy,
                        },
                        RxaResizeObserver,
                    ],
                    standalone: true,
                }]
        }], propDecorators: { runwayItems: [{
                type: Input
            }], runwayItemsOpposite: [{
                type: Input
            }], tombstoneSize: [{
                type: Input
            }], resizeObserverConfig: [{
                type: Input
            }], withResizeObserver: [{
                type: Input,
                args: [{ transform: toBoolean }]
            }], appendOnly: [{
                type: Input,
                args: [{ transform: toBoolean }]
            }], withSyncScrollbar: [{
                type: Input,
                args: [{ transform: toBoolean }]
            }], keepScrolledIndexOnPrepend: [{
                type: Input,
                args: [{ transform: toBoolean }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b3NpemUtdmlydHVhbC1zY3JvbGwtc3RyYXRlZ3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL3RlbXBsYXRlL2V4cGVyaW1lbnRhbC92aXJ0dWFsLXNjcm9sbGluZy9zcmMvbGliL3Njcm9sbC1zdHJhdGVnaWVzL2F1dG9zaXplLXZpcnR1YWwtc2Nyb2xsLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBRVQsTUFBTSxFQUNOLEtBQUssR0FLTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDMUQsT0FBTyxFQUNMLGFBQWEsRUFDYixLQUFLLEVBR0wsUUFBUSxFQUNSLGFBQWEsRUFDYixPQUFPLEdBQ1IsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLFVBQVUsRUFDVixNQUFNLEVBQ04sUUFBUSxFQUNSLE9BQU8sRUFDUCxHQUFHLEVBQ0gsUUFBUSxFQUNSLFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxHQUFHLEdBQ0osTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBR0wsdUJBQXVCLEdBR3hCLE1BQU0sVUFBVSxDQUFDO0FBQ2xCLE9BQU8sRUFDTCw2QkFBNkIsRUFDN0Isd0JBQXdCLEVBQ3hCLFNBQVMsRUFDVCxrQkFBa0IsR0FDbkIsTUFBTSxTQUFTLENBQUM7QUFDakIsT0FBTyxFQUFFLGlDQUFpQyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDN0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7O0FBZXRELE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxLQUEwQixFQUFFLEVBQUUsQ0FDeEQsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFFbkM7Ozs7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RCxTQUFTLEVBQUU7d0JBQ1Q7NEJBQ0UsT0FBTyxFQUFFLHVCQUF1Qjs0QkFDaEMsV0FBVywrQkFBK0I7eUJBQzNDO3dCQUNELGlCQUFpQjtxQkFDbEI7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzhCQWdCVSxXQUFXO3NCQUFuQixLQUFLO2dCQU1HLG1CQUFtQjtzQkFBM0IsS0FBSztnQkFZRyxhQUFhO3NCQUFyQixLQUFLO2dCQVNHLG9CQUFvQjtzQkFBNUIsS0FBSztnQkFhMkIsa0JBQWtCO3NCQUFsRCxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtnQkFRRSxVQUFVO3NCQUExQyxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtnQkFVRSxpQkFBaUI7c0JBQWpELEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFO2dCQVFFLDBCQUEwQjtzQkFBMUQsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgaW5qZWN0LFxuICBJbnB1dCxcbiAgTmdJdGVyYWJsZSxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIFNpbXBsZUNoYW5nZXMsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29hbGVzY2VXaXRoIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL2NvYWxlc2NpbmcnO1xuaW1wb3J0IHtcbiAgY29tYmluZUxhdGVzdCxcbiAgbWVyZ2UsXG4gIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbixcbiAgT2JzZXJ2YWJsZSxcbiAgcGFpcndpc2UsXG4gIFJlcGxheVN1YmplY3QsXG4gIFN1YmplY3QsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIGV4aGF1c3RNYXAsXG4gIGZpbHRlcixcbiAgZmluYWxpemUsXG4gIGdyb3VwQnksXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHN0YXJ0V2l0aCxcbiAgc3dpdGNoTWFwLFxuICB0YWtlVW50aWwsXG4gIHRha2VXaGlsZSxcbiAgdGFwLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBMaXN0UmFuZ2UsXG4gIFJ4VmlydHVhbEZvclZpZXdDb250ZXh0LFxuICBSeFZpcnR1YWxTY3JvbGxTdHJhdGVneSxcbiAgUnhWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsXG4gIFJ4VmlydHVhbFZpZXdSZXBlYXRlcixcbn0gZnJvbSAnLi4vbW9kZWwnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVmlzaWJsZUNvbnRhaW5lclNpemUsXG4gIHBhcnNlU2Nyb2xsVG9wQm91bmRhcmllcyxcbiAgdG9Cb29sZWFuLFxuICB1bnBhdGNoZWRNaWNyb1Rhc2ssXG59IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgUlhfVklSVFVBTF9TQ1JPTExfREVGQVVMVF9PUFRJT05TIH0gZnJvbSAnLi4vdmlydHVhbC1zY3JvbGwuY29uZmlnJztcbmltcG9ydCB7IFJ4YVJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi9yZXNpemUtb2JzZXJ2ZXInO1xuXG4vKiogQGludGVybmFsICovXG50eXBlIFZpcnR1YWxWaWV3SXRlbSA9IHtcbiAgc2l6ZTogbnVtYmVyO1xuICBjYWNoZWQ/OiBib29sZWFuO1xuICBwb3NpdGlvbj86IG51bWJlcjtcbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cbnR5cGUgQW5jaG9ySXRlbSA9IHtcbiAgaW5kZXg6IG51bWJlcjtcbiAgb2Zmc2V0OiBudW1iZXI7XG59O1xuXG5jb25zdCBkZWZhdWx0U2l6ZUV4dHJhY3QgPSAoZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkpID0+XG4gIGVudHJ5LmJvcmRlckJveFNpemVbMF0uYmxvY2tTaXplO1xuXG4vKipcbiAqIEBEaXJlY3RpdmUgQXV0b3NpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3lcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGUgYEF1dG9zaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5YCBwcm92aWRlcyBhIHR3aXR0ZXItbGlrZSB2aXJ0dWFsLXNjcm9sbGluZ1xuICogZXhwZXJpZW5jZS4gSXQgaXMgYWJsZSB0byByZW5kZXIgYW5kIHBvc2l0aW9uIGl0ZW1zIGJhc2VkIG9uIHRoZWlyIGluZGl2aWR1YWxcbiAqIHNpemUuIEl0IGlzIGNvbXBhcmFibGUgdG8gXFxAYW5ndWxhci9jZGsvZXhwZXJpbWVudGFsIGBBdXRvc2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAsIGJ1dFxuICogd2l0aCBhIGhpZ2ggcGVyZm9ybWFudCBsYXlvdXRpbmcgdGVjaG5pcXVlIGFuZCBtb3JlIGZlYXR1cmVzLlxuICpcbiAqIE9uIHRvcCBvZiB0aGlzIHRoZSBgQXV0b3NpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3lgIGlzIGxldmVyYWdpbmcgdGhlIG5hdGl2ZVxuICogYFJlc2l6ZU9ic2VydmVyYCBpbiBvcmRlciB0byBkZXRlY3Qgc2l6ZSBjaGFuZ2VzIGZvciBlYWNoIGluZGl2aWR1YWwgdmlld1xuICogcmVuZGVyZWQgdG8gdGhlIERPTSBhbmQgcHJvcGVybHkgcmUtcG9zaXRpb24gYWNjb3JkaW5nbHkuXG4gKlxuICogSW4gb3JkZXIgdG8gcHJvdmlkZSB0b3Atbm90Y2ggcnVudGltZSBwZXJmb3JtYW5jZSB0aGUgYEF1dG9zaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5YFxuICogYnVpbGRzIHVwIGNhY2hlcyB0aGF0IHByZXZlbnQgRE9NIGludGVyYWN0aW9ucyB3aGVuZXZlciBwb3NzaWJsZS4gT25jZSBhIHZpZXdcbiAqIHdhcyB2aXNpdGVkLCBpdHMgcHJvcGVydGllcyB3aWxsIGJlIHN0b3JlZCBpbnN0ZWFkIG9mIHJlLXJlYWQgZnJvbSB0aGUgRE9NIGFnYWluIGFzXG4gKiB0aGlzIGNhbiBwb3RlbnRpYWxseSBsZWFkIHRvIHVud2FudGVkIGZvcmNlZCByZWZsb3dzLlxuICpcbiAqIEBkb2NzQ2F0ZWdvcnkgUnhWaXJ0dWFsRm9yXG4gKiBAZG9jc1BhZ2UgUnhWaXJ0dWFsRm9yXG4gKiBAcHVibGljQXBpXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ3J4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0W2F1dG9zaXplXScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IFJ4VmlydHVhbFNjcm9sbFN0cmF0ZWd5LFxuICAgICAgdXNlRXhpc3Rpbmc6IEF1dG9TaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5LFxuICAgIH0sXG4gICAgUnhhUmVzaXplT2JzZXJ2ZXIsXG4gIF0sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG59KVxuZXhwb3J0IGNsYXNzIEF1dG9TaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5PFxuICAgIFQsXG4gICAgVSBleHRlbmRzIE5nSXRlcmFibGU8VD4gPSBOZ0l0ZXJhYmxlPFQ+LFxuICA+XG4gIGV4dGVuZHMgUnhWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3k8VCwgVT5cbiAgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveVxue1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRzPyA9IGluamVjdChSWF9WSVJUVUFMX1NDUk9MTF9ERUZBVUxUX09QVElPTlMsIHtcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgYW1vdW50IG9mIGl0ZW1zIHRvIHJlbmRlciB1cGZyb250IGluIHNjcm9sbCBkaXJlY3Rpb25cbiAgICovXG4gIEBJbnB1dCgpIHJ1bndheUl0ZW1zID0gdGhpcy5kZWZhdWx0cz8ucnVud2F5SXRlbXMgPz8gMTA7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgYW1vdW50IG9mIGl0ZW1zIHRvIHJlbmRlciB1cGZyb250IGluIHJldmVyc2Ugc2Nyb2xsIGRpcmVjdGlvblxuICAgKi9cbiAgQElucHV0KCkgcnVud2F5SXRlbXNPcHBvc2l0ZSA9IHRoaXMuZGVmYXVsdHM/LnJ1bndheUl0ZW1zT3Bwb3NpdGUgPz8gMjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBkZWZhdWx0IHNpemUgb2YgdGhlIGl0ZW1zIGJlaW5nIHJlbmRlcmVkLiBUaGUgYXV0b3NpemVkIHN0cmF0ZWd5IHdpbGwgYXNzdW1lXG4gICAqIHRoaXMgc2l6ZSBmb3IgaXRlbXMgaXQgZG9lc24ndCBrbm93IHlldC4gRm9yIHRoZSBzbW9vdGhlc3QgZXhwZXJpZW5jZSxcbiAgICogeW91IHByb3ZpZGUgdGhlIG1lYW4gc2l6ZSBvZiBhbGwgaXRlbXMgYmVpbmcgcmVuZGVyZWQgLSBpZiBwb3NzaWJsZSBvZiBjb3Vyc2UuXG4gICAqXG4gICAqIEFzIHNvb24gYXMgcnhWaXJ0dWFsRm9yIGlzIGFibGUgdG8gYWxzbyByZW5kZXIgYWN0dWFsIHRvbWJzdG9uZSBpdGVtcywgdGhpc1xuICAgKiB3aWxsIGJlIHRoZSBzaXplIG9mIGEgdG9tYnN0b25lIGl0ZW0gYmVpbmcgcmVuZGVyZWQgYmVmb3JlIHRoZSBhY3R1YWwgaXRlbVxuICAgKiBpcyBpbnNlcnRlZCBpbnRvIGl0cyBwb3NpdGlvbi5cbiAgICovXG4gIEBJbnB1dCgpIHRvbWJzdG9uZVNpemUgPSB0aGlzLmRlZmF1bHRzPy5pdGVtU2l6ZSA/PyA1MDtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBhdXRvc2l6ZWQgc3RyYXRlZ3kgdXNlcyB0aGUgbmF0aXZlIFJlc2l6ZU9ic2VydmVyIGluIG9yZGVyIHRvIGRldGVybWluZVxuICAgKiBpZiBhbiBpdGVtIGNoYW5nZWQgaW4gc2l6ZSB0byBhZnRlcndhcmRzIHByb3Blcmx5IHBvc2l0aW9uIHRoZSB2aWV3cy5cbiAgICogWW91IGNhbiBjdXN0b21pemUgdGhlIGNvbmZpZyBwYXNzZWQgdG8gdGhlIFJlc2l6ZU9ic2VydmVyIGFzIHdlbGwgYXMgZGV0ZXJtaW5lXG4gICAqIHdoaWNoIHJlc3VsdCBwcm9wZXJ0eSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB0aGUgdmlld3Mgc2l6ZS5cbiAgICovXG4gIEBJbnB1dCgpIHJlc2l6ZU9ic2VydmVyQ29uZmlnPzoge1xuICAgIG9wdGlvbnM/OiBSZXNpemVPYnNlcnZlck9wdGlvbnM7XG4gICAgZXh0cmFjdFNpemU/OiAoZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkpID0+IG51bWJlcjtcbiAgfTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFdoZW4gZW5hYmxlZCwgdGhlIGF1dG9zaXplZCBzY3JvbGwgc3RyYXRlZ3kgYXR0YWNoZXMgYSBgUmVzaXplT2JzZXJ2ZXJgXG4gICAqIHRvIGV2ZXJ5IHZpZXcgd2l0aGluIHRoZSBnaXZlbiByZW5kZXJlZFJhbmdlLiBJZiB5b3VyIHZpZXdzIHJlY2VpdmVcbiAgICogZGltZW5zaW9uIGNoYW5nZXMgdGhhdCBhcmUgbm90IGNhdXNlZCBieSBsaXN0IHVwZGF0ZXMsIHRoaXMgaXMgYSB3YXkgdG9cbiAgICogc3RpbGwgdHJhY2sgaGVpZ2h0IGNoYW5nZXMuIFRoaXMgYWxzbyBhcHBsaWVzIHRvIHJlc2l6ZSBldmVudHMgb2YgdGhlIHdob2xlXG4gICAqIGRvY3VtZW50LlxuICAgKi9cbiAgQElucHV0KHsgdHJhbnNmb3JtOiB0b0Jvb2xlYW4gfSkgd2l0aFJlc2l6ZU9ic2VydmVyID0gdHJ1ZTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFdoZW4gZW5hYmxlZCwgdGhlIHNjcm9sbCBzdHJhdGVneSBzdG9wcyByZW1vdmluZyB2aWV3cyBmcm9tIHRoZSB2aWV3cG9ydCxcbiAgICogaW5zdGVhZCBpdCBvbmx5IGFkZHMgdmlld3MuIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBvbiB0aGUgZmx5LiBWaWV3cyB3aWxsIGJlIGFkZGVkIGluIGJvdGggZGlyZWN0aW9uc1xuICAgKiBhY2NvcmRpbmcgdG8gdGhlIHVzZXIgaW50ZXJhY3Rpb25zLlxuICAgKi9cbiAgQElucHV0KHsgdHJhbnNmb3JtOiB0b0Jvb2xlYW4gfSkgYXBwZW5kT25seSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogV2hlbiBlbmFibGVkLCB0aGUgYXV0b3NpemVkIHNjcm9sbCBzdHJhdGVneSByZW1vdmVzIGNzcyBzdHlsZXMgdGhhdFxuICAgKiBwcmV2ZW50IHRoZSBzY3JvbGxiYXIgZnJvbSBiZWluZyBpbiBzeW5jIHdpdGggdGhlIGlucHV0IGRldmljZS5cbiAgICogVXNlIHdpdGggY2F1dGlvbiwgYXMgdGhpcyBjYW4gbGVhZCB0byBleHRyZW1lbHkgd2VpcmQgc2Nyb2xsIGJlaGF2aW9yXG4gICAqIG9uIGNocm9taXVtIGJhc2VkIGJyb3dzZXJzIHdoZW4gdGhlIHJlbmRlcmVkIHZpZXdzIGRpZmZlclxuICAgKiBpbiBkaW1lbnNpb25zIHRvbyBtdWNoIG9yIGNoYW5nZSBkaW1lbnNpb25zIGhlYXZpbHkuXG4gICAqL1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IHRvQm9vbGVhbiB9KSB3aXRoU3luY1Njcm9sbGJhciA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSWYgdGhpcyBmbGFnIGlzIHRydWUsIHRoZSB2aXJ0dWFsIHNjcm9sbCBzdHJhdGVneSBtYWludGFpbnMgdGhlIHNjcm9sbGVkIGl0ZW0gd2hlbiBuZXcgZGF0YVxuICAgKiBpcyBwcmVwZW5kZWQgdG8gdGhlIGxpc3QuIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiBpbXBsZW1lbnRpbmcgYSByZXZlcnNlZCBpbmZpbml0ZSBzY3JvbGxlciwgdGhhdCBwcmVwZW5kc1xuICAgKiBkYXRhIGluc3RlYWQgb2YgYXBwZW5kaW5nIGl0XG4gICAqL1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IHRvQm9vbGVhbiB9KSBrZWVwU2Nyb2xsZWRJbmRleE9uUHJlcGVuZCA9IGZhbHNlO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB2aWV3cG9ydDogUnhWaXJ0dWFsU2Nyb2xsVmlld3BvcnQgfCBudWxsID0gbnVsbDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHZpZXdSZXBlYXRlcjogUnhWaXJ0dWFsVmlld1JlcGVhdGVyPFQsIFU+IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb250ZW50U2l6ZSQgPSBuZXcgUmVwbGF5U3ViamVjdDxudW1iZXI+KDEpO1xuICAvKiogQGludGVybmFsICovXG4gIG92ZXJyaWRlIHJlYWRvbmx5IGNvbnRlbnRTaXplJCA9IHRoaXMuX2NvbnRlbnRTaXplJC5hc09ic2VydmFibGUoKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX2NvbnRlbnRTaXplID0gMDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHNldCBjb250ZW50U2l6ZShzaXplOiBudW1iZXIpIHtcbiAgICB0aGlzLl9jb250ZW50U2l6ZSA9IHNpemU7XG4gICAgdGhpcy5fY29udGVudFNpemUkLm5leHQoc2l6ZSk7XG4gIH1cbiAgcHJpdmF0ZSBnZXQgY29udGVudFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudFNpemU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX3JlbmRlcmVkUmFuZ2UkID0gbmV3IFN1YmplY3Q8TGlzdFJhbmdlPigpO1xuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IHJlbmRlcmVkUmFuZ2UkID0gdGhpcy5fcmVuZGVyZWRSYW5nZSQuYXNPYnNlcnZhYmxlKCk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcmVuZGVyZWRSYW5nZTogTGlzdFJhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHNldCByZW5kZXJlZFJhbmdlKHJhbmdlOiBMaXN0UmFuZ2UpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9yZW5kZXJlZFJhbmdlLnN0YXJ0ICE9PSByYW5nZS5zdGFydCB8fFxuICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZS5lbmQgIT09IHJhbmdlLmVuZFxuICAgICkge1xuICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZSA9IHJhbmdlO1xuICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZSQubmV4dChyYW5nZSk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBnZXQgcmVuZGVyZWRSYW5nZSgpOiBMaXN0UmFuZ2Uge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZFJhbmdlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBwb3NpdGlvbmVkUmFuZ2U6IExpc3RSYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfc2Nyb2xsZWRJbmRleCQgPSBuZXcgUmVwbGF5U3ViamVjdDxudW1iZXI+KDEpO1xuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IHNjcm9sbGVkSW5kZXgkID0gdGhpcy5fc2Nyb2xsZWRJbmRleCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9zY3JvbGxlZEluZGV4ID0gMDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGdldCBzY3JvbGxlZEluZGV4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbGVkSW5kZXg7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHNldCBzY3JvbGxlZEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLl9zY3JvbGxlZEluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fc2Nyb2xsZWRJbmRleCQubmV4dChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogaXMgc2V0LCB3aGVuIHNjcm9sbFRvSW5kZXggaXMgY2FsbGVkXG4gICAqIEBpbnRlcm5hbFxuICAgKiAqL1xuICBwcml2YXRlIF9zY3JvbGxUb0luZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgY29udGFpbmVyU2l6ZSA9IDA7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBjb250ZW50TGVuZ3RoID0gMDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF92aXJ0dWFsSXRlbXM6IFZpcnR1YWxWaWV3SXRlbVtdID0gW107XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzY3JvbGxUb3AgPSAwO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc2Nyb2xsVG9wV2l0aE91dE9mZnNldCA9IDA7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzY3JvbGxUb3BBZnRlck9mZnNldCA9IDA7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB2aWV3cG9ydE9mZnNldCA9IDA7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBkaXJlY3Rpb246ICd1cCcgfCAnZG93bicgPSAnZG93bic7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBhbmNob3JTY3JvbGxUb3AgPSAwO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBhbmNob3JJdGVtID0ge1xuICAgIGluZGV4OiAwLFxuICAgIG9mZnNldDogMCxcbiAgfTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGxhc3RTY3JlZW5JdGVtID0ge1xuICAgIGluZGV4OiAwLFxuICAgIG9mZnNldDogMCxcbiAgfTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgd2FpdEZvclNjcm9sbCA9IGZhbHNlO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBpc1N0YWJsZSQgPSBuZXcgUmVwbGF5U3ViamVjdDxib29sZWFuPigxKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZGV0YWNoZWQkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVzaXplT2JzZXJ2ZXIgPSBpbmplY3QoUnhhUmVzaXplT2JzZXJ2ZXIsIHsgc2VsZjogdHJ1ZSB9KTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHJlY2FsY3VsYXRlUmFuZ2UkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgdW50aWwkPEE+KCk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxBPiB7XG4gICAgcmV0dXJuIChvJCkgPT4gbyQucGlwZSh0YWtlVW50aWwodGhpcy5kZXRhY2hlZCQpKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBnZXQgZXh0cmFjdFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzaXplT2JzZXJ2ZXJDb25maWc/LmV4dHJhY3RTaXplID8/IGRlZmF1bHRTaXplRXh0cmFjdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgb3ZlcnJpZGUgZ2V0IGlzU3RhYmxlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLmlzU3RhYmxlJC5waXBlKGZpbHRlcigodykgPT4gdykpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKFxuICAgICAgKGNoYW5nZXNbJ3J1bndheUl0ZW1zT3Bwb3NpdGUnXSAmJlxuICAgICAgICAhY2hhbmdlc1sncnVud2F5SXRlbXNPcHBvc2l0ZSddLmZpcnN0Q2hhbmdlKSB8fFxuICAgICAgKGNoYW5nZXNbJ3J1bndheUl0ZW1zJ10gJiYgIWNoYW5nZXNbJ3J1bndheUl0ZW1zJ10uZmlyc3RDaGFuZ2UpXG4gICAgKSB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlUmFuZ2UkLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZXNbJ3dpdGhTeW5jU2Nyb2xsYmFyJ10pIHtcbiAgICAgIHRoaXMudXBkYXRlU2Nyb2xsRWxlbWVudENsYXNzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhdHRhY2goXG4gICAgdmlld3BvcnQ6IFJ4VmlydHVhbFNjcm9sbFZpZXdwb3J0LFxuICAgIHZpZXdSZXBlYXRlcjogUnhWaXJ0dWFsVmlld1JlcGVhdGVyPFQsIFU+LFxuICApOiB2b2lkIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy52aWV3UmVwZWF0ZXIgPSB2aWV3UmVwZWF0ZXI7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxFbGVtZW50Q2xhc3MoKTtcbiAgICB0aGlzLm1haW50YWluVmlydHVhbEl0ZW1zKCk7XG4gICAgdGhpcy5jYWxjUmVuZGVyZWRSYW5nZSgpO1xuICAgIHRoaXMucG9zaXRpb25FbGVtZW50cygpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBkZXRhY2goKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxFbGVtZW50Q2xhc3MoZmFsc2UpO1xuICAgIHRoaXMudmlld3BvcnQgPSBudWxsO1xuICAgIHRoaXMudmlld1JlcGVhdGVyID0gbnVsbDtcbiAgICB0aGlzLl92aXJ0dWFsSXRlbXMgPSBbXTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRldGFjaGVkJC5uZXh0KCk7XG4gIH1cblxuICBzY3JvbGxUb0luZGV4KGluZGV4OiBudW1iZXIsIGJlaGF2aW9yPzogU2Nyb2xsQmVoYXZpb3IpOiB2b2lkIHtcbiAgICBjb25zdCBfaW5kZXggPSBNYXRoLm1pbihNYXRoLm1heChpbmRleCwgMCksIHRoaXMuY29udGVudExlbmd0aCAtIDEpO1xuICAgIGlmIChfaW5kZXggIT09IHRoaXMuc2Nyb2xsZWRJbmRleCkge1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5jYWxjSW5pdGlhbFBvc2l0aW9uKF9pbmRleCk7XG4gICAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0gX2luZGV4O1xuICAgICAgdGhpcy5zY3JvbGxUbyhzY3JvbGxUb3AsIGJlaGF2aW9yKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNjcm9sbFRvKHNjcm9sbFRvOiBudW1iZXIsIGJlaGF2aW9yPzogU2Nyb2xsQmVoYXZpb3IpOiB2b2lkIHtcbiAgICB0aGlzLndhaXRGb3JTY3JvbGwgPVxuICAgICAgc2Nyb2xsVG8gIT09IHRoaXMuc2Nyb2xsVG9wICYmIHRoaXMuY29udGVudFNpemUgPiB0aGlzLmNvbnRhaW5lclNpemU7XG4gICAgaWYgKHRoaXMud2FpdEZvclNjcm9sbCkge1xuICAgICAgdGhpcy5pc1N0YWJsZSQubmV4dChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMudmlld3BvcnQhLnNjcm9sbFRvKHRoaXMudmlld3BvcnRPZmZzZXQgKyBzY3JvbGxUbywgYmVoYXZpb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIHN0YXJ0cyB0aGUgc3Vic2NyaXB0aW9ucyB0aGF0IG1haW50YWluIHRoZSB2aXJ0dWFsSXRlbXMgYXJyYXkgb24gY2hhbmdlc1xuICAgKiB0byB0aGUgdW5kZXJseWluZyBkYXRhc2V0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBtYWludGFpblZpcnR1YWxJdGVtcygpOiB2b2lkIHtcbiAgICAvLyByZXNldCB2aXJ0dWFsIHZpZXdwb3J0IHdoZW4gb3Bwb3NpdGUgb3JpZW50YXRpb24gdG8gdGhlIHNjcm9sbCBkaXJlY3Rpb25cbiAgICAvLyBjaGFuZ2VzLCBhcyB3ZSBoYXZlIHRvIGV4cGVjdCBkaW1lbnNpb24gY2hhbmdlcyBmb3IgYWxsIGl0ZW1zIHdoZW4gdGhpc1xuICAgIC8vIGhhcHBlbnMuIFRoaXMgY291bGQgYWxzbyBiZSBjb25maWd1cmFibGUgYXMgaXQgbWF5YmUgY29zdHMgcGVyZm9ybWFuY2VcbiAgICB0aGlzLnZpZXdwb3J0IS5jb250YWluZXJSZWN0JC5waXBlKFxuICAgICAgbWFwKCh7IHdpZHRoIH0pID0+IHdpZHRoKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5yZW5kZXJlZFJhbmdlLmVuZCA+IDAgJiYgdGhpcy5fdmlydHVhbEl0ZW1zLmxlbmd0aCA+IDApLFxuICAgICAgdGhpcy51bnRpbCQoKSxcbiAgICApLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyByZXNldCBiZWNhdXNlIHdlIGhhdmUgbm8gaWRlYSBob3cgaXRlbXMgd2lsbCBiZWhhdmVcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgdGhpcy5yZW5kZXJlZFJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxJdGVtc1tpXS5jYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucmVuZGVyZWRSYW5nZS5lbmQ7XG4gICAgICB3aGlsZSAoaSA8IHRoaXMuY29udGVudExlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5fdmlydHVhbEl0ZW1zW2ldLmNhY2hlZCA9IGZhbHNlO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBzeW5jaHJvbmlzZXMgdGhlIHZhbHVlcyB3aXRoIHRoZSB2aXJ0dWFsIHZpZXdwb3J0IHdlJ3ZlIGJ1aWx0IHVwXG4gICAgLy8gaXQgbWlnaHQgZ2V0IGNvc3R5IHdoZW4gaGF2aW5nID4gMTAwayBlbGVtZW50cywgaXQncyBzdGlsbCBmYXN0ZXIgdGhhblxuICAgIC8vIHRoZSBJdGVyYWJsZURpZmZlciBhcHByb2FjaCwgZXNwZWNpYWxseSBvbiBtb3ZlIG9wZXJhdGlvbnNcbiAgICBjb25zdCBpdGVtQ2FjaGUgPSBuZXcgTWFwPGFueSwgeyBpdGVtOiBUOyBpbmRleDogbnVtYmVyIH0+KCk7XG4gICAgY29uc3QgdHJhY2tCeSA9IHRoaXMudmlld1JlcGVhdGVyIS5fdHJhY2tCeSA/PyAoKGksIGl0ZW0pID0+IGl0ZW0pO1xuICAgIHRoaXMucmVuZGVyZWRSYW5nZSRcbiAgICAgIC5waXBlKHBhaXJ3aXNlKCksIHRoaXMudW50aWwkKCkpXG4gICAgICAuc3Vic2NyaWJlKChbb2xkUmFuZ2UsIG5ld1JhbmdlXSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gb2xkUmFuZ2Uuc3RhcnQ7IGkgPCBvbGRSYW5nZS5lbmQ7IGkrKykge1xuICAgICAgICAgIGlmIChpIDwgbmV3UmFuZ2Uuc3RhcnQgfHwgaSA+PSBuZXdSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpcnR1YWxJdGVtc1tpXS5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHRoaXMudmlld1JlcGVhdGVyIS52YWx1ZXMkLnBpcGUoXG4gICAgICB0aGlzLnVudGlsJCgpLFxuICAgICAgdGFwKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YUFyciA9IEFycmF5LmlzQXJyYXkodmFsdWVzKVxuICAgICAgICAgID8gdmFsdWVzXG4gICAgICAgICAgOiB2YWx1ZXNcbiAgICAgICAgICAgID8gQXJyYXkuZnJvbSh2YWx1ZXMpXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQ8YW55PigpO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdmlydHVhbEl0ZW1zID0gbmV3IEFycmF5PFZpcnR1YWxWaWV3SXRlbT4oZGF0YUxlbmd0aCk7XG4gICAgICAgIGxldCBhbmNob3JJdGVtSW5kZXggPSB0aGlzLmFuY2hvckl0ZW0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGtlZXBTY3JvbGxlZEluZGV4T25QcmVwZW5kID1cbiAgICAgICAgICB0aGlzLmtlZXBTY3JvbGxlZEluZGV4T25QcmVwZW5kICYmXG4gICAgICAgICAgZGF0YUFyci5sZW5ndGggPiAwICYmXG4gICAgICAgICAgaXRlbUNhY2hlLnNpemUgPiAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhQXJyW2ldO1xuICAgICAgICAgIGNvbnN0IGlkID0gdHJhY2tCeShpLCBpdGVtKTtcbiAgICAgICAgICBjb25zdCBjYWNoZWRJdGVtID0gaXRlbUNhY2hlLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNhY2hlZEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgICB2aXJ0dWFsSXRlbXNbaV0gPSB7IHNpemU6IDAgfTtcbiAgICAgICAgICAgIGl0ZW1DYWNoZS5zZXQoaWQsIHsgaXRlbTogZGF0YUFycltpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgICBpZiAoaSA8PSBhbmNob3JJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgYW5jaG9ySXRlbUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjYWNoZWRJdGVtLmluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICAvLyBtb3ZlXG4gICAgICAgICAgICB2aXJ0dWFsSXRlbXNbaV0gPSB0aGlzLl92aXJ0dWFsSXRlbXNbY2FjaGVkSXRlbS5pbmRleF07XG4gICAgICAgICAgICB2aXJ0dWFsSXRlbXNbaV0ucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtQ2FjaGUuc2V0KGlkLCB7IGl0ZW06IGRhdGFBcnJbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgIC8vIHRvZG86IHByb3Blcmx5IGRldGVybWluZSB1cGRhdGUgKE9iamVjdC5pcz8pXG4gICAgICAgICAgICB2aXJ0dWFsSXRlbXNbaV0gPSB0aGlzLl92aXJ0dWFsSXRlbXNbaV07XG4gICAgICAgICAgICAvLyBpZiBpbmRleCBpcyBub3QgcGFydCBvZiByZW5kZXJlZCByYW5nZSwgcmVtb3ZlIGNhY2hlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF0aGlzLndpdGhSZXNpemVPYnNlcnZlciB8fFxuICAgICAgICAgICAgICBpIDwgdGhpcy5yZW5kZXJlZFJhbmdlLnN0YXJ0IHx8XG4gICAgICAgICAgICAgIGkgPj0gdGhpcy5yZW5kZXJlZFJhbmdlLmVuZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZpcnR1YWxJdGVtc1tpXS5jYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1DYWNoZS5zZXQoaWQsIHsgaXRlbTogZGF0YUFycltpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4aXN0aW5nSWRzLmFkZChpZCk7XG4gICAgICAgICAgc2l6ZSArPSB2aXJ0dWFsSXRlbXNbaV0uc2l6ZSB8fCB0aGlzLnRvbWJzdG9uZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlydHVhbEl0ZW1zID0gdmlydHVhbEl0ZW1zO1xuICAgICAgICAvLyBzeW5jIGRlbGV0ZSBvcGVyYXRpb25zXG4gICAgICAgIGlmIChpdGVtQ2FjaGUuc2l6ZSA+IGRhdGFMZW5ndGgpIHtcbiAgICAgICAgICBpdGVtQ2FjaGUuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ0lkcy5oYXMoaykpIHtcbiAgICAgICAgICAgICAgaXRlbUNhY2hlLmRlbGV0ZShrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZ0lkcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2VlcFNjcm9sbGVkSW5kZXhPblByZXBlbmQgJiZcbiAgICAgICAgICB0aGlzLmFuY2hvckl0ZW0uaW5kZXggIT09IGFuY2hvckl0ZW1JbmRleFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgoYW5jaG9ySXRlbUluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoIDwgdGhpcy5fcmVuZGVyZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgICBjb25zdCByYW5nZURpZmYgPSB0aGlzLl9yZW5kZXJlZFJhbmdlLmVuZCAtIHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgYW5jaG9yRGlmZiA9IHRoaXMuYW5jaG9ySXRlbS5pbmRleCAtIHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZS5lbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGRhdGFMZW5ndGgsXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZFJhbmdlLmVuZCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZFJhbmdlLmVuZCAtIHJhbmdlRGlmZixcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIHRoaXMuYW5jaG9ySXRlbS5vZmZzZXQgPSAwO1xuICAgICAgICAgIHRoaXMuYW5jaG9ySXRlbS5pbmRleCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQgKyBhbmNob3JEaWZmLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5jYWxjQW5jaG9yU2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHNpemU7XG4gICAgICB9KSxcbiAgICAgIGZpbmFsaXplKCgpID0+IGl0ZW1DYWNoZS5jbGVhcigpKSxcbiAgICApLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpc3RlbiB0byB0cmlnZ2VycyB0aGF0IHNob3VsZCBjaGFuZ2UgdGhlIHJlbmRlcmVkUmFuZ2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIGNhbGNSZW5kZXJlZFJhbmdlKCk6IHZvaWQge1xuICAgIGxldCByZW1vdmVTY3JvbGxBbmNob3JPbk5leHRTY3JvbGwgPSBmYWxzZTtcbiAgICBjb25zdCBvbmx5VHJpZ2dlcldoZW5TdGFibGUgPVxuICAgICAgPEE+KCkgPT5cbiAgICAgIChvJDogT2JzZXJ2YWJsZTxBPikgPT5cbiAgICAgICAgbyQucGlwZShcbiAgICAgICAgICBmaWx0ZXIoXG4gICAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkUmFuZ2UuZW5kID09PSAwIHx8XG4gICAgICAgICAgICAgICh0aGlzLnNjcm9sbFRvcCA9PT0gdGhpcy5hbmNob3JTY3JvbGxUb3AgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID09PSBudWxsKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgIGNvbWJpbmVMYXRlc3QoW1xuICAgICAgdGhpcy52aWV3cG9ydCEuY29udGFpbmVyUmVjdCQucGlwZShcbiAgICAgICAgbWFwKCh7IGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gaGVpZ2h0O1xuICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgICBvbmx5VHJpZ2dlcldoZW5TdGFibGUoKSxcbiAgICAgICksXG4gICAgICB0aGlzLnZpZXdwb3J0IS5lbGVtZW50U2Nyb2xsZWQkLnBpcGUoXG4gICAgICAgIHN0YXJ0V2l0aCh2b2lkIDApLFxuICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgIHRoaXMudmlld3BvcnRPZmZzZXQgPSB0aGlzLnZpZXdwb3J0IS5tZWFzdXJlT2Zmc2V0KCk7XG4gICAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbFRvcFdpdGhPdXRPZmZzZXQsIHNjcm9sbFRvcEFmdGVyT2Zmc2V0IH0gPVxuICAgICAgICAgICAgcGFyc2VTY3JvbGxUb3BCb3VuZGFyaWVzKFxuICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0IS5nZXRTY3JvbGxUb3AoKSxcbiAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydE9mZnNldCxcbiAgICAgICAgICAgICAgdGhpcy5fY29udGVudFNpemUsXG4gICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPVxuICAgICAgICAgICAgc2Nyb2xsVG9wV2l0aE91dE9mZnNldCA+IHRoaXMuc2Nyb2xsVG9wV2l0aE91dE9mZnNldFxuICAgICAgICAgICAgICA/ICdkb3duJ1xuICAgICAgICAgICAgICA6ICd1cCc7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb3BXaXRoT3V0T2Zmc2V0ID0gc2Nyb2xsVG9wV2l0aE91dE9mZnNldDtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvcEFmdGVyT2Zmc2V0ID0gc2Nyb2xsVG9wQWZ0ZXJPZmZzZXQ7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgaWYgKHJlbW92ZVNjcm9sbEFuY2hvck9uTmV4dFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9JbmRleCA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVTY3JvbGxBbmNob3JPbk5leHRTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlU2Nyb2xsQW5jaG9yT25OZXh0U2Nyb2xsID0gdGhpcy5fc2Nyb2xsVG9JbmRleCAhPT0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53YWl0Rm9yU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIHRoaXMuX2NvbnRlbnRTaXplJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIG9ubHlUcmlnZ2VyV2hlblN0YWJsZSgpKSxcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVSYW5nZSQucGlwZShvbmx5VHJpZ2dlcldoZW5TdGFibGUoKSwgc3RhcnRXaXRoKHZvaWQgMCkpLFxuICAgIF0pXG4gICAgICAucGlwZShcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIG5vdCBvdmVyIGNhbGN1bGF0ZSB0aGluZ3MgYnkgY29hbGVzY2luZyBhbGwgdHJpZ2dlcnMgdG8gdGhlIG5leHQgbWljcm90YXNrXG4gICAgICAgIGNvYWxlc2NlV2l0aCh1bnBhdGNoZWRNaWNyb1Rhc2soKSksXG4gICAgICAgIG1hcCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuc2Nyb2xsVG9wIC0gdGhpcy5hbmNob3JTY3JvbGxUb3A7XG4gICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9ySXRlbSA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvckl0ZW0gPSB0aGlzLmNhbGN1bGF0ZUFuY2hvcmVkSXRlbShcbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JJdGVtLFxuICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7XG4gICAgICAgICAgdGhpcy5zY3JvbGxlZEluZGV4ID0gdGhpcy5hbmNob3JJdGVtLmluZGV4O1xuICAgICAgICAgIHRoaXMubGFzdFNjcmVlbkl0ZW0gPSB0aGlzLmNhbGN1bGF0ZUFuY2hvcmVkSXRlbShcbiAgICAgICAgICAgIHRoaXMuYW5jaG9ySXRlbSxcbiAgICAgICAgICAgIGNhbGN1bGF0ZVZpc2libGVDb250YWluZXJTaXplKFxuICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUsXG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wV2l0aE91dE9mZnNldCxcbiAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BBZnRlck9mZnNldCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5hbmNob3JJdGVtLmluZGV4IC0gdGhpcy5ydW53YXlJdGVtcyk7XG4gICAgICAgICAgICByYW5nZS5lbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgdGhpcy5jb250ZW50TGVuZ3RoLFxuICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JlZW5JdGVtLmluZGV4ICsgdGhpcy5ydW53YXlJdGVtc09wcG9zaXRlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JJdGVtLmluZGV4IC0gdGhpcy5ydW53YXlJdGVtc09wcG9zaXRlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgICAgIHRoaXMubGFzdFNjcmVlbkl0ZW0uaW5kZXggKyB0aGlzLnJ1bndheUl0ZW1zLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuYXBwZW5kT25seSkge1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSBNYXRoLm1pbih0aGlzLl9yZW5kZXJlZFJhbmdlLnN0YXJ0LCByYW5nZS5zdGFydCk7XG4gICAgICAgICAgICByYW5nZS5lbmQgPSBNYXRoLm1heCh0aGlzLl9yZW5kZXJlZFJhbmdlLmVuZCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9KSxcbiAgICAgIClcbiAgICAgIC5waXBlKHRoaXMudW50aWwkKCkpXG4gICAgICAuc3Vic2NyaWJlKChyYW5nZTogTGlzdFJhbmdlKSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLmlzU3RhYmxlJC5uZXh0KCF0aGlzLndhaXRGb3JTY3JvbGwpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcG9zaXRpb24gZWxlbWVudHMgYWZ0ZXIgdGhleSBhcmUgY3JlYXRlZC91cGRhdGVkL21vdmVkIG9yIHRoZWlyIGRpbWVuc2lvbnNcbiAgICogY2hhbmdlIGZyb20gb3RoZXIgc291cmNlc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgcG9zaXRpb25FbGVtZW50cygpOiB2b2lkIHtcbiAgICBjb25zdCB2aWV3c1RvT2JzZXJ2ZSQgPSBuZXcgU3ViamVjdDxcbiAgICAgIEVtYmVkZGVkVmlld1JlZjxSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxULCBVPj5cbiAgICA+KCk7XG4gICAgY29uc3QgcG9zaXRpb25CeUl0ZXJhYmxlQ2hhbmdlJCA9IHRoaXMudmlld1JlcGVhdGVyIS5yZW5kZXJpbmdTdGFydCQucGlwZShcbiAgICAgIHN3aXRjaE1hcCgoYmF0Y2hlZFVwZGF0ZXMpID0+IHtcbiAgICAgICAgLy8gaW5pdGlhbEluZGV4IHRlbGxzIHVzIHdoYXQgd2lsbCBiZSB0aGUgZmlyc3QgaW5kZXggdG8gYmUgY2hhbmdlIGRldGVjdGVkXG4gICAgICAgIC8vIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCBvbmUsIHdlIG1heWJlIGhhdmUgdG8gYWRqdXN0IHRoZSBwb3NpdGlvblxuICAgICAgICAvLyBvZiBhbGwgaXRlbXMgaW4gdGhlIHZpZXdwb3J0IGJlZm9yZSB0aGlzIGluZGV4XG4gICAgICAgIGNvbnN0IGluaXRpYWxJbmRleCA9IGJhdGNoZWRVcGRhdGVzLnNpemVcbiAgICAgICAgICA/IGJhdGNoZWRVcGRhdGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSArIHRoaXMucmVuZGVyZWRSYW5nZS5zdGFydFxuICAgICAgICAgIDogdGhpcy5yZW5kZXJlZFJhbmdlLnN0YXJ0O1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgc2Nyb2xsVG9BbmNob3JQb3NpdGlvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdSZXBlYXRlciEudmlld1JlbmRlcmVkJC5waXBlKFxuICAgICAgICAgIHRhcCgoeyB2aWV3LCBpbmRleDogdmlld0luZGV4LCBpdGVtIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHZpZXcuY29udGV4dC5pbmRleDtcbiAgICAgICAgICAgIC8vIHRoaXMgbW9zdCBvZiB0aGUgdGltZSBjYXVzZXMgYSBmb3JjZWQgcmVmbG93IHBlciByZW5kZXJlZCB2aWV3LlxuICAgICAgICAgICAgLy8gaXQgZG9lc24ndCBzb3VuZCBnb29kLCBidXQgaXQncyBzdGlsbCB3YXkgbW9yZSBzdGFibGUgdGhhblxuICAgICAgICAgICAgLy8gaGF2aW5nIG9uZSBsYXJnZSByZWZsb3cgaW4gYSBtaWNyb3Rhc2sgYWZ0ZXIgdGhlIGFjdHVhbFxuICAgICAgICAgICAgLy8gc2NoZWR1bGVyIHRpY2suXG4gICAgICAgICAgICAvLyBSaWdodCBoZXJlLCB3ZSBjYW4gaW5zZXJ0IHdvcmsgaW50byB0aGUgdGFzayB3aGljaCBpcyBjdXJyZW50bHlcbiAgICAgICAgICAgIC8vIGV4ZWN1dGVkIGFzIHBhcnQgb2YgdGhlIGNvbmN1cnJlbnQgc2NoZWR1bGVyIHRpY2suXG4gICAgICAgICAgICAvLyBjYXVzaW5nIHRoZSBmb3JjZWQgcmVmbG93IGhlcmUsIGFsc28gbWFrZXMgaXQgY291bnQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gc2NoZWR1bGVycyBmcmFtZSBidWRnZXQuIFRoaXMgd2F5IHdlIHdpbGwgYWx3YXlzIHJ1biB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY29uZmlndXJlZCBGUFMuIFRoZSBvbmx5IGNhc2Ugd2hlcmUgdGhpcyBpcyBub3QgdHJ1ZSBpcyB3aGVuIHJlbmRlcmluZyAxIHNpbmdsZSB2aWV3XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGV4cGxvZGVzIHRoZSBidWRnZXRcbiAgICAgICAgICAgIGNvbnN0IFssIHNpemVEaWZmXSA9IHRoaXMudXBkYXRlRWxlbWVudFNpemUodmlldywgaXRlbUluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxJdGVtID0gdGhpcy5fdmlydHVhbEl0ZW1zW2l0ZW1JbmRleF07XG5cbiAgICAgICAgICAgIC8vIGJlZm9yZSBwb3NpdGlvbmluZyB0aGUgZmlyc3QgdmlldyBvZiB0aGlzIGJhdGNoLCBjYWxjdWxhdGUgdGhlXG4gICAgICAgICAgICAvLyBhbmNob3JTY3JvbGxUb3AgJiBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSB2aWV3XG4gICAgICAgICAgICBpZiAoaXRlbUluZGV4ID09PSBpbml0aWFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYWxjQW5jaG9yU2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5jYWxjSW5pdGlhbFBvc2l0aW9uKGl0ZW1JbmRleCk7XG5cbiAgICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZSBhIHBhcnRpYWwgdXBkYXRlIGFuZCB0aGUgY3VycmVudCB2aWV3cyBwb3NpdGlvbiBpc1xuICAgICAgICAgICAgICAvLyBuZXcsIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgYWxsIHBvc2l0aW9ucyBmcm9tIHZpZXdzIGJlZm9yZSB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAvLyBpbmRleCBhcmUgYWxzbyBvZmYuIFdlIG5lZWQgdG8gYWRqdXN0IHRoZW1cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA+IHRoaXMucmVuZGVyZWRSYW5nZS5zdGFydCAmJlxuICAgICAgICAgICAgICAgIHZpcnR1YWxJdGVtLnBvc2l0aW9uICE9PSBwb3NpdGlvblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGluaXRpYWxJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gdGhpcy5yZW5kZXJlZFJhbmdlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5nZXRWaWV3UmVmKGkgLSB0aGlzLnJlbmRlcmVkUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEl0ZW0gPSB0aGlzLl92aXJ0dWFsSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgYmVmb3JlUG9zaXRpb24gLT0gdmlydHVhbEl0ZW0uc2l6ZTtcbiAgICAgICAgICAgICAgICAgIHZpcnR1YWxJdGVtLnBvc2l0aW9uID0gYmVmb3JlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uRWxlbWVudChlbGVtZW50LCBiZWZvcmVQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1JbmRleCA8IHRoaXMuYW5jaG9ySXRlbS5pbmRleCAmJiBzaXplRGlmZikge1xuICAgICAgICAgICAgICB0aGlzLmFuY2hvclNjcm9sbFRvcCArPSBzaXplRGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB2aXJ0dWFsSXRlbS5zaXplO1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gY3VycmVudCBlbGVtZW50IGlmIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIGlmICh2aXJ0dWFsSXRlbS5wb3NpdGlvbiAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCh2aWV3KTtcbiAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnQoZWxlbWVudCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICB2aXJ0dWFsSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvSW5kZXggPT09IGl0ZW1JbmRleCkge1xuICAgICAgICAgICAgICBzY3JvbGxUb0FuY2hvclBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzaXplO1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgYWN0aXZhdGUgdGhlIFJlc2l6ZU9ic2VydmVyIGFmdGVyIGluaXRpYWwgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIHZpZXdzVG9PYnNlcnZlJC5uZXh0KHZpZXcpO1xuICAgICAgICAgICAgdGhpcy52aWV3UmVuZGVyQ2FsbGJhY2submV4dCh7XG4gICAgICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXgsXG4gICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGFmdGVyIHBvc2l0aW9uaW5nIHRoZSBhY3R1YWwgdmlldywgd2UgYWxzbyBuZWVkIHRvIHBvc2l0aW9uIGFsbFxuICAgICAgICAgICAgLy8gdmlld3MgZnJvbSB0aGUgY3VycmVudCBpbmRleCBvbiB1bnRpbCBlaXRoZXIgdGhlIHJlbmRlcmVkUmFuZ2UuZW5kXG4gICAgICAgICAgICAvLyBpcyBoaXQgb3Igd2UgaGl0IGFuIGluZGV4IHRoYXQgd2lsbCBhbnl3YXkgcmVjZWl2ZSBhbiB1cGRhdGUuXG4gICAgICAgICAgICAvLyB3ZSBjYW4gZGVyaXZlIHRoYXQgaW5mb3JtYXRpb24gZnJvbSB0aGUgYmF0Y2hlZFVwZGF0ZXMgaW5kZXggU2V0XG4gICAgICAgICAgICBjb25zdCB7IGxhc3RQb3NpdGlvbmVkSW5kZXg6IGxhc3RJbmRleCwgcG9zaXRpb246IG5ld1Bvc2l0aW9uIH0gPVxuICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uVW5jaGFuZ2VkVmlld3Moe1xuICAgICAgICAgICAgICAgIHZpZXdJbmRleCxcbiAgICAgICAgICAgICAgICBpdGVtSW5kZXgsXG4gICAgICAgICAgICAgICAgYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25lZFJhbmdlLnN0YXJ0ID0gdGhpcy5yZW5kZXJlZFJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbmVkUmFuZ2UuZW5kID0gbGFzdEluZGV4ICsgMTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjb2FsZXNjZVdpdGgodW5wYXRjaGVkTWljcm9UYXNrKCkpLFxuICAgICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdENvbnRlbnRTaXplKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY3JvbGxUb0luZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMubWF5YmVBZGp1c3RTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb0FuY2hvclBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvQW5jaG9yUG9zaXRpb24gIT09IHRoaXMuYW5jaG9yU2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9BbmNob3JQb3NpdGlvbiA+XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplIC0gdGhpcy5jb250YWluZXJTaXplXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5jaG9ySXRlbVBvc2l0aW9uIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHNjcm9sbFBvcyxcbiAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gc2Nyb2xsIHVudGlsIHRoZSBib3R0b20uXG4gICAgICAgICAgICAgICAgICAvLyBvZiBjb3Vyc2UsIHdlIG5lZWQgdG8gYmUgc3VyZSBhbGwgdGhlIGl0ZW1zIHVudGlsIHRoZSBlbmQgYXJlIHBvc2l0aW9uZWRcbiAgICAgICAgICAgICAgICAgIC8vIHVudGlsIHdlIGFyZSBzdXJlIHRoYXQgd2UgbmVlZCB0byBzY3JvbGwgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRSYW5nZS5lbmQgPT09IHRoaXMucG9zaXRpb25lZFJhbmdlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmNvbnRlbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9JbmRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvKHNjcm9sbFRvQW5jaG9yUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlQWRqdXN0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgKTtcbiAgICBjb25zdCBwb3NpdGlvbkJ5UmVzaXplT2JzZXJ2ZXIkID0gdmlld3NUb09ic2VydmUkLnBpcGUoXG4gICAgICBmaWx0ZXIoKCkgPT4gdGhpcy53aXRoUmVzaXplT2JzZXJ2ZXIpLFxuICAgICAgZ3JvdXBCeSgodmlld1JlZikgPT4gdmlld1JlZiksXG4gICAgICBtZXJnZU1hcCgobyQpID0+XG4gICAgICAgIG8kLnBpcGUoXG4gICAgICAgICAgZXhoYXVzdE1hcCgodmlld1JlZikgPT4gdGhpcy5vYnNlcnZlVmlld1NpemUkKHZpZXdSZWYpKSxcbiAgICAgICAgICB0YXAoKFtpbmRleCwgdmlld0luZGV4XSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxjQW5jaG9yU2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLmNhbGNJbml0aWFsUG9zaXRpb24oaW5kZXgpO1xuICAgICAgICAgICAgbGV0IHZpZXdJZHggPSB2aWV3SW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlydHVhbEl0ZW1zW2luZGV4XS5wb3NpdGlvbiAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byByZXBvc2l0aW9uIHRoZSB3aG9sZSB2aWV3cG9ydCwgd2hlbiB0aGUgY3VycmVudCBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICB3aGlsZSAodmlld0lkeCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3SWR4LS07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gLT1cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnR1YWxJdGVtc1t0aGlzLmdldFZpZXdSZWYodmlld0lkeCkuY29udGV4dC5pbmRleF1cbiAgICAgICAgICAgICAgICAgICAgLnNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byByZXBvc2l0aW9uIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgbmV4dCB2aWV3SW5kZXggb25cbiAgICAgICAgICAgICAgdmlld0lkeCsrO1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSB0aGlzLl92aXJ0dWFsSXRlbXNbaW5kZXhdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBhbGwgdmlld3MgZnJvbSB0aGUgc3BlY2lmaWVkIHZpZXdJbmRleFxuICAgICAgICAgICAgd2hpbGUgKHZpZXdJZHggPCB0aGlzLnZpZXdSZXBlYXRlciEudmlld0NvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0Vmlld1JlZih2aWV3SWR4KTtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gdmlldy5jb250ZXh0LmluZGV4O1xuICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsSXRlbSA9IHRoaXMuX3ZpcnR1YWxJdGVtc1tpdGVtSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHZpZXcpO1xuICAgICAgICAgICAgICB2aXJ0dWFsSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uRWxlbWVudChlbGVtZW50LCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHZpcnR1YWxJdGVtLnNpemU7XG4gICAgICAgICAgICAgIHZpZXdJZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF5YmVBZGp1c3RTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICApO1xuICAgIG1lcmdlKHBvc2l0aW9uQnlJdGVyYWJsZUNoYW5nZSQsIHBvc2l0aW9uQnlSZXNpemVPYnNlcnZlciQpXG4gICAgICAucGlwZSh0aGlzLnVudGlsJCgpKVxuICAgICAgLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGFkanVzdENvbnRlbnRTaXplKHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBsZXQgbmV3Q29udGVudFNpemUgPSBwb3NpdGlvbjtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5wb3NpdGlvbmVkUmFuZ2UuZW5kOyBpIDwgdGhpcy5fdmlydHVhbEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdDb250ZW50U2l6ZSArPSB0aGlzLmdldEl0ZW1TaXplKGkpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRTaXplID0gbmV3Q29udGVudFNpemU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb2JzZXJ2ZVZpZXdTaXplJChcbiAgICB2aWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8UnhWaXJ0dWFsRm9yVmlld0NvbnRleHQ8VCwgVT4+LFxuICApIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHZpZXdSZWYpO1xuICAgIHJldHVybiB0aGlzLnJlc2l6ZU9ic2VydmVyXG4gICAgICAub2JzZXJ2ZUVsZW1lbnQoZWxlbWVudCwgdGhpcy5yZXNpemVPYnNlcnZlckNvbmZpZz8ub3B0aW9ucylcbiAgICAgIC5waXBlKFxuICAgICAgICB0YWtlV2hpbGUoKGV2ZW50KSA9PiBldmVudC50YXJnZXQuaXNDb25uZWN0ZWQpLFxuICAgICAgICBtYXAoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB2aWV3UmVmLmNvbnRleHQuaW5kZXg7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQodGhpcy5leHRyYWN0U2l6ZShldmVudCkpO1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBzaXplIC0gdGhpcy5fdmlydHVhbEl0ZW1zW2luZGV4XS5zaXplO1xuICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl92aXJ0dWFsSXRlbXNbaW5kZXhdLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5fdmlydHVhbEl0ZW1zW2luZGV4XS5jYWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50U2l6ZSArPSBkaWZmO1xuICAgICAgICAgICAgcmV0dXJuIFtpbmRleCwgdGhpcy52aWV3UmVwZWF0ZXIhLnZpZXdDb250YWluZXIuaW5kZXhPZih2aWV3UmVmKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsIGFzIHVua25vd24gYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcihcbiAgICAgICAgICAoZGlmZikgPT5cbiAgICAgICAgICAgIGRpZmYgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGRpZmZbMF0gPj0gdGhpcy5wb3NpdGlvbmVkUmFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgICAgIGRpZmZbMF0gPCB0aGlzLnBvc2l0aW9uZWRSYW5nZS5lbmQsXG4gICAgICAgICksXG4gICAgICAgIHRha2VVbnRpbChcbiAgICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIHRoaXMudmlld1JlcGVhdGVyIS52aWV3UmVuZGVyZWQkLFxuICAgICAgICAgICAgdGhpcy52aWV3UmVwZWF0ZXIhLnJlbmRlcmluZ1N0YXJ0JCxcbiAgICAgICAgICApLnBpcGUoXG4gICAgICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFuIHVwIHRoZSBwb3NpdGlvbiBwcm9wZXJ0eSBmb3Igdmlld3NcbiAgICAgICAgICAgICAgLy8gdGhhdCBmYWxsIG91dCBvZiB0aGUgcmVuZGVyZWRSYW5nZS5cbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2aWV3UmVmLmNvbnRleHQuaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLl92aXJ0dWFsSXRlbXNbaW5kZXhdICYmXG4gICAgICAgICAgICAgICAgKGluZGV4IDwgdGhpcy5yZW5kZXJlZFJhbmdlLnN0YXJ0IHx8XG4gICAgICAgICAgICAgICAgICBpbmRleCA+PSB0aGlzLnJlbmRlcmVkUmFuZ2UuZW5kKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXJ0dWFsSXRlbXNbaW5kZXhdLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZpbHRlcihcbiAgICAgICAgICAgICAgKCkgPT4gdGhpcy52aWV3UmVwZWF0ZXIhLnZpZXdDb250YWluZXIuaW5kZXhPZih2aWV3UmVmKSA9PT0gLTEsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBoZWF2aWx5IGluc3BpcmVkIGJ5XG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvdWktZWxlbWVudC1zYW1wbGVzL2Jsb2IvZ2gtcGFnZXMvaW5maW5pdGUtc2Nyb2xsZXIvc2NyaXB0cy9pbmZpbml0ZS1zY3JvbGwuanNcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlQW5jaG9yZWRJdGVtKFxuICAgIGluaXRpYWxBbmNob3I6IEFuY2hvckl0ZW0sXG4gICAgZGVsdGE6IG51bWJlcixcbiAgKTogQW5jaG9ySXRlbSB7XG4gICAgaWYgKGRlbHRhID09PSAwKSByZXR1cm4gaW5pdGlhbEFuY2hvcjtcbiAgICBkZWx0YSArPSBpbml0aWFsQW5jaG9yLm9mZnNldDtcbiAgICBsZXQgaSA9IGluaXRpYWxBbmNob3IuaW5kZXg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl92aXJ0dWFsSXRlbXM7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgd2hpbGUgKGRlbHRhIDwgMCAmJiBpID4gMCkge1xuICAgICAgICBkZWx0YSArPSB0aGlzLmdldEl0ZW1TaXplKGkgLSAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoZGVsdGEgPiAwICYmIGkgPCBpdGVtcy5sZW5ndGggJiYgdGhpcy5nZXRJdGVtU2l6ZShpKSA8PSBkZWx0YSkge1xuICAgICAgICBkZWx0YSAtPSB0aGlzLmdldEl0ZW1TaXplKGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogTWF0aC5taW4oaSwgaXRlbXMubGVuZ3RoKSxcbiAgICAgIG9mZnNldDogZGVsdGEsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBwb3NpdGlvblVuY2hhbmdlZFZpZXdzKHtcbiAgICB2aWV3SW5kZXgsXG4gICAgaXRlbUluZGV4LFxuICAgIGJhdGNoZWRVcGRhdGVzLFxuICAgIHBvc2l0aW9uLFxuICB9OiB7XG4gICAgdmlld0luZGV4OiBudW1iZXI7XG4gICAgaXRlbUluZGV4OiBudW1iZXI7XG4gICAgYmF0Y2hlZFVwZGF0ZXM6IFNldDxudW1iZXI+O1xuICAgIHBvc2l0aW9uOiBudW1iZXI7XG4gIH0pOiB7IHBvc2l0aW9uOiBudW1iZXI7IGxhc3RQb3NpdGlvbmVkSW5kZXg6IG51bWJlciB9IHtcbiAgICBsZXQgX3ZpZXdJbmRleCA9IHZpZXdJbmRleCArIDE7XG4gICAgbGV0IGluZGV4ID0gaXRlbUluZGV4ICsgMTtcbiAgICBsZXQgbGFzdFBvc2l0aW9uZWRJbmRleCA9IGl0ZW1JbmRleDtcbiAgICB3aGlsZSAoIWJhdGNoZWRVcGRhdGVzLmhhcyhfdmlld0luZGV4KSAmJiBpbmRleCA8IHRoaXMucmVuZGVyZWRSYW5nZS5lbmQpIHtcbiAgICAgIGNvbnN0IHZpcnR1YWxJdGVtID0gdGhpcy5fdmlydHVhbEl0ZW1zW2luZGV4XTtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gdmlydHVhbEl0ZW0ucG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0Vmlld1JlZihfdmlld0luZGV4KTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCh2aWV3KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnQoZWxlbWVudCwgcG9zaXRpb24pO1xuICAgICAgICB2aXJ0dWFsSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24gKz0gdmlydHVhbEl0ZW0uc2l6ZTtcbiAgICAgIGxhc3RQb3NpdGlvbmVkSW5kZXggPSBpbmRleDtcbiAgICAgIGluZGV4Kys7XG4gICAgICBfdmlld0luZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB7IHBvc2l0aW9uLCBsYXN0UG9zaXRpb25lZEluZGV4IH07XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IHRoZSBzY3JvbGwgcG9zaXRpb24gd2hlbiB0aGUgYW5jaG9yU2Nyb2xsVG9wIGRpZmZlcnMgZnJvbVxuICAgKiB0aGUgYWN0dWFsIHNjcm9sbFRvcC5cbiAgICogVHJpZ2dlciBhIHJhbmdlIHJlY2FsY3VsYXRpb24gaWYgdGhlcmUgaXMgZW1wdHkgc3BhY2VcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIG1heWJlQWRqdXN0U2Nyb2xsUG9zaXRpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYW5jaG9yU2Nyb2xsVG9wICE9PSB0aGlzLnNjcm9sbFRvcCkge1xuICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmFuY2hvclNjcm9sbFRvcCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGNhbGNBbmNob3JTY3JvbGxUb3AoKTogdm9pZCB7XG4gICAgdGhpcy5hbmNob3JTY3JvbGxUb3AgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmNob3JJdGVtLmluZGV4OyBpKyspIHtcbiAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsVG9wICs9IHRoaXMuZ2V0SXRlbVNpemUoaSk7XG4gICAgfVxuICAgIHRoaXMuYW5jaG9yU2Nyb2xsVG9wICs9IHRoaXMuYW5jaG9ySXRlbS5vZmZzZXQ7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgY2FsY0luaXRpYWxQb3NpdGlvbihzdGFydDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gb2Ygc3RhcnRpbmcgbm9kZVxuICAgIGxldCBwb3MgPSB0aGlzLmFuY2hvclNjcm9sbFRvcCAtIHRoaXMuYW5jaG9ySXRlbS5vZmZzZXQ7XG4gICAgbGV0IGkgPSB0aGlzLmFuY2hvckl0ZW0uaW5kZXg7XG4gICAgd2hpbGUgKGkgPiBzdGFydCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLmdldEl0ZW1TaXplKGkgLSAxKTtcbiAgICAgIHBvcyAtPSBpdGVtU2l6ZTtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgd2hpbGUgKGkgPCBzdGFydCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLmdldEl0ZW1TaXplKGkpO1xuICAgICAgcG9zICs9IGl0ZW1TaXplO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGdldFZpZXdSZWYoXG4gICAgaW5kZXg6IG51bWJlcixcbiAgKTogRW1iZWRkZWRWaWV3UmVmPFJ4VmlydHVhbEZvclZpZXdDb250ZXh0PFQsIFU+PiB7XG4gICAgcmV0dXJuIDxFbWJlZGRlZFZpZXdSZWY8UnhWaXJ0dWFsRm9yVmlld0NvbnRleHQ8VCwgVT4+PihcbiAgICAgIHRoaXMudmlld1JlcGVhdGVyIS52aWV3Q29udGFpbmVyLmdldChpbmRleCkhXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSB1cGRhdGVFbGVtZW50U2l6ZShcbiAgICB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8YW55PixcbiAgICBpbmRleDogbnVtYmVyLFxuICApOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5nZXRJdGVtU2l6ZShpbmRleCk7XG4gICAgY29uc3QgaXNDYWNoZWQgPSB0aGlzLl92aXJ0dWFsSXRlbXNbaW5kZXhdLmNhY2hlZDtcbiAgICBjb25zdCBzaXplID0gaXNDYWNoZWRcbiAgICAgID8gb2xkU2l6ZVxuICAgICAgOiB0aGlzLmdldEVsZW1lbnRTaXplKHRoaXMuZ2V0RWxlbWVudCh2aWV3KSk7XG4gICAgdGhpcy5fdmlydHVhbEl0ZW1zW2luZGV4XS5zaXplID0gc2l6ZTtcbiAgICB0aGlzLl92aXJ0dWFsSXRlbXNbaW5kZXhdLmNhY2hlZCA9IHRydWU7XG4gICAgcmV0dXJuIFtzaXplLCBzaXplIC0gb2xkU2l6ZV07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgZ2V0SXRlbVNpemUoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxJdGVtc1tpbmRleF0uc2l6ZSB8fCB0aGlzLnRvbWJzdG9uZVNpemU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGdldEVsZW1lbnRTaXplKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHBvc2l0aW9uRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCwgc2Nyb2xsVG9wOiBudW1iZXIpOiB2b2lkIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7c2Nyb2xsVG9wfXB4KWA7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgdXBkYXRlU2Nyb2xsRWxlbWVudENsYXNzKGZvcmNlID0gdGhpcy53aXRoU3luY1Njcm9sbGJhcik6IHZvaWQge1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB0aGlzLnZpZXdwb3J0Py5nZXRTY3JvbGxFbGVtZW50Py4oKTtcbiAgICBpZiAoXG4gICAgICAhIXNjcm9sbEVsZW1lbnQgJiZcbiAgICAgIHNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdyeC12aXJ0dWFsLXNjcm9sbC1lbGVtZW50JylcbiAgICApIHtcbiAgICAgIHNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcbiAgICAgICAgJ3J4LXZpcnR1YWwtc2Nyb2xsLWVsZW1lbnQtLXdpdGhTeW5jU2Nyb2xsYmFyJyxcbiAgICAgICAgZm9yY2UsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19