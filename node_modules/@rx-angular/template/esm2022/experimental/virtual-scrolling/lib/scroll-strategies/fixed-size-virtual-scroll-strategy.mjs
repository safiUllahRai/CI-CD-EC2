import { Directive, inject, Input, } from '@angular/core';
import { coalesceWith } from '@rx-angular/cdk/coalescing';
import { combineLatest, ReplaySubject, Subject, } from 'rxjs';
import { distinctUntilChanged, filter, map, shareReplay, startWith, switchMap, takeUntil, tap, } from 'rxjs/operators';
import { RxVirtualScrollStrategy, } from '../model';
import { calculateVisibleContainerSize, parseScrollTopBoundaries, toBoolean, unpatchedAnimationFrameTick, } from '../util';
import { DEFAULT_ITEM_SIZE, DEFAULT_RUNWAY_ITEMS, DEFAULT_RUNWAY_ITEMS_OPPOSITE, RX_VIRTUAL_SCROLL_DEFAULT_OPTIONS, } from '../virtual-scroll.config';
import * as i0 from "@angular/core";
/**
 * @Directive FixedSizeVirtualScrollStrategy
 *
 * @description
 *
 * The `FixedSizeVirtualScrollStrategy` provides a very performant way of rendering
 * items of a given size. It is comparable to \@angular/cdk `FixedSizeVirtualScrollStrategy`, but
 * with a high performant layouting technique.
 *
 * @docsCategory RxVirtualFor
 * @docsPage RxVirtualFor
 * @publicApi
 */
export class FixedSizeVirtualScrollStrategy extends RxVirtualScrollStrategy {
    defaults = inject(RX_VIRTUAL_SCROLL_DEFAULT_OPTIONS, {
        optional: true,
    });
    /**
     * @description
     * The size of the items in the virtually scrolled list
     */
    set itemSize(itemSize) {
        if (typeof itemSize === 'number') {
            this._itemSize = itemSize;
        }
    }
    get itemSize() {
        return this._itemSize;
    }
    _itemSize = DEFAULT_ITEM_SIZE;
    /**
     * @description
     * When enabled, the scroll strategy stops removing views from the viewport,
     * instead it only adds views. This setting can be changed on the fly. Views will be added in both directions
     * according to the user interactions.
     */
    appendOnly = false;
    /**
     * @description
     * The amount of items to render upfront in scroll direction
     */
    runwayItems = this.defaults?.runwayItems ?? DEFAULT_RUNWAY_ITEMS;
    /**
     * @description
     * The amount of items to render upfront in reverse scroll direction
     */
    runwayItemsOpposite = this.defaults?.runwayItemsOpposite ?? DEFAULT_RUNWAY_ITEMS_OPPOSITE;
    /**
     * @description
     * If this flag is true, the virtual scroll strategy maintains the scrolled item when new data
     * is prepended to the list. This is very useful when implementing a reversed infinite scroller, that prepends
     * data instead of appending it
     */
    keepScrolledIndexOnPrepend = false;
    /** @internal */
    runwayStateChanged$ = new Subject();
    viewport = null;
    viewRepeater = null;
    _scrolledIndex$ = new ReplaySubject(1);
    scrolledIndex$ = this._scrolledIndex$.pipe(distinctUntilChanged());
    _scrolledIndex = 0;
    set scrolledIndex(index) {
        this._scrolledIndex = index;
        this._scrolledIndex$.next(index);
    }
    get scrolledIndex() {
        return this._scrolledIndex;
    }
    _contentSize$ = new ReplaySubject(1);
    contentSize$ = this._contentSize$.asObservable();
    _contentSize = 0;
    set contentSize(size) {
        this._contentSize = size;
        this._contentSize$.next(size);
    }
    _renderedRange$ = new ReplaySubject(1);
    renderedRange$ = this._renderedRange$.asObservable();
    _renderedRange = { start: 0, end: 0 };
    set renderedRange(range) {
        this._renderedRange = range;
        this._renderedRange$.next(range);
    }
    get renderedRange() {
        return this._renderedRange;
    }
    scrollTop = 0;
    /** @internal */
    scrollTopWithOutOffset = 0;
    /** @internal */
    scrollTopAfterOffset = 0;
    /** @internal */
    viewportOffset = 0;
    /** @internal */
    containerSize = 0;
    direction = 'down';
    detached$ = new Subject();
    /** @internal */
    ngOnChanges(changes) {
        if ((changes['runwayItemsOpposite'] &&
            !changes['runwayItemsOpposite'].firstChange) ||
            (changes['runwayItems'] && !changes['runwayItems'].firstChange)) {
            this.runwayStateChanged$.next();
        }
    }
    ngOnDestroy() {
        this.detach();
    }
    attach(viewport, viewRepeater) {
        this.viewport = viewport;
        this.viewRepeater = viewRepeater;
        this.calcRenderedRange();
        this.positionElements();
    }
    detach() {
        this.viewport = null;
        this.viewRepeater = null;
        this.detached$.next();
    }
    positionElements() {
        this.viewRepeater.renderingStart$.pipe(switchMap(() => {
            const start = this.renderedRange.start;
            return this.viewRepeater.viewRendered$.pipe(tap(({ view, index, item }) => {
                this._setViewPosition(view, (index + start) * this.itemSize);
                this.viewRenderCallback.next({
                    view,
                    item,
                    index,
                });
            }));
        }), this.untilDetached$()).subscribe();
    }
    calcRenderedRange() {
        const valueArray$ = this.viewRepeater.values$.pipe(map((values) => Array.isArray(values)
            ? values
            : values != null
                ? Array.from(values)
                : []), shareReplay({ bufferSize: 1, refCount: true }));
        /*
         * when keepScrolledIndexOnPrepend is active, we need to listen to data changes and figure out what was appended
         * before the last scrolledToItem
         */
        let valueCache = {};
        valueArray$
            .pipe(
        // TODO: this might cause issues when turning on/off
        filter(() => this.keepScrolledIndexOnPrepend), this.untilDetached$())
            .subscribe((valueArray) => {
            const trackBy = this.viewRepeater._trackBy;
            let scrollTo = this.scrolledIndex;
            const dataLength = valueArray.length;
            const oldDataLength = Object.keys(valueCache).length;
            if (oldDataLength > 0) {
                let i = 0;
                // check for each item from the last known scrolledIndex if it's an insert
                for (i; i <= scrollTo && i < dataLength; i++) {
                    // item is not in the valueCache, so it was added
                    if (!valueCache[trackBy(i, valueArray[i])]) {
                        scrollTo++;
                    }
                }
            }
            valueCache = {};
            valueArray.forEach((v, i) => (valueCache[trackBy(i, v)] = v));
            if (scrollTo !== this.scrolledIndex) {
                this.scrollToIndex(scrollTo);
            }
        });
        const dataLengthChanged$ = valueArray$.pipe(map((values) => values.length), distinctUntilChanged(), tap((dataLength) => (this.contentSize = dataLength * this.itemSize)));
        const onScroll$ = this.viewport.elementScrolled$.pipe(coalesceWith(unpatchedAnimationFrameTick()), startWith(void 0), tap(() => {
            this.viewportOffset = this.viewport.measureOffset();
            const { scrollTop, scrollTopWithOutOffset, scrollTopAfterOffset } = parseScrollTopBoundaries(this.viewport.getScrollTop(), this.viewportOffset, this._contentSize, this.containerSize);
            this.direction =
                scrollTopWithOutOffset > this.scrollTopWithOutOffset ? 'down' : 'up';
            this.scrollTopWithOutOffset = scrollTopWithOutOffset;
            this.scrollTopAfterOffset = scrollTopAfterOffset;
            this.scrollTop = scrollTop;
        }));
        combineLatest([
            dataLengthChanged$,
            this.viewport.containerRect$.pipe(map(({ height }) => {
                this.containerSize = height;
                return height;
            }), distinctUntilChanged()),
            onScroll$,
            this.runwayStateChanged$.pipe(startWith(void 0)),
        ])
            .pipe(map(([length]) => {
            const containerSize = calculateVisibleContainerSize(this.containerSize, this.scrollTopWithOutOffset, this.scrollTopAfterOffset);
            const range = { start: 0, end: 0 };
            if (this.direction === 'up') {
                range.start = Math.floor(Math.max(0, this.scrollTop - this.runwayItems * this.itemSize) /
                    this.itemSize);
                range.end = Math.min(length, Math.ceil((this.scrollTop +
                    containerSize +
                    this.runwayItemsOpposite * this.itemSize) /
                    this.itemSize));
            }
            else {
                range.start = Math.floor(Math.max(0, this.scrollTop - this.runwayItemsOpposite * this.itemSize) / this.itemSize);
                range.end = Math.min(length, Math.ceil((this.scrollTop +
                    containerSize +
                    this.runwayItems * this.itemSize) /
                    this.itemSize));
            }
            if (this.appendOnly) {
                range.start = Math.min(this._renderedRange.start, range.start);
                range.end = Math.max(this._renderedRange.end, range.end);
            }
            this.scrolledIndex = Math.floor(this.scrollTop / this.itemSize);
            return range;
        }), distinctUntilChanged(({ start: prevStart, end: prevEnd }, { start, end }) => prevStart === start && prevEnd === end), this.untilDetached$())
            .subscribe((range) => (this.renderedRange = range));
    }
    scrollToIndex(index, behavior) {
        const scrollTop = this.itemSize * index;
        this.viewport.scrollTo(this.viewportOffset + scrollTop, behavior);
    }
    untilDetached$() {
        return (o$) => o$.pipe(takeUntil(this.detached$));
    }
    _setViewPosition(view, scrollTop) {
        const element = this.getElement(view);
        element.style.position = 'absolute';
        element.style.transform = `translateY(${scrollTop}px)`;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: FixedSizeVirtualScrollStrategy, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.0.1", type: FixedSizeVirtualScrollStrategy, isStandalone: true, selector: "rx-virtual-scroll-viewport[itemSize]", inputs: { itemSize: "itemSize", appendOnly: ["appendOnly", "appendOnly", toBoolean], runwayItems: "runwayItems", runwayItemsOpposite: "runwayItemsOpposite", keepScrolledIndexOnPrepend: ["keepScrolledIndexOnPrepend", "keepScrolledIndexOnPrepend", toBoolean] }, providers: [
            {
                provide: RxVirtualScrollStrategy,
                useExisting: FixedSizeVirtualScrollStrategy,
            },
        ], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: FixedSizeVirtualScrollStrategy, decorators: [{
            type: Directive,
            args: [{
                    selector: 'rx-virtual-scroll-viewport[itemSize]',
                    providers: [
                        {
                            provide: RxVirtualScrollStrategy,
                            useExisting: FixedSizeVirtualScrollStrategy,
                        },
                    ],
                    standalone: true,
                }]
        }], propDecorators: { itemSize: [{
                type: Input
            }], appendOnly: [{
                type: Input,
                args: [{ transform: toBoolean }]
            }], runwayItems: [{
                type: Input
            }], runwayItemsOpposite: [{
                type: Input
            }], keepScrolledIndexOnPrepend: [{
                type: Input,
                args: [{ transform: toBoolean }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZml4ZWQtc2l6ZS12aXJ0dWFsLXNjcm9sbC1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvdGVtcGxhdGUvZXhwZXJpbWVudGFsL3ZpcnR1YWwtc2Nyb2xsaW5nL3NyYy9saWIvc2Nyb2xsLXN0cmF0ZWdpZXMvZml4ZWQtc2l6ZS12aXJ0dWFsLXNjcm9sbC1zdHJhdGVneS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUVULE1BQU0sRUFDTixLQUFLLEdBS04sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzFELE9BQU8sRUFDTCxhQUFhLEVBRWIsYUFBYSxFQUNiLE9BQU8sR0FDUixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsTUFBTSxFQUNOLEdBQUcsRUFDSCxXQUFXLEVBQ1gsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsR0FBRyxHQUNKLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUdMLHVCQUF1QixHQUd4QixNQUFNLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQ0wsNkJBQTZCLEVBQzdCLHdCQUF3QixFQUN4QixTQUFTLEVBQ1QsMkJBQTJCLEdBQzVCLE1BQU0sU0FBUyxDQUFDO0FBQ2pCLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsb0JBQW9CLEVBQ3BCLDZCQUE2QixFQUM3QixpQ0FBaUMsR0FDbEMsTUFBTSwwQkFBMEIsQ0FBQzs7QUFFbEM7Ozs7Ozs7Ozs7OztHQVlHO0FBV0gsTUFBTSxPQUFPLDhCQUlYLFNBQVEsdUJBQTZCO0lBR3BCLFFBQVEsR0FBSSxNQUFNLENBQUMsaUNBQWlDLEVBQUU7UUFDckUsUUFBUSxFQUFFLElBQUk7S0FDZixDQUFDLENBQUM7SUFFSDs7O09BR0c7SUFDSCxJQUNJLFFBQVEsQ0FBQyxRQUFn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LE9BQU8sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTyxnQkFBZ0IsQ0FDdEIsSUFBb0QsRUFDcEQsU0FBaUI7UUFFakIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7UUFDcEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsY0FBYyxTQUFTLEtBQUssQ0FBQztJQUN6RCxDQUFDOzBIQW5UVSw4QkFBOEI7OEdBQTlCLDhCQUE4QixpSkFpQ3JCLFNBQVMsb0tBcUJULFNBQVMsZ0JBOURsQjtZQUNUO2dCQUNFLE9BQU8sRUFBRSx1QkFBdUI7Z0JBQ2hDLFdBQVcsRUFBRSw4QkFBOEI7YUFDNUM7U0FDRjs7MkZBR1UsOEJBQThCO2tCQVYxQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxzQ0FBc0M7b0JBQ2hELFNBQVMsRUFBRTt3QkFDVDs0QkFDRSxPQUFPLEVBQUUsdUJBQXVCOzRCQUNoQyxXQUFXLGdDQUFnQzt5QkFDNUM7cUJBQ0Y7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzhCQWlCSyxRQUFRO3NCQURYLEtBQUs7Z0JBa0IyQixVQUFVO3NCQUExQyxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtnQkFNdEIsV0FBVztzQkFBbkIsS0FBSztnQkFNRyxtQkFBbUI7c0JBQTNCLEtBQUs7Z0JBUzJCLDBCQUEwQjtzQkFBMUQsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgaW5qZWN0LFxuICBJbnB1dCxcbiAgTmdJdGVyYWJsZSxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIFNpbXBsZUNoYW5nZXMsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29hbGVzY2VXaXRoIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL2NvYWxlc2NpbmcnO1xuaW1wb3J0IHtcbiAgY29tYmluZUxhdGVzdCxcbiAgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLFxuICBSZXBsYXlTdWJqZWN0LFxuICBTdWJqZWN0LFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgc2hhcmVSZXBsYXksXG4gIHN0YXJ0V2l0aCxcbiAgc3dpdGNoTWFwLFxuICB0YWtlVW50aWwsXG4gIHRhcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgTGlzdFJhbmdlLFxuICBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dCxcbiAgUnhWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3ksXG4gIFJ4VmlydHVhbFNjcm9sbFZpZXdwb3J0LFxuICBSeFZpcnR1YWxWaWV3UmVwZWF0ZXIsXG59IGZyb20gJy4uL21vZGVsJztcbmltcG9ydCB7XG4gIGNhbGN1bGF0ZVZpc2libGVDb250YWluZXJTaXplLFxuICBwYXJzZVNjcm9sbFRvcEJvdW5kYXJpZXMsXG4gIHRvQm9vbGVhbixcbiAgdW5wYXRjaGVkQW5pbWF0aW9uRnJhbWVUaWNrLFxufSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7XG4gIERFRkFVTFRfSVRFTV9TSVpFLFxuICBERUZBVUxUX1JVTldBWV9JVEVNUyxcbiAgREVGQVVMVF9SVU5XQVlfSVRFTVNfT1BQT1NJVEUsXG4gIFJYX1ZJUlRVQUxfU0NST0xMX0RFRkFVTFRfT1BUSU9OUyxcbn0gZnJvbSAnLi4vdmlydHVhbC1zY3JvbGwuY29uZmlnJztcblxuLyoqXG4gKiBARGlyZWN0aXZlIEZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoZSBgRml4ZWRTaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5YCBwcm92aWRlcyBhIHZlcnkgcGVyZm9ybWFudCB3YXkgb2YgcmVuZGVyaW5nXG4gKiBpdGVtcyBvZiBhIGdpdmVuIHNpemUuIEl0IGlzIGNvbXBhcmFibGUgdG8gXFxAYW5ndWxhci9jZGsgYEZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAsIGJ1dFxuICogd2l0aCBhIGhpZ2ggcGVyZm9ybWFudCBsYXlvdXRpbmcgdGVjaG5pcXVlLlxuICpcbiAqIEBkb2NzQ2F0ZWdvcnkgUnhWaXJ0dWFsRm9yXG4gKiBAZG9jc1BhZ2UgUnhWaXJ0dWFsRm9yXG4gKiBAcHVibGljQXBpXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ3J4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0W2l0ZW1TaXplXScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IFJ4VmlydHVhbFNjcm9sbFN0cmF0ZWd5LFxuICAgICAgdXNlRXhpc3Rpbmc6IEZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneSxcbiAgICB9LFxuICBdLFxuICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3k8XG4gICAgVCxcbiAgICBVIGV4dGVuZHMgTmdJdGVyYWJsZTxUPiA9IE5nSXRlcmFibGU8VD4sXG4gID5cbiAgZXh0ZW5kcyBSeFZpcnR1YWxTY3JvbGxTdHJhdGVneTxULCBVPlxuICBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95XG57XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdHM/ID0gaW5qZWN0KFJYX1ZJUlRVQUxfU0NST0xMX0RFRkFVTFRfT1BUSU9OUywge1xuICAgIG9wdGlvbmFsOiB0cnVlLFxuICB9KTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBzaXplIG9mIHRoZSBpdGVtcyBpbiB0aGUgdmlydHVhbGx5IHNjcm9sbGVkIGxpc3RcbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBpdGVtU2l6ZShpdGVtU2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX2l0ZW1TaXplID0gaXRlbVNpemU7XG4gICAgfVxuICB9XG4gIGdldCBpdGVtU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbVNpemU7XG4gIH1cblxuICBwcml2YXRlIF9pdGVtU2l6ZSA9IERFRkFVTFRfSVRFTV9TSVpFO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogV2hlbiBlbmFibGVkLCB0aGUgc2Nyb2xsIHN0cmF0ZWd5IHN0b3BzIHJlbW92aW5nIHZpZXdzIGZyb20gdGhlIHZpZXdwb3J0LFxuICAgKiBpbnN0ZWFkIGl0IG9ubHkgYWRkcyB2aWV3cy4gVGhpcyBzZXR0aW5nIGNhbiBiZSBjaGFuZ2VkIG9uIHRoZSBmbHkuIFZpZXdzIHdpbGwgYmUgYWRkZWQgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAqIGFjY29yZGluZyB0byB0aGUgdXNlciBpbnRlcmFjdGlvbnMuXG4gICAqL1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IHRvQm9vbGVhbiB9KSBhcHBlbmRPbmx5ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgYW1vdW50IG9mIGl0ZW1zIHRvIHJlbmRlciB1cGZyb250IGluIHNjcm9sbCBkaXJlY3Rpb25cbiAgICovXG4gIEBJbnB1dCgpIHJ1bndheUl0ZW1zID0gdGhpcy5kZWZhdWx0cz8ucnVud2F5SXRlbXMgPz8gREVGQVVMVF9SVU5XQVlfSVRFTVM7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgYW1vdW50IG9mIGl0ZW1zIHRvIHJlbmRlciB1cGZyb250IGluIHJldmVyc2Ugc2Nyb2xsIGRpcmVjdGlvblxuICAgKi9cbiAgQElucHV0KCkgcnVud2F5SXRlbXNPcHBvc2l0ZSA9XG4gICAgdGhpcy5kZWZhdWx0cz8ucnVud2F5SXRlbXNPcHBvc2l0ZSA/PyBERUZBVUxUX1JVTldBWV9JVEVNU19PUFBPU0lURTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIElmIHRoaXMgZmxhZyBpcyB0cnVlLCB0aGUgdmlydHVhbCBzY3JvbGwgc3RyYXRlZ3kgbWFpbnRhaW5zIHRoZSBzY3JvbGxlZCBpdGVtIHdoZW4gbmV3IGRhdGFcbiAgICogaXMgcHJlcGVuZGVkIHRvIHRoZSBsaXN0LiBUaGlzIGlzIHZlcnkgdXNlZnVsIHdoZW4gaW1wbGVtZW50aW5nIGEgcmV2ZXJzZWQgaW5maW5pdGUgc2Nyb2xsZXIsIHRoYXQgcHJlcGVuZHNcbiAgICogZGF0YSBpbnN0ZWFkIG9mIGFwcGVuZGluZyBpdFxuICAgKi9cbiAgQElucHV0KHsgdHJhbnNmb3JtOiB0b0Jvb2xlYW4gfSkga2VlcFNjcm9sbGVkSW5kZXhPblByZXBlbmQgPSBmYWxzZTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcnVud2F5U3RhdGVDaGFuZ2VkJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgcHJpdmF0ZSB2aWV3cG9ydDogUnhWaXJ0dWFsU2Nyb2xsVmlld3BvcnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB2aWV3UmVwZWF0ZXI6IFJ4VmlydHVhbFZpZXdSZXBlYXRlcjxULCBVPiB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX3Njcm9sbGVkSW5kZXgkID0gbmV3IFJlcGxheVN1YmplY3Q8bnVtYmVyPigxKTtcbiAgcmVhZG9ubHkgc2Nyb2xsZWRJbmRleCQgPSB0aGlzLl9zY3JvbGxlZEluZGV4JC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICBwcml2YXRlIF9zY3JvbGxlZEluZGV4ID0gMDtcbiAgcHJpdmF0ZSBzZXQgc2Nyb2xsZWRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fc2Nyb2xsZWRJbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX3Njcm9sbGVkSW5kZXgkLm5leHQoaW5kZXgpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgc2Nyb2xsZWRJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxlZEluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfY29udGVudFNpemUkID0gbmV3IFJlcGxheVN1YmplY3Q8bnVtYmVyPigxKTtcbiAgcmVhZG9ubHkgY29udGVudFNpemUkID0gdGhpcy5fY29udGVudFNpemUkLmFzT2JzZXJ2YWJsZSgpO1xuICBwcml2YXRlIF9jb250ZW50U2l6ZSA9IDA7XG4gIHByaXZhdGUgc2V0IGNvbnRlbnRTaXplKHNpemU6IG51bWJlcikge1xuICAgIHRoaXMuX2NvbnRlbnRTaXplID0gc2l6ZTtcbiAgICB0aGlzLl9jb250ZW50U2l6ZSQubmV4dChzaXplKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgX3JlbmRlcmVkUmFuZ2UkID0gbmV3IFJlcGxheVN1YmplY3Q8TGlzdFJhbmdlPigxKTtcbiAgcmVuZGVyZWRSYW5nZSQgPSB0aGlzLl9yZW5kZXJlZFJhbmdlJC5hc09ic2VydmFibGUoKTtcbiAgcHJpdmF0ZSBfcmVuZGVyZWRSYW5nZTogTGlzdFJhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG4gIHByaXZhdGUgc2V0IHJlbmRlcmVkUmFuZ2UocmFuZ2U6IExpc3RSYW5nZSkge1xuICAgIHRoaXMuX3JlbmRlcmVkUmFuZ2UgPSByYW5nZTtcbiAgICB0aGlzLl9yZW5kZXJlZFJhbmdlJC5uZXh0KHJhbmdlKTtcbiAgfVxuICBwcml2YXRlIGdldCByZW5kZXJlZFJhbmdlKCk6IExpc3RSYW5nZSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkUmFuZ2U7XG4gIH1cblxuICBwcml2YXRlIHNjcm9sbFRvcCA9IDA7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzY3JvbGxUb3BXaXRoT3V0T2Zmc2V0ID0gMDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHNjcm9sbFRvcEFmdGVyT2Zmc2V0ID0gMDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHZpZXdwb3J0T2Zmc2V0ID0gMDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGNvbnRhaW5lclNpemUgPSAwO1xuICBwcml2YXRlIGRpcmVjdGlvbjogJ3VwJyB8ICdkb3duJyA9ICdkb3duJztcblxuICBwcml2YXRlIHJlYWRvbmx5IGRldGFjaGVkJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKFxuICAgICAgKGNoYW5nZXNbJ3J1bndheUl0ZW1zT3Bwb3NpdGUnXSAmJlxuICAgICAgICAhY2hhbmdlc1sncnVud2F5SXRlbXNPcHBvc2l0ZSddLmZpcnN0Q2hhbmdlKSB8fFxuICAgICAgKGNoYW5nZXNbJ3J1bndheUl0ZW1zJ10gJiYgIWNoYW5nZXNbJ3J1bndheUl0ZW1zJ10uZmlyc3RDaGFuZ2UpXG4gICAgKSB7XG4gICAgICB0aGlzLnJ1bndheVN0YXRlQ2hhbmdlZCQubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gIH1cblxuICBhdHRhY2goXG4gICAgdmlld3BvcnQ6IFJ4VmlydHVhbFNjcm9sbFZpZXdwb3J0LFxuICAgIHZpZXdSZXBlYXRlcjogUnhWaXJ0dWFsVmlld1JlcGVhdGVyPFQsIFU+LFxuICApOiB2b2lkIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy52aWV3UmVwZWF0ZXIgPSB2aWV3UmVwZWF0ZXI7XG4gICAgdGhpcy5jYWxjUmVuZGVyZWRSYW5nZSgpO1xuICAgIHRoaXMucG9zaXRpb25FbGVtZW50cygpO1xuICB9XG5cbiAgZGV0YWNoKCk6IHZvaWQge1xuICAgIHRoaXMudmlld3BvcnQgPSBudWxsO1xuICAgIHRoaXMudmlld1JlcGVhdGVyID0gbnVsbDtcbiAgICB0aGlzLmRldGFjaGVkJC5uZXh0KCk7XG4gIH1cblxuICBwcml2YXRlIHBvc2l0aW9uRWxlbWVudHMoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3UmVwZWF0ZXIhLnJlbmRlcmluZ1N0YXJ0JC5waXBlKFxuICAgICAgc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnJlbmRlcmVkUmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdSZXBlYXRlciEudmlld1JlbmRlcmVkJC5waXBlKFxuICAgICAgICAgIHRhcCgoeyB2aWV3LCBpbmRleCwgaXRlbSB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRWaWV3UG9zaXRpb24odmlldywgKGluZGV4ICsgc3RhcnQpICogdGhpcy5pdGVtU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnZpZXdSZW5kZXJDYWxsYmFjay5uZXh0KHtcbiAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgICAgdGhpcy51bnRpbERldGFjaGVkJCgpLFxuICAgICkuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBwcml2YXRlIGNhbGNSZW5kZXJlZFJhbmdlKCk6IHZvaWQge1xuICAgIGNvbnN0IHZhbHVlQXJyYXkkID0gdGhpcy52aWV3UmVwZWF0ZXIhLnZhbHVlcyQucGlwZShcbiAgICAgIG1hcCgodmFsdWVzKSA9PlxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlcylcbiAgICAgICAgICA/IHZhbHVlc1xuICAgICAgICAgIDogdmFsdWVzICE9IG51bGxcbiAgICAgICAgICAgID8gQXJyYXkuZnJvbSh2YWx1ZXMpXG4gICAgICAgICAgICA6IFtdLFxuICAgICAgKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSksXG4gICAgKTtcbiAgICAvKlxuICAgICAqIHdoZW4ga2VlcFNjcm9sbGVkSW5kZXhPblByZXBlbmQgaXMgYWN0aXZlLCB3ZSBuZWVkIHRvIGxpc3RlbiB0byBkYXRhIGNoYW5nZXMgYW5kIGZpZ3VyZSBvdXQgd2hhdCB3YXMgYXBwZW5kZWRcbiAgICAgKiBiZWZvcmUgdGhlIGxhc3Qgc2Nyb2xsZWRUb0l0ZW1cbiAgICAgKi9cbiAgICBsZXQgdmFsdWVDYWNoZTogUmVjb3JkPGFueSwgVD4gPSB7fTtcbiAgICB2YWx1ZUFycmF5JFxuICAgICAgLnBpcGUoXG4gICAgICAgIC8vIFRPRE86IHRoaXMgbWlnaHQgY2F1c2UgaXNzdWVzIHdoZW4gdHVybmluZyBvbi9vZmZcbiAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMua2VlcFNjcm9sbGVkSW5kZXhPblByZXBlbmQpLFxuICAgICAgICB0aGlzLnVudGlsRGV0YWNoZWQkKCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCh2YWx1ZUFycmF5KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNrQnkgPSB0aGlzLnZpZXdSZXBlYXRlciEuX3RyYWNrQnk7XG4gICAgICAgIGxldCBzY3JvbGxUbyA9IHRoaXMuc2Nyb2xsZWRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IHZhbHVlQXJyYXkubGVuZ3RoO1xuICAgICAgICBjb25zdCBvbGREYXRhTGVuZ3RoID0gT2JqZWN0LmtleXModmFsdWVDYWNoZSkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChvbGREYXRhTGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAvLyBjaGVjayBmb3IgZWFjaCBpdGVtIGZyb20gdGhlIGxhc3Qga25vd24gc2Nyb2xsZWRJbmRleCBpZiBpdCdzIGFuIGluc2VydFxuICAgICAgICAgIGZvciAoaTsgaSA8PSBzY3JvbGxUbyAmJiBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIG5vdCBpbiB0aGUgdmFsdWVDYWNoZSwgc28gaXQgd2FzIGFkZGVkXG4gICAgICAgICAgICBpZiAoIXZhbHVlQ2FjaGVbdHJhY2tCeShpLCB2YWx1ZUFycmF5W2ldKV0pIHtcbiAgICAgICAgICAgICAgc2Nyb2xsVG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVDYWNoZSA9IHt9O1xuICAgICAgICB2YWx1ZUFycmF5LmZvckVhY2goKHYsIGkpID0+ICh2YWx1ZUNhY2hlW3RyYWNrQnkoaSwgdildID0gdikpO1xuICAgICAgICBpZiAoc2Nyb2xsVG8gIT09IHRoaXMuc2Nyb2xsZWRJbmRleCkge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChzY3JvbGxUbyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGNvbnN0IGRhdGFMZW5ndGhDaGFuZ2VkJCA9IHZhbHVlQXJyYXkkLnBpcGUoXG4gICAgICBtYXAoKHZhbHVlcykgPT4gdmFsdWVzLmxlbmd0aCksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgdGFwKChkYXRhTGVuZ3RoKSA9PiAodGhpcy5jb250ZW50U2l6ZSA9IGRhdGFMZW5ndGggKiB0aGlzLml0ZW1TaXplKSksXG4gICAgKTtcbiAgICBjb25zdCBvblNjcm9sbCQgPSB0aGlzLnZpZXdwb3J0IS5lbGVtZW50U2Nyb2xsZWQkLnBpcGUoXG4gICAgICBjb2FsZXNjZVdpdGgodW5wYXRjaGVkQW5pbWF0aW9uRnJhbWVUaWNrKCkpLFxuICAgICAgc3RhcnRXaXRoKHZvaWQgMCksXG4gICAgICB0YXAoKCkgPT4ge1xuICAgICAgICB0aGlzLnZpZXdwb3J0T2Zmc2V0ID0gdGhpcy52aWV3cG9ydCEubWVhc3VyZU9mZnNldCgpO1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsVG9wV2l0aE91dE9mZnNldCwgc2Nyb2xsVG9wQWZ0ZXJPZmZzZXQgfSA9XG4gICAgICAgICAgcGFyc2VTY3JvbGxUb3BCb3VuZGFyaWVzKFxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCEuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0T2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fY29udGVudFNpemUsXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUsXG4gICAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPVxuICAgICAgICAgIHNjcm9sbFRvcFdpdGhPdXRPZmZzZXQgPiB0aGlzLnNjcm9sbFRvcFdpdGhPdXRPZmZzZXQgPyAnZG93bicgOiAndXAnO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcFdpdGhPdXRPZmZzZXQgPSBzY3JvbGxUb3BXaXRoT3V0T2Zmc2V0O1xuICAgICAgICB0aGlzLnNjcm9sbFRvcEFmdGVyT2Zmc2V0ID0gc2Nyb2xsVG9wQWZ0ZXJPZmZzZXQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgfSksXG4gICAgKTtcbiAgICBjb21iaW5lTGF0ZXN0KFtcbiAgICAgIGRhdGFMZW5ndGhDaGFuZ2VkJCxcbiAgICAgIHRoaXMudmlld3BvcnQhLmNvbnRhaW5lclJlY3QkLnBpcGUoXG4gICAgICAgIG1hcCgoeyBoZWlnaHQgfSkgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IGhlaWdodDtcbiAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICksXG4gICAgICBvblNjcm9sbCQsXG4gICAgICB0aGlzLnJ1bndheVN0YXRlQ2hhbmdlZCQucGlwZShzdGFydFdpdGgodm9pZCAwKSksXG4gICAgXSlcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoKFtsZW5ndGhdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGNhbGN1bGF0ZVZpc2libGVDb250YWluZXJTaXplKFxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplLFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BXaXRoT3V0T2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BBZnRlck9mZnNldCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHJhbmdlOiBMaXN0UmFuZ2UgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy5zY3JvbGxUb3AgLSB0aGlzLnJ1bndheUl0ZW1zICogdGhpcy5pdGVtU2l6ZSkgL1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbVNpemUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmFuZ2UuZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICh0aGlzLnNjcm9sbFRvcCArXG4gICAgICAgICAgICAgICAgICBjb250YWluZXJTaXplICtcbiAgICAgICAgICAgICAgICAgIHRoaXMucnVud2F5SXRlbXNPcHBvc2l0ZSAqIHRoaXMuaXRlbVNpemUpIC9cbiAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbVNpemUsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZS5zdGFydCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgLSB0aGlzLnJ1bndheUl0ZW1zT3Bwb3NpdGUgKiB0aGlzLml0ZW1TaXplLFxuICAgICAgICAgICAgICApIC8gdGhpcy5pdGVtU2l6ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByYW5nZS5lbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgKHRoaXMuc2Nyb2xsVG9wICtcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclNpemUgK1xuICAgICAgICAgICAgICAgICAgdGhpcy5ydW53YXlJdGVtcyAqIHRoaXMuaXRlbVNpemUpIC9cbiAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbVNpemUsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRPbmx5KSB7XG4gICAgICAgICAgICByYW5nZS5zdGFydCA9IE1hdGgubWluKHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQsIHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHJhbmdlLmVuZCA9IE1hdGgubWF4KHRoaXMuX3JlbmRlcmVkUmFuZ2UuZW5kLCByYW5nZS5lbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNjcm9sbGVkSW5kZXggPSBNYXRoLmZsb29yKHRoaXMuc2Nyb2xsVG9wIC8gdGhpcy5pdGVtU2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoXG4gICAgICAgICAgKHsgc3RhcnQ6IHByZXZTdGFydCwgZW5kOiBwcmV2RW5kIH0sIHsgc3RhcnQsIGVuZCB9KSA9PlxuICAgICAgICAgICAgcHJldlN0YXJ0ID09PSBzdGFydCAmJiBwcmV2RW5kID09PSBlbmQsXG4gICAgICAgICksXG4gICAgICAgIHRoaXMudW50aWxEZXRhY2hlZCQoKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKHJhbmdlKSA9PiAodGhpcy5yZW5kZXJlZFJhbmdlID0gcmFuZ2UpKTtcbiAgfVxuXG4gIHNjcm9sbFRvSW5kZXgoaW5kZXg6IG51bWJlciwgYmVoYXZpb3I/OiBTY3JvbGxCZWhhdmlvcik6IHZvaWQge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuaXRlbVNpemUgKiBpbmRleDtcbiAgICB0aGlzLnZpZXdwb3J0IS5zY3JvbGxUbyh0aGlzLnZpZXdwb3J0T2Zmc2V0ICsgc2Nyb2xsVG9wLCBiZWhhdmlvcik7XG4gIH1cblxuICBwcml2YXRlIHVudGlsRGV0YWNoZWQkPEE+KCk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxBPiB7XG4gICAgcmV0dXJuIChvJCkgPT4gbyQucGlwZSh0YWtlVW50aWwodGhpcy5kZXRhY2hlZCQpKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NldFZpZXdQb3NpdGlvbihcbiAgICB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8UnhWaXJ0dWFsRm9yVmlld0NvbnRleHQ8VCwgVT4+LFxuICAgIHNjcm9sbFRvcDogbnVtYmVyLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHZpZXcpO1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHtzY3JvbGxUb3B9cHgpYDtcbiAgfVxufVxuIl19