import { ChangeDetectorRef, Directive, ErrorHandler, inject, Injector, Input, isSignal, IterableDiffers, NgZone, TemplateRef, ViewContainerRef, } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { coerceObservableWith } from '@rx-angular/cdk/coercing';
import { onStrategy, RxStrategyProvider, strategyHandling, } from '@rx-angular/cdk/render-strategies';
import { Promise } from '@rx-angular/cdk/zone-less/browser';
import { combineLatest, concat, isObservable, NEVER, of, ReplaySubject, Subject, } from 'rxjs';
import { catchError, distinctUntilChanged, ignoreElements, map, shareReplay, switchAll, switchMap, take, takeUntil, tap, } from 'rxjs/operators';
import { RxVirtualForViewContext, RxVirtualScrollStrategy, RxVirtualViewRepeater, } from './model';
import { createVirtualListTemplateManager, } from './virtual-list-template-manager';
import { DEFAULT_TEMPLATE_CACHE_SIZE, RX_VIRTUAL_SCROLL_DEFAULT_OPTIONS, } from './virtual-scroll.config';
import * as i0 from "@angular/core";
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;
/**
 * @Directive RxVirtualFor
 *
 * @description
 *
 * The `*rxVirtualFor` structural directive provides a convenient and performant
 * way for rendering huge lists of items. It brings all the benefits `rxFor` does,
 * and implements virtual rendering.
 *
 * Instead of rendering every item provided, rxVirtualFor only renders what is
 * currently visible to the user, thus providing excellent runtime performance
 * for huge sets of data.
 *
 * The technique to render items is comparable to the on used by twitter and
 * explained in very much detail by @DasSurma in his blog post about the [complexities
 * of infinite scrollers](https://developer.chrome.com/blog/infinite-scroller/).
 *
 * "Each recycling of a DOM element would normally relayout the entire runway which
 * would bring us well below our target of 60 frames per second.
 * To avoid this, we are taking the burden of layout onto ourselves and use
 * absolutely positioned elements with transforms." (@DasSurma)
 *
 * ## API
 * The API is a combination of \@rx-angular/template/for &
 *  \@angular/cdk `*cdkVirtualFor`.
 * * trackBy: `(index: number, item: T) => any` | `keyof T`
 * * strategy: `string` | `Observable<string>`
 * * parent: `boolean`;
 * * renderCallback: `Subject<T[]>`
 * * viewCache: `number`
 * * (Injected) scrollStrategy: `RxVirtualScrollStrategy<T, U>`
 * * provides itself as RxVirtualViewRepeater for RxVirtualViewPortComponent to operate
 *
 * ## Features
 * * Push based architecture
 * * Comprehensive set of context variables
 * * Opt-out of `NgZone` with `patchZone`
 * * Notify when rendering of child templates is finished (`renderCallback`)
 * * Super efficient layouting with css transformations
 * * Define a viewCache in order to re-use views instead of re-creating them
 * * Configurable RxVirtualScrollStrategy<T, U> providing the core logic to calculate the viewRange and position DOM
 * Nodes
 *
 * ### Context Variables
 *
 * The following context variables are available for each template:
 *
 * - $implicit: `T` // the default variable accessed by `let val`
 * - item$: `Observable<T>` // the same value as $implicit, but as `Observable`
 * - index: `number` // current index of the item
 * - count: `number` // count of all items in the list
 * - first: `boolean` // true if the item is the first in the list
 * - last: `boolean` // true if the item is the last in the list
 * - even: `boolean` // true if the item has on even index (index % 2 === 0)
 * - odd: `boolean` // the opposite of even
 * - index$: `Observable<number>` // index as `Observable`
 * - count$: `Observable<number>` // count as `Observable`
 * - first$: `Observable<boolean>` // first as `Observable`
 * - last$: `Observable<boolean>` // last as `Observable`
 * - even$: `Observable<boolean>` // even as `Observable`
 * - odd$: `Observable<boolean>` // odd as `Observable`
 * - select: `(keys: (keyof T)[], distinctByMap) => Observable<Partial<T>>`
 * // returns a selection function which
 * // accepts an array of properties to pluck out of every list item. The function returns the selected properties of
 * // the current list item as distinct `Observable` key-value-pair. See the example below:
 *
 * This example showcases the `select` view-context function used for deeply nested lists.
 *
 *  ```html
 * <rx-virtual-scroll-viewport>
 *   <div
 *    autosized
 *    *rxVirtualFor="let hero of heroes$; trackBy: trackItem; let select = select;">
 *     <div>
 *       <strong>{{ hero.name }}</strong></br>
 *       Defeated enemies:
 *     </div>
 *      <span *rxFor="let enemy of select(['defeatedEnemies']); trackBy: trackEnemy;">
 *        {{ enemy.name }}
 *      </span>
 *   </div>
 * </rx-virtual-scroll-viewport>
 *  ```
 *
 * ### Using the context variables
 *
 * ```html
 * <rx-virtual-scroll-viewport>
 *  <div
 *     *rxVirtualFor="
 *       let item of observableItems$;
 *       let count = count;
 *       let index = index;
 *       let first = first;
 *       let last = last;
 *       let even = even;
 *       let odd = odd;
 *       trackBy: trackItem;
 *     "
 *   >
 *     <div>{{ count }}</div>
 *     <div>{{ index }}</div>
 *     <div>{{ item }}</div>
 *     <div>{{ first }}</div>
 *     <div>{{ last }}</div>
 *     <div>{{ even }}</div>
 *     <div>{{ odd }}</div>
 *   </div>
 * </rx-virtual-scroll-viewport>
 * ```
 *
 * @docsCategory RxVirtualFor
 * @docsPage RxVirtualFor
 * @publicApi
 */
export class RxVirtualFor {
    templateRef;
    scrollStrategy = inject((RxVirtualScrollStrategy));
    iterableDiffers = inject(IterableDiffers);
    cdRef = inject(ChangeDetectorRef);
    ngZone = inject(NgZone);
    /** @internal */
    injector = inject(Injector);
    viewContainer = inject(ViewContainerRef);
    strategyProvider = inject(RxStrategyProvider);
    errorHandler = inject(ErrorHandler);
    defaults = inject(RX_VIRTUAL_SCROLL_DEFAULT_OPTIONS, {
        optional: true,
    });
    /** @internal */
    _differ;
    /** @internal */
    partiallyFinished = false;
    /** @internal */
    staticValue;
    /** @internal */
    renderStatic = false;
    /**
     * @description
     * The iterable input
     *
     * @example
     * <rx-virtual-scroll-viewport>
     *   <app-hero *rxVirtualFor="heroes$; let hero"
     *     [hero]="hero"></app-hero>
     * </rx-virtual-scroll-viewport>
     *
     * @param potentialSignalOrObservable
     */
    set rxVirtualForOf(potentialSignalOrObservable) {
        if (isSignal(potentialSignalOrObservable)) {
            this.staticValue = undefined;
            this.renderStatic = false;
            this.observables$.next(toObservable(potentialSignalOrObservable, { injector: this.injector }));
        }
        else if (!isObservable(potentialSignalOrObservable)) {
            this.staticValue = potentialSignalOrObservable;
            this.renderStatic = true;
        }
        else {
            this.staticValue = undefined;
            this.renderStatic = false;
            this.observables$.next(potentialSignalOrObservable);
        }
    }
    /**
     * @internal
     * A reference to the template that is created for each item in the iterable.
     * @see [template reference variable](guide/template-reference-variables)
     * (inspired by @angular/common `ng_for_of.ts`)
     */
    _template;
    set rxVirtualForTemplate(value) {
        this._template = value;
    }
    /** @internal */
    strategyHandler = strategyHandling(this.strategyProvider.primaryStrategy, this.strategyProvider.strategies);
    /**
     * @description
     * The rendering strategy to be used to render updates to the DOM.
     * Use it to dynamically manage your rendering strategy. You can switch the strategy
     * imperatively (with a string) or by binding an Observable.
     * The default strategy is `'normal'` if not configured otherwise.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *     <rx-virtual-scroll-viewport>
     *       <app-hero
     *        autosized
     *        *rxVirtualFor="let hero of heroes$; strategy: strategy"
     *        [hero]="hero"></app-hero>
     *     </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   strategy = 'low';
     * }
     *
     * // OR
     *
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *     <rx-virtual-scroll-viewport>
     *       <app-hero
     *        autosized
     *        *rxVirtualFor="let hero of heroes$; strategy: strategy$"
     *        [hero]="hero"></app-hero>
     *     </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   strategy$ = new BehaviorSubject('immediate');
     * }
     *
     * @param strategyName
     * @see {@link strategies}
     */
    set strategy(strategyName) {
        this.strategyHandler.next(strategyName);
    }
    /**
     * @description
     * Controls the amount if views held in cache for later re-use when a user is
     * scrolling the list. If this is set to 0, `rxVirtualFor` won't cache any view,
     * thus destroying & re-creating very often on scroll events.
     */
    templateCacheSize = this.defaults?.templateCacheSize || DEFAULT_TEMPLATE_CACHE_SIZE;
    /**
     * @description
     *  If `parent` is set to `true` (default to `false`), `*rxVirtualFor` will
     *  automatically run change-detection for its parent component when its scheduled
     *  tasks are done in order to update any pending `@ContentChild` or `@ViewChild`
     *  relation to be updated according to the updated ViewContainer.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *   <rx-virtual-scroll-viewport>
     *      <app-list-item
     *        *rxVirtualFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *          parent: true;
     *        "
     *        [item]="item"
     *        autosized
     *      ></app-list-item>
     *    </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   // those queries won't be in sync with what `rxVirtualFor` is rendering
     *   // when parent is set to false.
     *   \@ViewChildren(AppListItem) listItems: QueryList<AppListItem>;
     *
     *   items$ = itemService.getItems();
     * }
     *
     * @param renderParent
     *
     * @deprecated this flag will be dropped soon, as it is no longer required when using signal based view & content queries
     */
    renderParent = false;
    /**
     * @description
     * A flag to control whether `*rxVirtualFor` rendering happens within
     * `NgZone` or not. The default value is set to `true` if not configured otherwise.
     * If `patchZone` is set to `false` `*rxVirtualFor` will operate completely outside of `NgZone`.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <rx-virtual-scroll-viewport>
     *      <app-list-item
     *        *rxVirtualFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *          patchZone: false;
     *        "
     *        [item]="item"
     *        autosized
     *      ></app-list-item>
     *    </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     * }
     *
     * @param patchZone
     */
    patchZone = this.strategyProvider.config.patchZone;
    /*@Input('rxVirtualForTombstone') tombstone: TemplateRef<
     RxVirtualForViewContext<T>
     > | null = null;*/
    /**
     * @description
     * A function or key that defines how to track changes for items in the provided
     * iterable data.
     *
     * When items are added, moved, or removed in the iterable,
     * the directive must re-render the appropriate DOM nodes.
     * To minimize operations on the DOM, only nodes that have changed
     * are re-rendered.
     *
     * By default, `rxVirtualFor` assumes that the object instance identifies
     * the node in the iterable (equality check `===`).
     * When a function or key is supplied, `rxVirtualFor` uses the result to identify the item node.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <rx-virtual-scroll-viewport>
     *      <app-list-item
     *        *rxVirtualFor="
     *          let item of items$;
     *          trackBy: 'id';
     *        "
     *        autosized
     *        [item]="item"
     *      >
     *      </app-list-item>
     *    </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     * }
     *
     * // OR
     *
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *   <rx-virtual-scroll-viewport>
     *      <app-list-item
     *        *rxVirtualFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *        "
     *        autosized
     *        [item]="item"
     *      >
     *      </app-list-item>
     *    </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   items$ = itemService.getItems();
     *   trackItem = (idx, item) => item.id;
     * }
     *
     * @param trackByFnOrKey
     */
    set trackBy(trackByFnOrKey) {
        if (NG_DEV_MODE &&
            trackByFnOrKey != null &&
            typeof trackByFnOrKey !== 'string' &&
            typeof trackByFnOrKey !== 'symbol' &&
            typeof trackByFnOrKey !== 'function') {
            throw new Error(`trackBy must be typeof function or keyof T, but received ${JSON.stringify(trackByFnOrKey)}.`);
        }
        if (trackByFnOrKey == null) {
            this._trackBy = null;
        }
        else {
            this._trackBy =
                typeof trackByFnOrKey !== 'function'
                    ? (i, a) => a[trackByFnOrKey]
                    : trackByFnOrKey;
        }
    }
    /**
     * @description
     * A `Subject` which emits whenever `*rxVirtualFor` finished rendering a
     * set of changes to the view.
     * This enables developers to perform actions exactly at the timing when the
     * updates passed are rendered to the DOM.
     * The `renderCallback` is useful in situations where you rely on specific DOM
     * properties like the `height` of a table after all items got rendered.
     * It is also possible to use the renderCallback in order to determine if a
     * view should be visible or not. This way developers can hide a list as
     * long as it has not finished rendering.
     *
     * The result of the `renderCallback` will contain the currently rendered set
     * of items in the iterable.
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <rx-virtual-scroll-viewport>
     *      <app-list-item
     *        *rxVirtualFor="
     *          let item of items$;
     *          trackBy: trackItem;
     *          renderCallback: itemsRendered;
     *        "
     *        autosized
     *        [item]="item"
     *      >
     *      </app-list-item>
     *    </rx-virtual-scroll-viewport>
     *   `
     * })
     * export class AppComponent {
     *   items$: Observable<Item[]> = itemService.getItems();
     *   trackItem = (idx, item) => item.id;
     *   // this emits whenever rxVirtualFor finished rendering changes
     *   itemsRendered = new Subject<Item[]>();
     * }
     *
     * @param renderCallback
     */
    set renderCallback(renderCallback) {
        this._renderCallback = renderCallback;
    }
    /** @internal */
    viewsRendered$ = new Subject();
    /** @internal */
    viewRendered$ = new Subject();
    /** @internal */
    renderingStart$ = new Subject();
    /** @internal */
    get template() {
        return this._template || this.templateRef;
    }
    /** @internal */
    observables$ = new ReplaySubject(1);
    /** @internal */
    _renderCallback;
    /** @internal */
    values$ = this.observables$.pipe(coerceObservableWith(), switchAll(), shareReplay({ bufferSize: 1, refCount: true }));
    /** @internal */
    values;
    /** @internal */
    templateManager;
    /** @internal */
    _destroy$ = new Subject();
    /** @internal */
    _trackBy = null;
    /** @internal */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    /** @internal */
    ngOnInit() {
        this.values$.pipe(takeUntil(this._destroy$)).subscribe((values) => {
            this.values = values;
        });
        this.templateManager = createVirtualListTemplateManager({
            viewContainerRef: this.viewContainer,
            templateRef: this.template,
            createViewContext: this.createViewContext.bind(this),
            updateViewContext: this.updateViewContext.bind(this),
            templateCacheSize: this.templateCacheSize,
        });
        // let the scroll strategy initialize before
        Promise.resolve().then(() => {
            this.render()
                .pipe(takeUntil(this._destroy$))
                .subscribe((v) => {
                this._renderCallback?.next(v);
            });
        });
    }
    /** @internal */
    ngDoCheck() {
        if (this.renderStatic) {
            this.observables$.next(this.staticValue);
        }
    }
    /** @internal */
    ngOnDestroy() {
        this._destroy$.next();
        this.templateManager.detach();
    }
    render() {
        return combineLatest([
            this.values$.pipe(map((values) => Array.isArray(values)
                ? values
                : values != null
                    ? Array.from(values)
                    : [])),
            this.scrollStrategy.renderedRange$,
            this.strategyHandler.strategy$.pipe(distinctUntilChanged()),
        ]).pipe(switchMap(([items, range, strategy]) => 
        // wait for scrollStrategy to be stable until computing new state
        this.scrollStrategy.isStable.pipe(take(1), 
        // map iterable to latest diff
        switchMap(() => {
            const iterable = items.slice(range.start, range.end);
            const differ = this.getDiffer(iterable);
            let changes = null;
            if (differ) {
                if (this.partiallyFinished) {
                    const currentIterable = [];
                    for (let i = 0, ilen = this.viewContainer.length; i < ilen; i++) {
                        const viewRef = (this.viewContainer.get(i));
                        currentIterable[i] = viewRef.context.$implicit;
                    }
                    differ.diff(currentIterable);
                }
                changes = differ.diff(iterable);
            }
            if (!changes) {
                return NEVER;
            }
            const listChanges = this.templateManager.getListChanges(changes, iterable, items.length, range.start);
            const updates = listChanges[0].sort((a, b) => a[0] - b[0]);
            const indicesToPosition = new Set();
            const insertedOrRemoved = listChanges[1];
            const work$ = updates.map(([index, work, removed]) => {
                if (!removed) {
                    indicesToPosition.add(index);
                }
                return onStrategy(null, strategy, () => {
                    const update = work();
                    if (update.view) {
                        this.viewRendered$.next(update);
                    }
                }, { ngZone: this.patchZone ? this.ngZone : undefined });
            });
            this.partiallyFinished = true;
            const notifyParent = insertedOrRemoved && this.renderParent;
            this.renderingStart$.next(indicesToPosition);
            return combineLatest(
            // emit after all changes are rendered
            work$.length > 0 ? work$ : [of(iterable)]).pipe(tap(() => {
                this.templateManager.setItemCount(items.length);
                this.partiallyFinished = false;
                const viewsRendered = [];
                const end = this.viewContainer.length;
                let i = 0;
                for (i; i < end; i++) {
                    viewsRendered.push(this.viewContainer.get(i));
                }
                this.viewsRendered$.next(viewsRendered);
            }), notifyParent
                ? switchMap((v) => concat(of(v), onStrategy(null, strategy, (_, work, options) => {
                    work(this.cdRef, options.scope);
                }, {
                    ngZone: this.patchZone ? this.ngZone : undefined,
                    scope: this.cdRef.context || this.cdRef,
                }).pipe(ignoreElements())))
                : (o$) => o$, this.handleError(), map(() => iterable));
        }))), this.handleError());
    }
    handleError() {
        return (o$) => o$.pipe(catchError((err) => {
            this.partiallyFinished = false;
            this.errorHandler.handleError(err);
            return of(null);
        }));
    }
    getDiffer(values) {
        if (this._differ) {
            return this._differ;
        }
        return values
            ? (this._differ = this.iterableDiffers.find(values).create(this._trackBy))
            : null;
    }
    /** @internal */
    createViewContext(item, computedContext) {
        return new RxVirtualForViewContext(item, this.values, computedContext);
    }
    /** @internal */
    updateViewContext(item, view, computedContext) {
        view.context.updateContext(computedContext);
        view.context.$implicit = item;
        view.context.rxVirtualForOf = this.values;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxVirtualFor, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: RxVirtualFor, isStandalone: true, selector: "[rxVirtualFor][rxVirtualForOf]", inputs: { rxVirtualForOf: "rxVirtualForOf", rxVirtualForTemplate: "rxVirtualForTemplate", strategy: ["rxVirtualForStrategy", "strategy"], templateCacheSize: ["rxVirtualForTemplateCacheSize", "templateCacheSize"], renderParent: ["rxVirtualForParent", "renderParent"], patchZone: ["rxVirtualForPatchZone", "patchZone"], trackBy: ["rxVirtualForTrackBy", "trackBy"], renderCallback: ["rxVirtualForRenderCallback", "renderCallback"] }, providers: [{ provide: RxVirtualViewRepeater, useExisting: RxVirtualFor }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxVirtualFor, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rxVirtualFor][rxVirtualForOf]',
                    providers: [{ provide: RxVirtualViewRepeater, useExisting: RxVirtualFor }],
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }], propDecorators: { rxVirtualForOf: [{
                type: Input
            }], rxVirtualForTemplate: [{
                type: Input
            }], strategy: [{
                type: Input,
                args: ['rxVirtualForStrategy']
            }], templateCacheSize: [{
                type: Input,
                args: ['rxVirtualForTemplateCacheSize']
            }], renderParent: [{
                type: Input,
                args: ['rxVirtualForParent']
            }], patchZone: [{
                type: Input,
                args: ['rxVirtualForPatchZone']
            }], trackBy: [{
                type: Input,
                args: ['rxVirtualForTrackBy']
            }], renderCallback: [{
                type: Input,
                args: ['rxVirtualForRenderCallback']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1mb3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy90ZW1wbGF0ZS9leHBlcmltZW50YWwvdmlydHVhbC1zY3JvbGxpbmcvc3JjL2xpYi92aXJ0dWFsLWZvci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixTQUFTLEVBR1QsWUFBWSxFQUNaLE1BQU0sRUFDTixRQUFRLEVBQ1IsS0FBSyxFQUNMLFFBQVEsRUFHUixlQUFlLEVBRWYsTUFBTSxFQUlOLFdBQVcsRUFFWCxnQkFBZ0IsR0FDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzFELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFDTCxVQUFVLEVBR1Ysa0JBQWtCLEVBQ2xCLGdCQUFnQixHQUNqQixNQUFNLG1DQUFtQyxDQUFDO0FBRTNDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUM1RCxPQUFPLEVBQ0wsYUFBYSxFQUNiLE1BQU0sRUFDTixZQUFZLEVBRVosS0FBSyxFQUVMLEVBQUUsRUFDRixhQUFhLEVBQ2IsT0FBTyxHQUNSLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUNMLFVBQVUsRUFDVixvQkFBb0IsRUFDcEIsY0FBYyxFQUNkLEdBQUcsRUFDSCxXQUFXLEVBQ1gsU0FBUyxFQUNULFNBQVMsRUFDVCxJQUFJLEVBQ0osU0FBUyxFQUNULEdBQUcsR0FDSixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsdUJBQXVCLEVBQ3ZCLHFCQUFxQixHQUN0QixNQUFNLFNBQVMsQ0FBQztBQUNqQixPQUFPLEVBQ0wsZ0NBQWdDLEdBRWpDLE1BQU0saUNBQWlDLENBQUM7QUFDekMsT0FBTyxFQUNMLDJCQUEyQixFQUMzQixpQ0FBaUMsR0FDbEMsTUFBTSx5QkFBeUIsQ0FBQzs7QUFRakMsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFFcEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtIRztBQU1ILE1BQU0sT0FBTyxZQUFZO0lBMlpKO0lBeFpGLGNBQWMsR0FBRyxNQUFNLENBQUMsQ0FBQSx1QkFBNkIsQ0FBQSxDQUFDLENBQUM7SUFDdkQsZUFBZSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUMxQyxLQUFLLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDbEMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6QyxnQkFBZ0I7SUFDUixRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzNCLGFBQWEsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNqQyxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUM5QyxZQUFZLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3BDLFFBQVEsR0FBSSxNQUFNLENBQUMsaUNBQWlDLEVBQUU7UUFDckUsUUFBUSxFQUFFLElBQUk7S0FDZixDQUFDLENBQUM7SUFFSCxnQkFBZ0I7SUFDUixPQUFPLENBQXFCO0lBRXBDLGdCQUFnQjtJQUNSLGlCQUFpQixHQUFHLEtBQUssQ0FBQztJQUVsQyxnQkFBZ0I7SUFDUixXQUFXLENBQUs7SUFDeEIsZ0JBQWdCO0lBQ1IsWUFBWSxHQUFHLEtBQUssQ0FBQztJQUU3Qjs7Ozs7Ozs7Ozs7T0FXRztJQUNILElBQ0ksY0FBYyxDQUNoQiwyQkFLYTtRQUViLElBQUksUUFBUSxDQUFDLDJCQUEyQixDQUFDLEVBQUUsQ0FBQztZQUMxQyxJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztZQUM3QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsWUFBWSxDQUFDLDJCQUEyQixFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUN2RSxDQUFDO1FBQ0osQ0FBQzthQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsMkJBQTJCLENBQUMsRUFBRSxDQUFDO1lBQ3RELElBQUksQ0FBQyxXQUFXLEdBQUcsMkJBQTJCLENBQUM7WUFDL0MsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDM0IsQ0FBQzthQUFNLENBQUM7WUFDTixJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztZQUM3QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBQ3RELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxTQUFTLENBQThDO0lBQy9ELElBQ0ksb0JBQW9CLENBQUMsS0FBaUQ7UUFDeEUsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDekIsQ0FBQztJQUVELGdCQUFnQjtJQUNSLGVBQWUsR0FBRyxnQkFBZ0IsQ0FDeEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsRUFDckMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FDakMsQ0FBQztJQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQ0c7SUFDSCxJQUNJLFFBQVEsQ0FDVixZQUEyRTtRQUUzRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDcUMsaUJBQWlCLEdBQ3ZELElBQUksQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLElBQUksMkJBQTJCLENBQUM7SUFFbEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUNHO0lBQzBCLFlBQVksR0FBRyxLQUFLLENBQUM7SUFFbEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0Qkc7SUFDNkIsU0FBUyxHQUN2QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUV6Qzs7dUJBRW1CO0lBRW5COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTJERztJQUNILElBQ0ksT0FBTyxDQUFDLGNBQTRDO1FBQ3RELElBQ0UsV0FBVztZQUNYLGNBQWMsSUFBSSxJQUFJO1lBQ3RCLE9BQU8sY0FBYyxLQUFLLFFBQVE7WUFDbEMsT0FBTyxjQUFjLEtBQUssUUFBUTtZQUNsQyxPQUFPLGNBQWMsS0FBSyxVQUFVLEVBQ3BDLENBQUM7WUFDRCxNQUFNLElBQUksS0FBSyxDQUNiLDREQUE0RCxJQUFJLENBQUMsU0FBUyxDQUN4RSxjQUFjLENBQ2YsR0FBRyxDQUNMLENBQUM7UUFDSixDQUFDO1FBQ0QsSUFBSSxjQUFjLElBQUksSUFBSSxFQUFFLENBQUM7WUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDdkIsQ0FBQzthQUFNLENBQUM7WUFDTixJQUFJLENBQUMsUUFBUTtnQkFDWCxPQUFPLGNBQWMsS0FBSyxVQUFVO29CQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDO29CQUM3QixDQUFDLENBQUMsY0FBYyxDQUFDO1FBQ3ZCLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUNHO0lBQ0gsSUFBeUMsY0FBYyxDQUNyRCxjQUEwQjtRQUUxQixJQUFJLENBQUMsZUFBZSxHQUFHLGNBQWMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsZ0JBQWdCO0lBQ1AsY0FBYyxHQUFHLElBQUksT0FBTyxFQUVsQyxDQUFDO0lBQ0osZ0JBQWdCO0lBQ1AsYUFBYSxHQUFHLElBQUksT0FBTyxFQUloQyxDQUFDO0lBQ0wsZ0JBQWdCO0lBQ1AsZUFBZSxHQUFHLElBQUksT0FBTyxFQUFlLENBQUM7SUFFdEQsZ0JBQWdCO0lBQ2hCLElBQVksUUFBUTtRQUNsQixPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUM1QyxDQUFDO0lBRUQsZ0JBQWdCO0lBQ1IsWUFBWSxHQUFHLElBQUksYUFBYSxDQUt0QyxDQUFDLENBQUMsQ0FBQztJQUVMLGdCQUFnQjtJQUNSLGVBQWUsQ0FBYztJQUVyQyxnQkFBZ0I7SUFDUCxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3ZDLG9CQUFvQixFQUFFLEVBQ3RCLFNBQVMsRUFBRSxFQUNYLFdBQVcsQ0FBQyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQy9DLENBQUM7SUFFRixnQkFBZ0I7SUFDUixNQUFNLENBQW9DO0lBRWxELGdCQUFnQjtJQUNSLGVBQWUsQ0FHckI7SUFFRixnQkFBZ0I7SUFDUixTQUFTLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztJQUV4QyxnQkFBZ0I7SUFDaEIsUUFBUSxHQUE4QixJQUFJLENBQUM7SUFFM0MsZ0JBQWdCO0lBQ2hCLE1BQU0sQ0FBQyxzQkFBc0IsQ0FLM0IsR0FBdUIsRUFDdkIsR0FBUTtRQUVSLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELFlBQ21CLFdBQXVEO1FBQXZELGdCQUFXLEdBQVgsV0FBVyxDQUE0QztJQUN2RSxDQUFDO0lBRUosZ0JBQWdCO0lBQ2hCLFFBQVE7UUFDTixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDaEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDdkIsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsZUFBZSxHQUFHLGdDQUFnQyxDQUFDO1lBQ3RELGdCQUFnQixFQUFFLElBQUksQ0FBQyxhQUFhO1lBQ3BDLFdBQVcsRUFBRSxJQUFJLENBQUMsUUFBUTtZQUMxQixpQkFBaUIsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNwRCxpQkFBaUIsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNwRCxpQkFBaUIsRUFBRSxJQUFJLENBQUMsaUJBQWlCO1NBQzFDLENBQUMsQ0FBQztRQUNILDRDQUE0QztRQUM1QyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUMxQixJQUFJLENBQUMsTUFBTSxFQUFFO2lCQUNWLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUMvQixTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxDQUFNLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELGdCQUFnQjtJQUNoQixTQUFTO1FBQ1AsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDdEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNDLENBQUM7SUFDSCxDQUFDO0lBRUQsZ0JBQWdCO0lBQ2hCLFdBQVc7UUFDVCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUVPLE1BQU07UUFDWixPQUFPLGFBQWEsQ0FBMEM7WUFDNUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ2YsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDYixLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztnQkFDbkIsQ0FBQyxDQUFDLE1BQU07Z0JBQ1IsQ0FBQyxDQUFDLE1BQU0sSUFBSSxJQUFJO29CQUNkLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztvQkFDcEIsQ0FBQyxDQUFDLEVBQUUsQ0FDVCxDQUNGO1lBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjO1lBQ2xDLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQzVELENBQUMsQ0FBQyxJQUFJLENBQ0wsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFLEVBQUU7UUFDckMsaUVBQWlFO1FBQ2pFLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLElBQUksQ0FDL0IsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNQLDhCQUE4QjtRQUM5QixTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ2IsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hDLElBQUksT0FBTyxHQUE4QixJQUFJLENBQUM7WUFDOUMsSUFBSSxNQUFNLEVBQUUsQ0FBQztnQkFDWCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO29CQUMzQixNQUFNLGVBQWUsR0FBRyxFQUFFLENBQUM7b0JBQzNCLEtBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFDM0MsQ0FBQyxHQUFHLElBQUksRUFDUixDQUFDLEVBQUUsRUFDSCxDQUFDO3dCQUNELE1BQU0sT0FBTyxHQUF5QixDQUNwQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDMUIsQ0FBQzt3QkFDRixlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7b0JBQ2pELENBQUM7b0JBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDL0IsQ0FBQztnQkFDRCxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNsQyxDQUFDO1lBQ0QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNiLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUNELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsY0FBYyxDQUNyRCxPQUFPLEVBQ1AsUUFBUSxFQUNSLEtBQUssQ0FBQyxNQUFNLEVBQ1osS0FBSyxDQUFDLEtBQUssQ0FDWixDQUFDO1lBQ0YsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUUzRCxNQUFNLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7WUFDNUMsTUFBTSxpQkFBaUIsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFO2dCQUNuRCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2IsaUJBQWlCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMvQixDQUFDO2dCQUNELE9BQU8sVUFBVSxDQUNmLElBQUksRUFDSixRQUFRLEVBQ1IsR0FBRyxFQUFFO29CQUNILE1BQU0sTUFBTSxHQUFHLElBQUksRUFBRSxDQUFDO29CQUN0QixJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQzt3QkFDaEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBYSxDQUFDLENBQUM7b0JBQ3pDLENBQUM7Z0JBQ0gsQ0FBQyxFQUNELEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUNyRCxDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1lBQzlCLE1BQU0sWUFBWSxHQUFHLGlCQUFpQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDNUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUM3QyxPQUFPLGFBQWE7WUFDbEIsc0NBQXNDO1lBQ3RDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQzFDLENBQUMsSUFBSSxDQUNKLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1AsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO2dCQUMvQixNQUFNLGFBQWEsR0FBRyxFQUFFLENBQUM7Z0JBQ3pCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO2dCQUN0QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ1YsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO29CQUNyQixhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hELENBQUM7Z0JBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBb0IsQ0FBQyxDQUFDO1lBQ2pELENBQUMsQ0FBQyxFQUNGLFlBQVk7Z0JBQ1YsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQ2QsTUFBTSxDQUNKLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDTCxVQUFVLENBQ1IsSUFBSSxFQUNKLFFBQVEsRUFDUixDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEVBQUU7b0JBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbEMsQ0FBQyxFQUNEO29CQUNFLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTO29CQUNoRCxLQUFLLEVBQUcsSUFBSSxDQUFDLEtBQWEsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUs7aUJBQ2pELENBQ0YsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FDekIsQ0FDRjtnQkFDSCxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFDZCxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQ2xCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FDcEIsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUNILENBQ0YsRUFDRCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQ25CLENBQUM7SUFDSixDQUFDO0lBRU8sV0FBVztRQUNqQixPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FDWixFQUFFLENBQUMsSUFBSSxDQUNMLFVBQVUsQ0FBQyxDQUFDLEdBQVUsRUFBRSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7WUFDL0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbkMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNOLENBQUM7SUFFTyxTQUFTLENBQUMsTUFBcUI7UUFDckMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDakIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7UUFDRCxPQUFPLE1BQU07WUFDWCxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDMUUsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNYLENBQUM7SUFFRCxnQkFBZ0I7SUFDUixpQkFBaUIsQ0FDdkIsSUFBTyxFQUNQLGVBQTBDO1FBRTFDLE9BQU8sSUFBSSx1QkFBdUIsQ0FDaEMsSUFBSSxFQUNKLElBQUksQ0FBQyxNQUFZLEVBQ2pCLGVBQWUsQ0FDaEIsQ0FBQztJQUNKLENBQUM7SUFFRCxnQkFBZ0I7SUFDUixpQkFBaUIsQ0FDdkIsSUFBTyxFQUNQLElBRUMsRUFDRCxlQUEyQztRQUUzQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxlQUFnQixDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQzlCLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxNQUFZLENBQUM7SUFDbEQsQ0FBQzswSEEvbEJVLFlBQVk7OEdBQVosWUFBWSw0ZkFIWixDQUFDLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsQ0FBQzs7MkZBRy9ELFlBQVk7a0JBTHhCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGdDQUFnQztvQkFDMUMsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsV0FBVyxjQUFjLEVBQUUsQ0FBQztvQkFDMUUsVUFBVSxFQUFFLElBQUk7aUJBQ2pCO2dGQXlDSyxjQUFjO3NCQURqQixLQUFLO2dCQWlDRixvQkFBb0I7c0JBRHZCLEtBQUs7Z0JBc0RGLFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxzQkFBc0I7Z0JBYVcsaUJBQWlCO3NCQUF4RCxLQUFLO3VCQUFDLCtCQUErQjtnQkF1Q1QsWUFBWTtzQkFBeEMsS0FBSzt1QkFBQyxvQkFBb0I7Z0JBK0JLLFNBQVM7c0JBQXhDLEtBQUs7dUJBQUMsdUJBQXVCO2dCQW9FMUIsT0FBTztzQkFEVixLQUFLO3VCQUFDLHFCQUFxQjtnQkFtRWEsY0FBYztzQkFBdEQsS0FBSzt1QkFBQyw0QkFBNEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRGlyZWN0aXZlLFxuICBEb0NoZWNrLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIEVycm9ySGFuZGxlcixcbiAgaW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIGlzU2lnbmFsLFxuICBJdGVyYWJsZUNoYW5nZXMsXG4gIEl0ZXJhYmxlRGlmZmVyLFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIE5nSXRlcmFibGUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFNpZ25hbCxcbiAgVGVtcGxhdGVSZWYsXG4gIFRyYWNrQnlGdW5jdGlvbixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0b09ic2VydmFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQgeyBjb2VyY2VPYnNlcnZhYmxlV2l0aCB9IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9jb2VyY2luZyc7XG5pbXBvcnQge1xuICBvblN0cmF0ZWd5LFxuICBSeFN0cmF0ZWd5Q3JlZGVudGlhbHMsXG4gIFJ4U3RyYXRlZ3lOYW1lcyxcbiAgUnhTdHJhdGVneVByb3ZpZGVyLFxuICBzdHJhdGVneUhhbmRsaW5nLFxufSBmcm9tICdAcngtYW5ndWxhci9jZGsvcmVuZGVyLXN0cmF0ZWdpZXMnO1xuaW1wb3J0IHsgUnhMaXN0Vmlld0NvbXB1dGVkQ29udGV4dCB9IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay90ZW1wbGF0ZSc7XG5pbXBvcnQgeyBQcm9taXNlIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3pvbmUtbGVzcy9icm93c2VyJztcbmltcG9ydCB7XG4gIGNvbWJpbmVMYXRlc3QsXG4gIGNvbmNhdCxcbiAgaXNPYnNlcnZhYmxlLFxuICBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sXG4gIE5FVkVSLFxuICBPYnNlcnZhYmxlLFxuICBvZixcbiAgUmVwbGF5U3ViamVjdCxcbiAgU3ViamVjdCxcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgaWdub3JlRWxlbWVudHMsXG4gIG1hcCxcbiAgc2hhcmVSZXBsYXksXG4gIHN3aXRjaEFsbCxcbiAgc3dpdGNoTWFwLFxuICB0YWtlLFxuICB0YWtlVW50aWwsXG4gIHRhcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgTGlzdFJhbmdlLFxuICBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dCxcbiAgUnhWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3ksXG4gIFJ4VmlydHVhbFZpZXdSZXBlYXRlcixcbn0gZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQge1xuICBjcmVhdGVWaXJ0dWFsTGlzdFRlbXBsYXRlTWFuYWdlcixcbiAgUnhWaXJ0dWFsTGlzdFRlbXBsYXRlTWFuYWdlcixcbn0gZnJvbSAnLi92aXJ0dWFsLWxpc3QtdGVtcGxhdGUtbWFuYWdlcic7XG5pbXBvcnQge1xuICBERUZBVUxUX1RFTVBMQVRFX0NBQ0hFX1NJWkUsXG4gIFJYX1ZJUlRVQUxfU0NST0xMX0RFRkFVTFRfT1BUSU9OUyxcbn0gZnJvbSAnLi92aXJ0dWFsLXNjcm9sbC5jb25maWcnO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBXaWxsIGJlIHByb3ZpZGVkIHRocm91Z2ggVGVyc2VyIGdsb2JhbCBkZWZpbml0aW9ucyBieSBBbmd1bGFyIENMSVxuICogZHVyaW5nIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLlxuICovXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCAhIW5nRGV2TW9kZTtcblxuLyoqXG4gKiBARGlyZWN0aXZlIFJ4VmlydHVhbEZvclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoZSBgKnJ4VmlydHVhbEZvcmAgc3RydWN0dXJhbCBkaXJlY3RpdmUgcHJvdmlkZXMgYSBjb252ZW5pZW50IGFuZCBwZXJmb3JtYW50XG4gKiB3YXkgZm9yIHJlbmRlcmluZyBodWdlIGxpc3RzIG9mIGl0ZW1zLiBJdCBicmluZ3MgYWxsIHRoZSBiZW5lZml0cyBgcnhGb3JgIGRvZXMsXG4gKiBhbmQgaW1wbGVtZW50cyB2aXJ0dWFsIHJlbmRlcmluZy5cbiAqXG4gKiBJbnN0ZWFkIG9mIHJlbmRlcmluZyBldmVyeSBpdGVtIHByb3ZpZGVkLCByeFZpcnR1YWxGb3Igb25seSByZW5kZXJzIHdoYXQgaXNcbiAqIGN1cnJlbnRseSB2aXNpYmxlIHRvIHRoZSB1c2VyLCB0aHVzIHByb3ZpZGluZyBleGNlbGxlbnQgcnVudGltZSBwZXJmb3JtYW5jZVxuICogZm9yIGh1Z2Ugc2V0cyBvZiBkYXRhLlxuICpcbiAqIFRoZSB0ZWNobmlxdWUgdG8gcmVuZGVyIGl0ZW1zIGlzIGNvbXBhcmFibGUgdG8gdGhlIG9uIHVzZWQgYnkgdHdpdHRlciBhbmRcbiAqIGV4cGxhaW5lZCBpbiB2ZXJ5IG11Y2ggZGV0YWlsIGJ5IEBEYXNTdXJtYSBpbiBoaXMgYmxvZyBwb3N0IGFib3V0IHRoZSBbY29tcGxleGl0aWVzXG4gKiBvZiBpbmZpbml0ZSBzY3JvbGxlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vYmxvZy9pbmZpbml0ZS1zY3JvbGxlci8pLlxuICpcbiAqIFwiRWFjaCByZWN5Y2xpbmcgb2YgYSBET00gZWxlbWVudCB3b3VsZCBub3JtYWxseSByZWxheW91dCB0aGUgZW50aXJlIHJ1bndheSB3aGljaFxuICogd291bGQgYnJpbmcgdXMgd2VsbCBiZWxvdyBvdXIgdGFyZ2V0IG9mIDYwIGZyYW1lcyBwZXIgc2Vjb25kLlxuICogVG8gYXZvaWQgdGhpcywgd2UgYXJlIHRha2luZyB0aGUgYnVyZGVuIG9mIGxheW91dCBvbnRvIG91cnNlbHZlcyBhbmQgdXNlXG4gKiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxlbWVudHMgd2l0aCB0cmFuc2Zvcm1zLlwiIChARGFzU3VybWEpXG4gKlxuICogIyMgQVBJXG4gKiBUaGUgQVBJIGlzIGEgY29tYmluYXRpb24gb2YgXFxAcngtYW5ndWxhci90ZW1wbGF0ZS9mb3IgJlxuICogIFxcQGFuZ3VsYXIvY2RrIGAqY2RrVmlydHVhbEZvcmAuXG4gKiAqIHRyYWNrQnk6IGAoaW5kZXg6IG51bWJlciwgaXRlbTogVCkgPT4gYW55YCB8IGBrZXlvZiBUYFxuICogKiBzdHJhdGVneTogYHN0cmluZ2AgfCBgT2JzZXJ2YWJsZTxzdHJpbmc+YFxuICogKiBwYXJlbnQ6IGBib29sZWFuYDtcbiAqICogcmVuZGVyQ2FsbGJhY2s6IGBTdWJqZWN0PFRbXT5gXG4gKiAqIHZpZXdDYWNoZTogYG51bWJlcmBcbiAqICogKEluamVjdGVkKSBzY3JvbGxTdHJhdGVneTogYFJ4VmlydHVhbFNjcm9sbFN0cmF0ZWd5PFQsIFU+YFxuICogKiBwcm92aWRlcyBpdHNlbGYgYXMgUnhWaXJ0dWFsVmlld1JlcGVhdGVyIGZvciBSeFZpcnR1YWxWaWV3UG9ydENvbXBvbmVudCB0byBvcGVyYXRlXG4gKlxuICogIyMgRmVhdHVyZXNcbiAqICogUHVzaCBiYXNlZCBhcmNoaXRlY3R1cmVcbiAqICogQ29tcHJlaGVuc2l2ZSBzZXQgb2YgY29udGV4dCB2YXJpYWJsZXNcbiAqICogT3B0LW91dCBvZiBgTmdab25lYCB3aXRoIGBwYXRjaFpvbmVgXG4gKiAqIE5vdGlmeSB3aGVuIHJlbmRlcmluZyBvZiBjaGlsZCB0ZW1wbGF0ZXMgaXMgZmluaXNoZWQgKGByZW5kZXJDYWxsYmFja2ApXG4gKiAqIFN1cGVyIGVmZmljaWVudCBsYXlvdXRpbmcgd2l0aCBjc3MgdHJhbnNmb3JtYXRpb25zXG4gKiAqIERlZmluZSBhIHZpZXdDYWNoZSBpbiBvcmRlciB0byByZS11c2Ugdmlld3MgaW5zdGVhZCBvZiByZS1jcmVhdGluZyB0aGVtXG4gKiAqIENvbmZpZ3VyYWJsZSBSeFZpcnR1YWxTY3JvbGxTdHJhdGVneTxULCBVPiBwcm92aWRpbmcgdGhlIGNvcmUgbG9naWMgdG8gY2FsY3VsYXRlIHRoZSB2aWV3UmFuZ2UgYW5kIHBvc2l0aW9uIERPTVxuICogTm9kZXNcbiAqXG4gKiAjIyMgQ29udGV4dCBWYXJpYWJsZXNcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhdmFpbGFibGUgZm9yIGVhY2ggdGVtcGxhdGU6XG4gKlxuICogLSAkaW1wbGljaXQ6IGBUYCAvLyB0aGUgZGVmYXVsdCB2YXJpYWJsZSBhY2Nlc3NlZCBieSBgbGV0IHZhbGBcbiAqIC0gaXRlbSQ6IGBPYnNlcnZhYmxlPFQ+YCAvLyB0aGUgc2FtZSB2YWx1ZSBhcyAkaW1wbGljaXQsIGJ1dCBhcyBgT2JzZXJ2YWJsZWBcbiAqIC0gaW5kZXg6IGBudW1iZXJgIC8vIGN1cnJlbnQgaW5kZXggb2YgdGhlIGl0ZW1cbiAqIC0gY291bnQ6IGBudW1iZXJgIC8vIGNvdW50IG9mIGFsbCBpdGVtcyBpbiB0aGUgbGlzdFxuICogLSBmaXJzdDogYGJvb2xlYW5gIC8vIHRydWUgaWYgdGhlIGl0ZW0gaXMgdGhlIGZpcnN0IGluIHRoZSBsaXN0XG4gKiAtIGxhc3Q6IGBib29sZWFuYCAvLyB0cnVlIGlmIHRoZSBpdGVtIGlzIHRoZSBsYXN0IGluIHRoZSBsaXN0XG4gKiAtIGV2ZW46IGBib29sZWFuYCAvLyB0cnVlIGlmIHRoZSBpdGVtIGhhcyBvbiBldmVuIGluZGV4IChpbmRleCAlIDIgPT09IDApXG4gKiAtIG9kZDogYGJvb2xlYW5gIC8vIHRoZSBvcHBvc2l0ZSBvZiBldmVuXG4gKiAtIGluZGV4JDogYE9ic2VydmFibGU8bnVtYmVyPmAgLy8gaW5kZXggYXMgYE9ic2VydmFibGVgXG4gKiAtIGNvdW50JDogYE9ic2VydmFibGU8bnVtYmVyPmAgLy8gY291bnQgYXMgYE9ic2VydmFibGVgXG4gKiAtIGZpcnN0JDogYE9ic2VydmFibGU8Ym9vbGVhbj5gIC8vIGZpcnN0IGFzIGBPYnNlcnZhYmxlYFxuICogLSBsYXN0JDogYE9ic2VydmFibGU8Ym9vbGVhbj5gIC8vIGxhc3QgYXMgYE9ic2VydmFibGVgXG4gKiAtIGV2ZW4kOiBgT2JzZXJ2YWJsZTxib29sZWFuPmAgLy8gZXZlbiBhcyBgT2JzZXJ2YWJsZWBcbiAqIC0gb2RkJDogYE9ic2VydmFibGU8Ym9vbGVhbj5gIC8vIG9kZCBhcyBgT2JzZXJ2YWJsZWBcbiAqIC0gc2VsZWN0OiBgKGtleXM6IChrZXlvZiBUKVtdLCBkaXN0aW5jdEJ5TWFwKSA9PiBPYnNlcnZhYmxlPFBhcnRpYWw8VD4+YFxuICogLy8gcmV0dXJucyBhIHNlbGVjdGlvbiBmdW5jdGlvbiB3aGljaFxuICogLy8gYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHBsdWNrIG91dCBvZiBldmVyeSBsaXN0IGl0ZW0uIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mXG4gKiAvLyB0aGUgY3VycmVudCBsaXN0IGl0ZW0gYXMgZGlzdGluY3QgYE9ic2VydmFibGVgIGtleS12YWx1ZS1wYWlyLiBTZWUgdGhlIGV4YW1wbGUgYmVsb3c6XG4gKlxuICogVGhpcyBleGFtcGxlIHNob3djYXNlcyB0aGUgYHNlbGVjdGAgdmlldy1jb250ZXh0IGZ1bmN0aW9uIHVzZWQgZm9yIGRlZXBseSBuZXN0ZWQgbGlzdHMuXG4gKlxuICogIGBgYGh0bWxcbiAqIDxyeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAqICAgPGRpdlxuICogICAgYXV0b3NpemVkXG4gKiAgICAqcnhWaXJ0dWFsRm9yPVwibGV0IGhlcm8gb2YgaGVyb2VzJDsgdHJhY2tCeTogdHJhY2tJdGVtOyBsZXQgc2VsZWN0ID0gc2VsZWN0O1wiPlxuICogICAgIDxkaXY+XG4gKiAgICAgICA8c3Ryb25nPnt7IGhlcm8ubmFtZSB9fTwvc3Ryb25nPjwvYnI+XG4gKiAgICAgICBEZWZlYXRlZCBlbmVtaWVzOlxuICogICAgIDwvZGl2PlxuICogICAgICA8c3BhbiAqcnhGb3I9XCJsZXQgZW5lbXkgb2Ygc2VsZWN0KFsnZGVmZWF0ZWRFbmVtaWVzJ10pOyB0cmFja0J5OiB0cmFja0VuZW15O1wiPlxuICogICAgICAgIHt7IGVuZW15Lm5hbWUgfX1cbiAqICAgICAgPC9zcGFuPlxuICogICA8L2Rpdj5cbiAqIDwvcngtdmlydHVhbC1zY3JvbGwtdmlld3BvcnQ+XG4gKiAgYGBgXG4gKlxuICogIyMjIFVzaW5nIHRoZSBjb250ZXh0IHZhcmlhYmxlc1xuICpcbiAqIGBgYGh0bWxcbiAqIDxyeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAqICA8ZGl2XG4gKiAgICAgKnJ4VmlydHVhbEZvcj1cIlxuICogICAgICAgbGV0IGl0ZW0gb2Ygb2JzZXJ2YWJsZUl0ZW1zJDtcbiAqICAgICAgIGxldCBjb3VudCA9IGNvdW50O1xuICogICAgICAgbGV0IGluZGV4ID0gaW5kZXg7XG4gKiAgICAgICBsZXQgZmlyc3QgPSBmaXJzdDtcbiAqICAgICAgIGxldCBsYXN0ID0gbGFzdDtcbiAqICAgICAgIGxldCBldmVuID0gZXZlbjtcbiAqICAgICAgIGxldCBvZGQgPSBvZGQ7XG4gKiAgICAgICB0cmFja0J5OiB0cmFja0l0ZW07XG4gKiAgICAgXCJcbiAqICAgPlxuICogICAgIDxkaXY+e3sgY291bnQgfX08L2Rpdj5cbiAqICAgICA8ZGl2Pnt7IGluZGV4IH19PC9kaXY+XG4gKiAgICAgPGRpdj57eyBpdGVtIH19PC9kaXY+XG4gKiAgICAgPGRpdj57eyBmaXJzdCB9fTwvZGl2PlxuICogICAgIDxkaXY+e3sgbGFzdCB9fTwvZGl2PlxuICogICAgIDxkaXY+e3sgZXZlbiB9fTwvZGl2PlxuICogICAgIDxkaXY+e3sgb2RkIH19PC9kaXY+XG4gKiAgIDwvZGl2PlxuICogPC9yeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAqIGBgYFxuICpcbiAqIEBkb2NzQ2F0ZWdvcnkgUnhWaXJ0dWFsRm9yXG4gKiBAZG9jc1BhZ2UgUnhWaXJ0dWFsRm9yXG4gKiBAcHVibGljQXBpXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tyeFZpcnR1YWxGb3JdW3J4VmlydHVhbEZvck9mXScsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogUnhWaXJ0dWFsVmlld1JlcGVhdGVyLCB1c2VFeGlzdGluZzogUnhWaXJ0dWFsRm9yIH1dLFxuICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBSeFZpcnR1YWxGb3I8VCwgVSBleHRlbmRzIE5nSXRlcmFibGU8VD4gPSBOZ0l0ZXJhYmxlPFQ+PlxuICBpbXBsZW1lbnRzIFJ4VmlydHVhbFZpZXdSZXBlYXRlcjxUPiwgT25Jbml0LCBEb0NoZWNrLCBPbkRlc3Ryb3lcbntcbiAgcHJpdmF0ZSByZWFkb25seSBzY3JvbGxTdHJhdGVneSA9IGluamVjdChSeFZpcnR1YWxTY3JvbGxTdHJhdGVneTxULCBVPik7XG4gIHByaXZhdGUgcmVhZG9ubHkgaXRlcmFibGVEaWZmZXJzID0gaW5qZWN0KEl0ZXJhYmxlRGlmZmVycyk7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2RSZWYgPSBpbmplY3QoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICBwcml2YXRlIHJlYWRvbmx5IG5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgaW5qZWN0b3IgPSBpbmplY3QoSW5qZWN0b3IpO1xuICByZWFkb25seSB2aWV3Q29udGFpbmVyID0gaW5qZWN0KFZpZXdDb250YWluZXJSZWYpO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0cmF0ZWd5UHJvdmlkZXIgPSBpbmplY3QoUnhTdHJhdGVneVByb3ZpZGVyKTtcbiAgcHJpdmF0ZSByZWFkb25seSBlcnJvckhhbmRsZXIgPSBpbmplY3QoRXJyb3JIYW5kbGVyKTtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0cz8gPSBpbmplY3QoUlhfVklSVFVBTF9TQ1JPTExfREVGQVVMVF9PUFRJT05TLCB7XG4gICAgb3B0aW9uYWw6IHRydWUsXG4gIH0pO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfZGlmZmVyPzogSXRlcmFibGVEaWZmZXI8VD47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHBhcnRpYWxseUZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0YXRpY1ZhbHVlPzogVTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHJlbmRlclN0YXRpYyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGl0ZXJhYmxlIGlucHV0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxyeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAgICogICA8YXBwLWhlcm8gKnJ4VmlydHVhbEZvcj1cImhlcm9lcyQ7IGxldCBoZXJvXCJcbiAgICogICAgIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiA8L3J4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgKlxuICAgKiBAcGFyYW0gcG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgcnhWaXJ0dWFsRm9yT2YoXG4gICAgcG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlOlxuICAgICAgfCBPYnNlcnZhYmxlPChVICYgTmdJdGVyYWJsZTxUPikgfCB1bmRlZmluZWQgfCBudWxsPlxuICAgICAgfCBTaWduYWw8KFUgJiBOZ0l0ZXJhYmxlPFQ+KSB8IHVuZGVmaW5lZCB8IG51bGw+XG4gICAgICB8IChVICYgTmdJdGVyYWJsZTxUPilcbiAgICAgIHwgbnVsbFxuICAgICAgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGlmIChpc1NpZ25hbChwb3RlbnRpYWxTaWduYWxPck9ic2VydmFibGUpKSB7XG4gICAgICB0aGlzLnN0YXRpY1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZW5kZXJTdGF0aWMgPSBmYWxzZTtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMkLm5leHQoXG4gICAgICAgIHRvT2JzZXJ2YWJsZShwb3RlbnRpYWxTaWduYWxPck9ic2VydmFibGUsIHsgaW5qZWN0b3I6IHRoaXMuaW5qZWN0b3IgfSksXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzT2JzZXJ2YWJsZShwb3RlbnRpYWxTaWduYWxPck9ic2VydmFibGUpKSB7XG4gICAgICB0aGlzLnN0YXRpY1ZhbHVlID0gcG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlO1xuICAgICAgdGhpcy5yZW5kZXJTdGF0aWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRpY1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZW5kZXJTdGF0aWMgPSBmYWxzZTtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMkLm5leHQocG90ZW50aWFsU2lnbmFsT3JPYnNlcnZhYmxlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZW1wbGF0ZSB0aGF0IGlzIGNyZWF0ZWQgZm9yIGVhY2ggaXRlbSBpbiB0aGUgaXRlcmFibGUuXG4gICAqIEBzZWUgW3RlbXBsYXRlIHJlZmVyZW5jZSB2YXJpYWJsZV0oZ3VpZGUvdGVtcGxhdGUtcmVmZXJlbmNlLXZhcmlhYmxlcylcbiAgICogKGluc3BpcmVkIGJ5IEBhbmd1bGFyL2NvbW1vbiBgbmdfZm9yX29mLnRzYClcbiAgICovXG4gIHByaXZhdGUgX3RlbXBsYXRlPzogVGVtcGxhdGVSZWY8UnhWaXJ0dWFsRm9yVmlld0NvbnRleHQ8VCwgVT4+O1xuICBASW5wdXQoKVxuICBzZXQgcnhWaXJ0dWFsRm9yVGVtcGxhdGUodmFsdWU6IFRlbXBsYXRlUmVmPFJ4VmlydHVhbEZvclZpZXdDb250ZXh0PFQsIFU+Pikge1xuICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RyYXRlZ3lIYW5kbGVyID0gc3RyYXRlZ3lIYW5kbGluZyhcbiAgICB0aGlzLnN0cmF0ZWd5UHJvdmlkZXIucHJpbWFyeVN0cmF0ZWd5LFxuICAgIHRoaXMuc3RyYXRlZ3lQcm92aWRlci5zdHJhdGVnaWVzLFxuICApO1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSByZW5kZXJpbmcgc3RyYXRlZ3kgdG8gYmUgdXNlZCB0byByZW5kZXIgdXBkYXRlcyB0byB0aGUgRE9NLlxuICAgKiBVc2UgaXQgdG8gZHluYW1pY2FsbHkgbWFuYWdlIHlvdXIgcmVuZGVyaW5nIHN0cmF0ZWd5LiBZb3UgY2FuIHN3aXRjaCB0aGUgc3RyYXRlZ3lcbiAgICogaW1wZXJhdGl2ZWx5ICh3aXRoIGEgc3RyaW5nKSBvciBieSBiaW5kaW5nIGFuIE9ic2VydmFibGUuXG4gICAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IGlzIGAnbm9ybWFsJ2AgaWYgbm90IGNvbmZpZ3VyZWQgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgICA8cngtdmlydHVhbC1zY3JvbGwtdmlld3BvcnQ+XG4gICAqICAgICAgIDxhcHAtaGVyb1xuICAgKiAgICAgICAgYXV0b3NpemVkXG4gICAqICAgICAgICAqcnhWaXJ0dWFsRm9yPVwibGV0IGhlcm8gb2YgaGVyb2VzJDsgc3RyYXRlZ3k6IHN0cmF0ZWd5XCJcbiAgICogICAgICAgIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiAgICAgPC9yeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAgICogICBgXG4gICAqIH0pXG4gICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgKiAgIHN0cmF0ZWd5ID0gJ2xvdyc7XG4gICAqIH1cbiAgICpcbiAgICogLy8gT1JcbiAgICpcbiAgICogXFxAQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgICogICB0ZW1wbGF0ZTogYFxuICAgKiAgICAgPHJ4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgKiAgICAgICA8YXBwLWhlcm9cbiAgICogICAgICAgIGF1dG9zaXplZFxuICAgKiAgICAgICAgKnJ4VmlydHVhbEZvcj1cImxldCBoZXJvIG9mIGhlcm9lcyQ7IHN0cmF0ZWd5OiBzdHJhdGVneSRcIlxuICAgKiAgICAgICAgW2hlcm9dPVwiaGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqICAgICA8L3J4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgc3RyYXRlZ3kkID0gbmV3IEJlaGF2aW9yU3ViamVjdCgnaW1tZWRpYXRlJyk7XG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHN0cmF0ZWd5TmFtZVxuICAgKiBAc2VlIHtAbGluayBzdHJhdGVnaWVzfVxuICAgKi9cbiAgQElucHV0KCdyeFZpcnR1YWxGb3JTdHJhdGVneScpXG4gIHNldCBzdHJhdGVneShcbiAgICBzdHJhdGVneU5hbWU6IFJ4U3RyYXRlZ3lOYW1lczxzdHJpbmc+IHwgT2JzZXJ2YWJsZTxSeFN0cmF0ZWd5TmFtZXM8c3RyaW5nPj4sXG4gICkge1xuICAgIHRoaXMuc3RyYXRlZ3lIYW5kbGVyLm5leHQoc3RyYXRlZ3lOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ29udHJvbHMgdGhlIGFtb3VudCBpZiB2aWV3cyBoZWxkIGluIGNhY2hlIGZvciBsYXRlciByZS11c2Ugd2hlbiBhIHVzZXIgaXNcbiAgICogc2Nyb2xsaW5nIHRoZSBsaXN0LiBJZiB0aGlzIGlzIHNldCB0byAwLCBgcnhWaXJ0dWFsRm9yYCB3b24ndCBjYWNoZSBhbnkgdmlldyxcbiAgICogdGh1cyBkZXN0cm95aW5nICYgcmUtY3JlYXRpbmcgdmVyeSBvZnRlbiBvbiBzY3JvbGwgZXZlbnRzLlxuICAgKi9cbiAgQElucHV0KCdyeFZpcnR1YWxGb3JUZW1wbGF0ZUNhY2hlU2l6ZScpIHRlbXBsYXRlQ2FjaGVTaXplID1cbiAgICB0aGlzLmRlZmF1bHRzPy50ZW1wbGF0ZUNhY2hlU2l6ZSB8fCBERUZBVUxUX1RFTVBMQVRFX0NBQ0hFX1NJWkU7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgSWYgYHBhcmVudGAgaXMgc2V0IHRvIGB0cnVlYCAoZGVmYXVsdCB0byBgZmFsc2VgKSwgYCpyeFZpcnR1YWxGb3JgIHdpbGxcbiAgICogIGF1dG9tYXRpY2FsbHkgcnVuIGNoYW5nZS1kZXRlY3Rpb24gZm9yIGl0cyBwYXJlbnQgY29tcG9uZW50IHdoZW4gaXRzIHNjaGVkdWxlZFxuICAgKiAgdGFza3MgYXJlIGRvbmUgaW4gb3JkZXIgdG8gdXBkYXRlIGFueSBwZW5kaW5nIGBAQ29udGVudENoaWxkYCBvciBgQFZpZXdDaGlsZGBcbiAgICogIHJlbGF0aW9uIHRvIGJlIHVwZGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSB1cGRhdGVkIFZpZXdDb250YWluZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFxcQENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdhcHAtcm9vdCcsXG4gICAqICAgdGVtcGxhdGU6IGBcbiAgICogICA8cngtdmlydHVhbC1zY3JvbGwtdmlld3BvcnQ+XG4gICAqICAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgICpyeFZpcnR1YWxGb3I9XCJcbiAgICogICAgICAgICAgbGV0IGl0ZW0gb2YgaXRlbXMkO1xuICAgKiAgICAgICAgICB0cmFja0J5OiB0cmFja0l0ZW07XG4gICAqICAgICAgICAgIHBhcmVudDogdHJ1ZTtcbiAgICogICAgICAgIFwiXG4gICAqICAgICAgICBbaXRlbV09XCJpdGVtXCJcbiAgICogICAgICAgIGF1dG9zaXplZFxuICAgKiAgICAgID48L2FwcC1saXN0LWl0ZW0+XG4gICAqICAgIDwvcngtdmlydHVhbC1zY3JvbGwtdmlld3BvcnQ+XG4gICAqICAgYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICAvLyB0aG9zZSBxdWVyaWVzIHdvbid0IGJlIGluIHN5bmMgd2l0aCB3aGF0IGByeFZpcnR1YWxGb3JgIGlzIHJlbmRlcmluZ1xuICAgKiAgIC8vIHdoZW4gcGFyZW50IGlzIHNldCB0byBmYWxzZS5cbiAgICogICBcXEBWaWV3Q2hpbGRyZW4oQXBwTGlzdEl0ZW0pIGxpc3RJdGVtczogUXVlcnlMaXN0PEFwcExpc3RJdGVtPjtcbiAgICpcbiAgICogICBpdGVtcyQgPSBpdGVtU2VydmljZS5nZXRJdGVtcygpO1xuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSByZW5kZXJQYXJlbnRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdGhpcyBmbGFnIHdpbGwgYmUgZHJvcHBlZCBzb29uLCBhcyBpdCBpcyBubyBsb25nZXIgcmVxdWlyZWQgd2hlbiB1c2luZyBzaWduYWwgYmFzZWQgdmlldyAmIGNvbnRlbnQgcXVlcmllc1xuICAgKi9cbiAgQElucHV0KCdyeFZpcnR1YWxGb3JQYXJlbnQnKSByZW5kZXJQYXJlbnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZmxhZyB0byBjb250cm9sIHdoZXRoZXIgYCpyeFZpcnR1YWxGb3JgIHJlbmRlcmluZyBoYXBwZW5zIHdpdGhpblxuICAgKiBgTmdab25lYCBvciBub3QuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCB0byBgdHJ1ZWAgaWYgbm90IGNvbmZpZ3VyZWQgb3RoZXJ3aXNlLlxuICAgKiBJZiBgcGF0Y2hab25lYCBpcyBzZXQgdG8gYGZhbHNlYCBgKnJ4VmlydHVhbEZvcmAgd2lsbCBvcGVyYXRlIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiBgTmdab25lYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogXFxAQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgICogICB0ZW1wbGF0ZTogYFxuICAgKiAgICA8cngtdmlydHVhbC1zY3JvbGwtdmlld3BvcnQ+XG4gICAqICAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgICpyeFZpcnR1YWxGb3I9XCJcbiAgICogICAgICAgICAgbGV0IGl0ZW0gb2YgaXRlbXMkO1xuICAgKiAgICAgICAgICB0cmFja0J5OiB0cmFja0l0ZW07XG4gICAqICAgICAgICAgIHBhdGNoWm9uZTogZmFsc2U7XG4gICAqICAgICAgICBcIlxuICAgKiAgICAgICAgW2l0ZW1dPVwiaXRlbVwiXG4gICAqICAgICAgICBhdXRvc2l6ZWRcbiAgICogICAgICA+PC9hcHAtbGlzdC1pdGVtPlxuICAgKiAgICA8L3J4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgaXRlbXMkID0gaXRlbVNlcnZpY2UuZ2V0SXRlbXMoKTtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0gcGF0Y2hab25lXG4gICAqL1xuICBASW5wdXQoJ3J4VmlydHVhbEZvclBhdGNoWm9uZScpIHBhdGNoWm9uZSA9XG4gICAgdGhpcy5zdHJhdGVneVByb3ZpZGVyLmNvbmZpZy5wYXRjaFpvbmU7XG5cbiAgLypASW5wdXQoJ3J4VmlydHVhbEZvclRvbWJzdG9uZScpIHRvbWJzdG9uZTogVGVtcGxhdGVSZWY8XG4gICBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxUPlxuICAgPiB8IG51bGwgPSBudWxsOyovXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGZ1bmN0aW9uIG9yIGtleSB0aGF0IGRlZmluZXMgaG93IHRvIHRyYWNrIGNoYW5nZXMgZm9yIGl0ZW1zIGluIHRoZSBwcm92aWRlZFxuICAgKiBpdGVyYWJsZSBkYXRhLlxuICAgKlxuICAgKiBXaGVuIGl0ZW1zIGFyZSBhZGRlZCwgbW92ZWQsIG9yIHJlbW92ZWQgaW4gdGhlIGl0ZXJhYmxlLFxuICAgKiB0aGUgZGlyZWN0aXZlIG11c3QgcmUtcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBET00gbm9kZXMuXG4gICAqIFRvIG1pbmltaXplIG9wZXJhdGlvbnMgb24gdGhlIERPTSwgb25seSBub2RlcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgKiBhcmUgcmUtcmVuZGVyZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGByeFZpcnR1YWxGb3JgIGFzc3VtZXMgdGhhdCB0aGUgb2JqZWN0IGluc3RhbmNlIGlkZW50aWZpZXNcbiAgICogdGhlIG5vZGUgaW4gdGhlIGl0ZXJhYmxlIChlcXVhbGl0eSBjaGVjayBgPT09YCkuXG4gICAqIFdoZW4gYSBmdW5jdGlvbiBvciBrZXkgaXMgc3VwcGxpZWQsIGByeFZpcnR1YWxGb3JgIHVzZXMgdGhlIHJlc3VsdCB0byBpZGVudGlmeSB0aGUgaXRlbSBub2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgIDxyeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAgICogICAgICA8YXBwLWxpc3QtaXRlbVxuICAgKiAgICAgICAgKnJ4VmlydHVhbEZvcj1cIlxuICAgKiAgICAgICAgICBsZXQgaXRlbSBvZiBpdGVtcyQ7XG4gICAqICAgICAgICAgIHRyYWNrQnk6ICdpZCc7XG4gICAqICAgICAgICBcIlxuICAgKiAgICAgICAgYXV0b3NpemVkXG4gICAqICAgICAgICBbaXRlbV09XCJpdGVtXCJcbiAgICogICAgICA+XG4gICAqICAgICAgPC9hcHAtbGlzdC1pdGVtPlxuICAgKiAgICA8L3J4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgaXRlbXMkID0gaXRlbVNlcnZpY2UuZ2V0SXRlbXMoKTtcbiAgICogfVxuICAgKlxuICAgKiAvLyBPUlxuICAgKlxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgPHJ4LXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgKiAgICAgIDxhcHAtbGlzdC1pdGVtXG4gICAqICAgICAgICAqcnhWaXJ0dWFsRm9yPVwiXG4gICAqICAgICAgICAgIGxldCBpdGVtIG9mIGl0ZW1zJDtcbiAgICogICAgICAgICAgdHJhY2tCeTogdHJhY2tJdGVtO1xuICAgKiAgICAgICAgXCJcbiAgICogICAgICAgIGF1dG9zaXplZFxuICAgKiAgICAgICAgW2l0ZW1dPVwiaXRlbVwiXG4gICAqICAgICAgPlxuICAgKiAgICAgIDwvYXBwLWxpc3QtaXRlbT5cbiAgICogICAgPC9yeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAgICogICBgXG4gICAqIH0pXG4gICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgKiAgIGl0ZW1zJCA9IGl0ZW1TZXJ2aWNlLmdldEl0ZW1zKCk7XG4gICAqICAgdHJhY2tJdGVtID0gKGlkeCwgaXRlbSkgPT4gaXRlbS5pZDtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0gdHJhY2tCeUZuT3JLZXlcbiAgICovXG4gIEBJbnB1dCgncnhWaXJ0dWFsRm9yVHJhY2tCeScpXG4gIHNldCB0cmFja0J5KHRyYWNrQnlGbk9yS2V5OiBrZXlvZiBUIHwgVHJhY2tCeUZ1bmN0aW9uPFQ+KSB7XG4gICAgaWYgKFxuICAgICAgTkdfREVWX01PREUgJiZcbiAgICAgIHRyYWNrQnlGbk9yS2V5ICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB0cmFja0J5Rm5PcktleSAhPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiB0cmFja0J5Rm5PcktleSAhPT0gJ3N5bWJvbCcgJiZcbiAgICAgIHR5cGVvZiB0cmFja0J5Rm5PcktleSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgdHJhY2tCeSBtdXN0IGJlIHR5cGVvZiBmdW5jdGlvbiBvciBrZXlvZiBULCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0cmFja0J5Rm5PcktleSxcbiAgICAgICAgKX0uYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cmFja0J5Rm5PcktleSA9PSBudWxsKSB7XG4gICAgICB0aGlzLl90cmFja0J5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHJhY2tCeSA9XG4gICAgICAgIHR5cGVvZiB0cmFja0J5Rm5PcktleSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gKGksIGEpID0+IGFbdHJhY2tCeUZuT3JLZXldXG4gICAgICAgICAgOiB0cmFja0J5Rm5PcktleTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgYFN1YmplY3RgIHdoaWNoIGVtaXRzIHdoZW5ldmVyIGAqcnhWaXJ0dWFsRm9yYCBmaW5pc2hlZCByZW5kZXJpbmcgYVxuICAgKiBzZXQgb2YgY2hhbmdlcyB0byB0aGUgdmlldy5cbiAgICogVGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gcGVyZm9ybSBhY3Rpb25zIGV4YWN0bHkgYXQgdGhlIHRpbWluZyB3aGVuIHRoZVxuICAgKiB1cGRhdGVzIHBhc3NlZCBhcmUgcmVuZGVyZWQgdG8gdGhlIERPTS5cbiAgICogVGhlIGByZW5kZXJDYWxsYmFja2AgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IHJlbHkgb24gc3BlY2lmaWMgRE9NXG4gICAqIHByb3BlcnRpZXMgbGlrZSB0aGUgYGhlaWdodGAgb2YgYSB0YWJsZSBhZnRlciBhbGwgaXRlbXMgZ290IHJlbmRlcmVkLlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSB0aGUgcmVuZGVyQ2FsbGJhY2sgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIGFcbiAgICogdmlldyBzaG91bGQgYmUgdmlzaWJsZSBvciBub3QuIFRoaXMgd2F5IGRldmVsb3BlcnMgY2FuIGhpZGUgYSBsaXN0IGFzXG4gICAqIGxvbmcgYXMgaXQgaGFzIG5vdCBmaW5pc2hlZCByZW5kZXJpbmcuXG4gICAqXG4gICAqIFRoZSByZXN1bHQgb2YgdGhlIGByZW5kZXJDYWxsYmFja2Agd2lsbCBjb250YWluIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgc2V0XG4gICAqIG9mIGl0ZW1zIGluIHRoZSBpdGVyYWJsZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogXFxAQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgICogICB0ZW1wbGF0ZTogYFxuICAgKiAgICA8cngtdmlydHVhbC1zY3JvbGwtdmlld3BvcnQ+XG4gICAqICAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgICpyeFZpcnR1YWxGb3I9XCJcbiAgICogICAgICAgICAgbGV0IGl0ZW0gb2YgaXRlbXMkO1xuICAgKiAgICAgICAgICB0cmFja0J5OiB0cmFja0l0ZW07XG4gICAqICAgICAgICAgIHJlbmRlckNhbGxiYWNrOiBpdGVtc1JlbmRlcmVkO1xuICAgKiAgICAgICAgXCJcbiAgICogICAgICAgIGF1dG9zaXplZFxuICAgKiAgICAgICAgW2l0ZW1dPVwiaXRlbVwiXG4gICAqICAgICAgPlxuICAgKiAgICAgIDwvYXBwLWxpc3QtaXRlbT5cbiAgICogICAgPC9yeC12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAgICogICBgXG4gICAqIH0pXG4gICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgKiAgIGl0ZW1zJDogT2JzZXJ2YWJsZTxJdGVtW10+ID0gaXRlbVNlcnZpY2UuZ2V0SXRlbXMoKTtcbiAgICogICB0cmFja0l0ZW0gPSAoaWR4LCBpdGVtKSA9PiBpdGVtLmlkO1xuICAgKiAgIC8vIHRoaXMgZW1pdHMgd2hlbmV2ZXIgcnhWaXJ0dWFsRm9yIGZpbmlzaGVkIHJlbmRlcmluZyBjaGFuZ2VzXG4gICAqICAgaXRlbXNSZW5kZXJlZCA9IG5ldyBTdWJqZWN0PEl0ZW1bXT4oKTtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0gcmVuZGVyQ2FsbGJhY2tcbiAgICovXG4gIEBJbnB1dCgncnhWaXJ0dWFsRm9yUmVuZGVyQ2FsbGJhY2snKSBzZXQgcmVuZGVyQ2FsbGJhY2soXG4gICAgcmVuZGVyQ2FsbGJhY2s6IFN1YmplY3Q8VT4sXG4gICkge1xuICAgIHRoaXMuX3JlbmRlckNhbGxiYWNrID0gcmVuZGVyQ2FsbGJhY2s7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IHZpZXdzUmVuZGVyZWQkID0gbmV3IFN1YmplY3Q8XG4gICAgRW1iZWRkZWRWaWV3UmVmPFJ4VmlydHVhbEZvclZpZXdDb250ZXh0PFQsIFUsIFJ4TGlzdFZpZXdDb21wdXRlZENvbnRleHQ+PltdXG4gID4oKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSB2aWV3UmVuZGVyZWQkID0gbmV3IFN1YmplY3Q8e1xuICAgIHZpZXc6IEVtYmVkZGVkVmlld1JlZjxSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxULCBVPj47XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICBpdGVtOiBUO1xuICB9PigpO1xuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IHJlbmRlcmluZ1N0YXJ0JCA9IG5ldyBTdWJqZWN0PFNldDxudW1iZXI+PigpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBnZXQgdGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8UnhWaXJ0dWFsRm9yVmlld0NvbnRleHQ8VCwgVT4+IHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGUgfHwgdGhpcy50ZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvYnNlcnZhYmxlcyQgPSBuZXcgUmVwbGF5U3ViamVjdDxcbiAgICB8IE9ic2VydmFibGU8TmdJdGVyYWJsZTxUPiB8IG51bGwgfCB1bmRlZmluZWQ+XG4gICAgfCBOZ0l0ZXJhYmxlPFQ+XG4gICAgfCBudWxsXG4gICAgfCB1bmRlZmluZWRcbiAgPigxKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3JlbmRlckNhbGxiYWNrPzogU3ViamVjdDxVPjtcblxuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IHZhbHVlcyQgPSB0aGlzLm9ic2VydmFibGVzJC5waXBlKFxuICAgIGNvZXJjZU9ic2VydmFibGVXaXRoKCksXG4gICAgc3dpdGNoQWxsKCksXG4gICAgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSxcbiAgKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgdmFsdWVzPzogTmdJdGVyYWJsZTxUPiB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHRlbXBsYXRlTWFuYWdlciE6IFJ4VmlydHVhbExpc3RUZW1wbGF0ZU1hbmFnZXI8XG4gICAgVCxcbiAgICBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxULCBVPlxuICA+O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyYWNrQnk6IFRyYWNrQnlGdW5jdGlvbjxUPiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIG5nVGVtcGxhdGVDb250ZXh0R3VhcmQ8XG4gICAgVCxcbiAgICBVIGV4dGVuZHMgTmdJdGVyYWJsZTxUPiA9IE5nSXRlcmFibGU8VD4sXG4gICAgSyA9IGtleW9mIFQsXG4gID4oXG4gICAgZGlyOiBSeFZpcnR1YWxGb3I8VCwgVT4sXG4gICAgY3R4OiBhbnksXG4gICk6IGN0eCBpcyBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxULCBVLCBSeExpc3RWaWV3Q29tcHV0ZWRDb250ZXh0LCBLPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxULCBVPj4sXG4gICkge31cblxuICAvKiogQGludGVybmFsICovXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsdWVzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCkpLnN1YnNjcmliZSgodmFsdWVzKSA9PiB7XG4gICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9KTtcbiAgICB0aGlzLnRlbXBsYXRlTWFuYWdlciA9IGNyZWF0ZVZpcnR1YWxMaXN0VGVtcGxhdGVNYW5hZ2VyKHtcbiAgICAgIHZpZXdDb250YWluZXJSZWY6IHRoaXMudmlld0NvbnRhaW5lcixcbiAgICAgIHRlbXBsYXRlUmVmOiB0aGlzLnRlbXBsYXRlLFxuICAgICAgY3JlYXRlVmlld0NvbnRleHQ6IHRoaXMuY3JlYXRlVmlld0NvbnRleHQuYmluZCh0aGlzKSxcbiAgICAgIHVwZGF0ZVZpZXdDb250ZXh0OiB0aGlzLnVwZGF0ZVZpZXdDb250ZXh0LmJpbmQodGhpcyksXG4gICAgICB0ZW1wbGF0ZUNhY2hlU2l6ZTogdGhpcy50ZW1wbGF0ZUNhY2hlU2l6ZSxcbiAgICB9KTtcbiAgICAvLyBsZXQgdGhlIHNjcm9sbCBzdHJhdGVneSBpbml0aWFsaXplIGJlZm9yZVxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXIoKVxuICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSQpKVxuICAgICAgICAuc3Vic2NyaWJlKCh2KSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyQ2FsbGJhY2s/Lm5leHQodiBhcyBVKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJTdGF0aWMpIHtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMkLm5leHQodGhpcy5zdGF0aWNWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95JC5uZXh0KCk7XG4gICAgdGhpcy50ZW1wbGF0ZU1hbmFnZXIuZGV0YWNoKCk7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlcigpIHtcbiAgICByZXR1cm4gY29tYmluZUxhdGVzdDxbVFtdLCBMaXN0UmFuZ2UsIFJ4U3RyYXRlZ3lDcmVkZW50aWFsc10+KFtcbiAgICAgIHRoaXMudmFsdWVzJC5waXBlKFxuICAgICAgICBtYXAoKHZhbHVlcykgPT5cbiAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlcylcbiAgICAgICAgICAgID8gdmFsdWVzXG4gICAgICAgICAgICA6IHZhbHVlcyAhPSBudWxsXG4gICAgICAgICAgICAgID8gQXJyYXkuZnJvbSh2YWx1ZXMpXG4gICAgICAgICAgICAgIDogW10sXG4gICAgICAgICksXG4gICAgICApLFxuICAgICAgdGhpcy5zY3JvbGxTdHJhdGVneS5yZW5kZXJlZFJhbmdlJCxcbiAgICAgIHRoaXMuc3RyYXRlZ3lIYW5kbGVyLnN0cmF0ZWd5JC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLFxuICAgIF0pLnBpcGUoXG4gICAgICBzd2l0Y2hNYXAoKFtpdGVtcywgcmFuZ2UsIHN0cmF0ZWd5XSkgPT5cbiAgICAgICAgLy8gd2FpdCBmb3Igc2Nyb2xsU3RyYXRlZ3kgdG8gYmUgc3RhYmxlIHVudGlsIGNvbXB1dGluZyBuZXcgc3RhdGVcbiAgICAgICAgdGhpcy5zY3JvbGxTdHJhdGVneS5pc1N0YWJsZS5waXBlKFxuICAgICAgICAgIHRha2UoMSksXG4gICAgICAgICAgLy8gbWFwIGl0ZXJhYmxlIHRvIGxhdGVzdCBkaWZmXG4gICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhYmxlID0gaXRlbXMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmZXIgPSB0aGlzLmdldERpZmZlcihpdGVyYWJsZSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlczogSXRlcmFibGVDaGFuZ2VzPFQ+IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZGlmZmVyKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpYWxseUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEl0ZXJhYmxlID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGxldCBpID0gMCwgaWxlbiA9IHRoaXMudmlld0NvbnRhaW5lci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpIDwgaWxlbjtcbiAgICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld1JlZiA9IDxFbWJlZGRlZFZpZXdSZWY8YW55Pj4oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5nZXQoaSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmFibGVbaV0gPSB2aWV3UmVmLmNvbnRleHQuJGltcGxpY2l0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWZmZXIuZGlmZihjdXJyZW50SXRlcmFibGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYW5nZXMgPSBkaWZmZXIuZGlmZihpdGVyYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE5FVkVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdENoYW5nZXMgPSB0aGlzLnRlbXBsYXRlTWFuYWdlci5nZXRMaXN0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgaXRlcmFibGUsXG4gICAgICAgICAgICAgIGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IGxpc3RDaGFuZ2VzWzBdLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcblxuICAgICAgICAgICAgY29uc3QgaW5kaWNlc1RvUG9zaXRpb24gPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydGVkT3JSZW1vdmVkID0gbGlzdENoYW5nZXNbMV07XG4gICAgICAgICAgICBjb25zdCB3b3JrJCA9IHVwZGF0ZXMubWFwKChbaW5kZXgsIHdvcmssIHJlbW92ZWRdKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIGluZGljZXNUb1Bvc2l0aW9uLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG9uU3RyYXRlZ3koXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGUgPSB3b3JrKCk7XG4gICAgICAgICAgICAgICAgICBpZiAodXBkYXRlLnZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3UmVuZGVyZWQkLm5leHQodXBkYXRlIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IG5nWm9uZTogdGhpcy5wYXRjaFpvbmUgPyB0aGlzLm5nWm9uZSA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxseUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IG5vdGlmeVBhcmVudCA9IGluc2VydGVkT3JSZW1vdmVkICYmIHRoaXMucmVuZGVyUGFyZW50O1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdTdGFydCQubmV4dChpbmRpY2VzVG9Qb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChcbiAgICAgICAgICAgICAgLy8gZW1pdCBhZnRlciBhbGwgY2hhbmdlcyBhcmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAgd29yayQubGVuZ3RoID4gMCA/IHdvcmskIDogW29mKGl0ZXJhYmxlKV0sXG4gICAgICAgICAgICApLnBpcGUoXG4gICAgICAgICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZU1hbmFnZXIuc2V0SXRlbUNvdW50KGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdzUmVuZGVyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLnZpZXdDb250YWluZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmlld3NSZW5kZXJlZC5wdXNoKHRoaXMudmlld0NvbnRhaW5lci5nZXQoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdzUmVuZGVyZWQkLm5leHQodmlld3NSZW5kZXJlZCBhcyBhbnkpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbm90aWZ5UGFyZW50XG4gICAgICAgICAgICAgICAgPyBzd2l0Y2hNYXAoKHYpID0+XG4gICAgICAgICAgICAgICAgICAgIGNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICBvZih2KSxcbiAgICAgICAgICAgICAgICAgICAgICBvblN0cmF0ZWd5KFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgICAgKF8sIHdvcmssIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd29yayh0aGlzLmNkUmVmLCBvcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5nWm9uZTogdGhpcy5wYXRjaFpvbmUgPyB0aGlzLm5nWm9uZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICh0aGlzLmNkUmVmIGFzIGFueSkuY29udGV4dCB8fCB0aGlzLmNkUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICApLnBpcGUoaWdub3JlRWxlbWVudHMoKSksXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAobyQpID0+IG8kLFxuICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKCksXG4gICAgICAgICAgICAgIG1hcCgoKSA9PiBpdGVyYWJsZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3IoKSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFcnJvcjxUPigpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VCB8IG51bGw+IHtcbiAgICByZXR1cm4gKG8kKSA9PlxuICAgICAgbyQucGlwZShcbiAgICAgICAgY2F0Y2hFcnJvcigoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMucGFydGlhbGx5RmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgfSksXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREaWZmZXIodmFsdWVzOiBOZ0l0ZXJhYmxlPFQ+KTogSXRlcmFibGVEaWZmZXI8VD4gfCBudWxsIHtcbiAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gICAgICA/ICh0aGlzLl9kaWZmZXIgPSB0aGlzLml0ZXJhYmxlRGlmZmVycy5maW5kKHZhbHVlcykuY3JlYXRlKHRoaXMuX3RyYWNrQnkpKVxuICAgICAgOiBudWxsO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGNyZWF0ZVZpZXdDb250ZXh0KFxuICAgIGl0ZW06IFQsXG4gICAgY29tcHV0ZWRDb250ZXh0OiBSeExpc3RWaWV3Q29tcHV0ZWRDb250ZXh0LFxuICApOiBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dDxULCBVLCBSeExpc3RWaWV3Q29tcHV0ZWRDb250ZXh0PiB7XG4gICAgcmV0dXJuIG5ldyBSeFZpcnR1YWxGb3JWaWV3Q29udGV4dChcbiAgICAgIGl0ZW0sXG4gICAgICB0aGlzLnZhbHVlcyEgYXMgVSxcbiAgICAgIGNvbXB1dGVkQ29udGV4dCxcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHVwZGF0ZVZpZXdDb250ZXh0KFxuICAgIGl0ZW06IFQsXG4gICAgdmlldzogRW1iZWRkZWRWaWV3UmVmPFxuICAgICAgUnhWaXJ0dWFsRm9yVmlld0NvbnRleHQ8VCwgVSwgUnhMaXN0Vmlld0NvbXB1dGVkQ29udGV4dD5cbiAgICA+LFxuICAgIGNvbXB1dGVkQ29udGV4dD86IFJ4TGlzdFZpZXdDb21wdXRlZENvbnRleHQsXG4gICk6IHZvaWQge1xuICAgIHZpZXcuY29udGV4dC51cGRhdGVDb250ZXh0KGNvbXB1dGVkQ29udGV4dCEpO1xuICAgIHZpZXcuY29udGV4dC4kaW1wbGljaXQgPSBpdGVtO1xuICAgIHZpZXcuY29udGV4dC5yeFZpcnR1YWxGb3JPZiA9IHRoaXMudmFsdWVzISBhcyBVO1xuICB9XG59XG4iXX0=