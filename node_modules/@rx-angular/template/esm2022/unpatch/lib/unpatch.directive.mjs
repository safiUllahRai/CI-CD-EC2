import { Directive, ElementRef, Input, } from '@angular/core';
import { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';
import { focusEvents, inputEvents, keyboardEvents, mouseEvents, touchEvents, wheelEvents, } from '@rx-angular/cdk/zone-configurations';
import { BehaviorSubject, Subscription } from 'rxjs';
import * as i0 from "@angular/core";
const zonePatchedEvents = [
    ...focusEvents,
    ...mouseEvents,
    ...wheelEvents,
    ...inputEvents,
    ...keyboardEvents,
    ...touchEvents,
];
/**
 *
 * @description
 *
 * This function takes an elem and event and re-applies the listeners from the passed event to the
 * passed element with the zone un-patched version of it.
 *
 * @param elem {HTMLElement} - The elem to re-apply the listeners to.
 * @param event {string} - The name of the event from which to re-apply the listeners.
 *
 * @returns void
 */
export function unpatchEventListener(element, event) {
    // `EventTarget` is patched only in the browser environment, thus
    // running this code on the server-side will throw an exception:
    // `TypeError: element.eventListeners is not a function`.
    if (typeof element.eventListeners !== 'function') {
        return;
    }
    const eventListeners = element.eventListeners(event);
    // Return if no event listeners are present
    if (!Array.isArray(eventListeners) || eventListeners.length === 0) {
        return;
    }
    const addEventListener = getZoneUnPatchedApi(element, 'addEventListener').bind(element);
    const listeners = [];
    eventListeners.forEach((listener) => {
        // Remove and reapply listeners with patched API
        element.removeEventListener(event, listener);
        // Reapply listeners with un-patched API
        addEventListener(event, listener);
        listeners.push(listener);
    });
    return listeners;
}
/**
 * @Directive RxUnpatch
 *
 * @description
 *
 * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid
 * of unnecessary renderings through zones `addEventListener` patches.
 * It can be used on any element you apply event bindings.
 *
 * The current way of binding events to the DOM is to use output bindings:
 *  ```html
 * <button (click)="doStuff($event)">click me</button>
 * ```
 *
 * The problem is that every event registered over `()` syntax, e.g. `(click)`
 * marks the component and all its ancestors as dirty and re-renders the whole component tree.
 * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.
 *
 * So even if your button is not related to a change that needs a re-render the app will re-render completely.
 * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'
 *
 * `unpatch` directive solves that problem.
 *
 * Included Features:
 *  - by default un-patch all registered listeners of the host it is applied on
 *  - un-patch only a specified set of registered event listeners
 *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)
 *  - Not interfering with any logic executed by the registered callback
 *
 * @usageNotes
 *
 * The `unpatch` directive can be used like shown here:
 * ```html
 * <button [unpatch] (click)="triggerSomeMethod($event)">click me</button>
 * <button [unpatch]="['mousemove']" (mousemove)="doStuff2($event)" (click)="doStuff($event)">click me</button>
 * ```
 *
 * @publicApi
 */
export class RxUnpatch {
    host;
    /**
     * @description
     * List of events that the element should be unpatched from. When input is empty or undefined,
     * the element is unpatched from all zone-patched events.
     *
     * Full list of zone-patched browser events can be found in
     * [this document](https://github.com/angular/angular/blob/master/packages/zone.js/STANDARD-APIS.md#browser).
     *
     */
    events;
    subscription = new Subscription();
    events$ = new BehaviorSubject(zonePatchedEvents);
    listeners = new Map();
    constructor(host) {
        this.host = host;
    }
    ngOnChanges({ events }) {
        if (events && Array.isArray(this.events)) {
            this.events$.next(this.events);
        }
    }
    ngAfterViewInit() {
        this.subscription = this.events$.subscribe((events) => {
            this.reapplyUnPatchedEventListeners(events);
        });
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        for (const [event, listeners = []] of this.listeners) {
            listeners.forEach((listener) => {
                this.host.nativeElement.removeEventListener(event, listener);
            });
        }
    }
    reapplyUnPatchedEventListeners(events) {
        for (const event of events) {
            const listeners = unpatchEventListener(this.host.nativeElement, event);
            this.listeners.set(event, listeners);
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxUnpatch, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: RxUnpatch, isStandalone: true, selector: "[unpatch]", inputs: { events: ["unpatch", "events"] }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxUnpatch, decorators: [{
            type: Directive,
            args: [{ selector: '[unpatch]', standalone: true }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { events: [{
                type: Input,
                args: ['unpatch']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5wYXRjaC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL3RlbXBsYXRlL3VucGF0Y2gvc3JjL2xpYi91bnBhdGNoLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEdBSU4sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDckUsT0FBTyxFQUNMLFdBQVcsRUFDWCxXQUFXLEVBQ1gsY0FBYyxFQUNkLFdBQVcsRUFDWCxXQUFXLEVBQ1gsV0FBVyxHQUNaLE1BQU0scUNBQXFDLENBQUM7QUFDN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBRXJELE1BQU0saUJBQWlCLEdBQWE7SUFDbEMsR0FBRyxXQUFXO0lBQ2QsR0FBRyxXQUFXO0lBQ2QsR0FBRyxXQUFXO0lBQ2QsR0FBRyxXQUFXO0lBQ2QsR0FBRyxjQUFjO0lBQ2pCLEdBQUcsV0FBVztDQUNmLENBQUM7QUFFRjs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsT0FFQyxFQUNELEtBQWE7SUFFYixpRUFBaUU7SUFDakUsZ0VBQWdFO0lBQ2hFLHlEQUF5RDtJQUN6RCxJQUFJLE9BQU8sT0FBTyxDQUFDLGNBQWMsS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUNqRCxPQUFPO0lBQ1QsQ0FBQztJQUVELE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFckQsMkNBQTJDO0lBQzNDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDbEUsT0FBTztJQUNULENBQUM7SUFFRCxNQUFNLGdCQUFnQixHQUFHLG1CQUFtQixDQUMxQyxPQUFPLEVBQ1Asa0JBQWtCLENBQ25CLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBb0MsQ0FBQztJQUVuRCxNQUFNLFNBQVMsR0FBeUMsRUFBRSxDQUFDO0lBQzNELGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtRQUNsQyxnREFBZ0Q7UUFDaEQsT0FBTyxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM3Qyx3Q0FBd0M7UUFDeEMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRWxDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0NHO0FBRUgsTUFBTSxPQUFPLFNBQVM7SUFnQkE7SUFmcEI7Ozs7Ozs7O09BUUc7SUFDZSxNQUFNLENBQVk7SUFFNUIsWUFBWSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7SUFDbEMsT0FBTyxHQUFHLElBQUksZUFBZSxDQUFXLGlCQUFpQixDQUFDLENBQUM7SUFDM0QsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFnRCxDQUFDO0lBRTVFLFlBQW9CLElBQTZCO1FBQTdCLFNBQUksR0FBSixJQUFJLENBQXlCO0lBQUcsQ0FBQztJQUVyRCxXQUFXLENBQUMsRUFBRSxNQUFNLEVBQWlCO1FBQ25DLElBQUksTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDekMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLENBQUM7SUFDSCxDQUFDO0lBRUQsZUFBZTtRQUNiLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNwRCxJQUFJLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFaEMsS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFFLFNBQVMsR0FBRyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDckQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO2dCQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDL0QsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVPLDhCQUE4QixDQUFDLE1BQWdCO1FBQ3JELEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLENBQUM7WUFDM0IsTUFBTSxTQUFTLEdBQUcsb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDdkUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7SUFDSCxDQUFDOzBIQTdDVSxTQUFTOzhHQUFULFNBQVM7OzJGQUFULFNBQVM7a0JBRHJCLFNBQVM7bUJBQUMsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUU7K0VBV2xDLE1BQU07c0JBQXZCLEtBQUs7dUJBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBTaW1wbGVDaGFuZ2VzLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGdldFpvbmVVblBhdGNoZWRBcGkgfSBmcm9tICdAcngtYW5ndWxhci9jZGsvaW50ZXJuYWxzL2NvcmUnO1xuaW1wb3J0IHtcbiAgZm9jdXNFdmVudHMsXG4gIGlucHV0RXZlbnRzLFxuICBrZXlib2FyZEV2ZW50cyxcbiAgbW91c2VFdmVudHMsXG4gIHRvdWNoRXZlbnRzLFxuICB3aGVlbEV2ZW50cyxcbn0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3pvbmUtY29uZmlndXJhdGlvbnMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuY29uc3Qgem9uZVBhdGNoZWRFdmVudHM6IHN0cmluZ1tdID0gW1xuICAuLi5mb2N1c0V2ZW50cyxcbiAgLi4ubW91c2VFdmVudHMsXG4gIC4uLndoZWVsRXZlbnRzLFxuICAuLi5pbnB1dEV2ZW50cyxcbiAgLi4ua2V5Ym9hcmRFdmVudHMsXG4gIC4uLnRvdWNoRXZlbnRzLFxuXTtcblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBlbGVtIGFuZCBldmVudCBhbmQgcmUtYXBwbGllcyB0aGUgbGlzdGVuZXJzIGZyb20gdGhlIHBhc3NlZCBldmVudCB0byB0aGVcbiAqIHBhc3NlZCBlbGVtZW50IHdpdGggdGhlIHpvbmUgdW4tcGF0Y2hlZCB2ZXJzaW9uIG9mIGl0LlxuICpcbiAqIEBwYXJhbSBlbGVtIHtIVE1MRWxlbWVudH0gLSBUaGUgZWxlbSB0byByZS1hcHBseSB0aGUgbGlzdGVuZXJzIHRvLlxuICogQHBhcmFtIGV2ZW50IHtzdHJpbmd9IC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGZyb20gd2hpY2ggdG8gcmUtYXBwbHkgdGhlIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhdGNoRXZlbnRMaXN0ZW5lcihcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQgJiB7XG4gICAgZXZlbnRMaXN0ZW5lcnM/OiAoZXZlbnQ6IHN0cmluZykgPT4gRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdFtdO1xuICB9LFxuICBldmVudDogc3RyaW5nXG4pOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0W10ge1xuICAvLyBgRXZlbnRUYXJnZXRgIGlzIHBhdGNoZWQgb25seSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCwgdGh1c1xuICAvLyBydW5uaW5nIHRoaXMgY29kZSBvbiB0aGUgc2VydmVyLXNpZGUgd2lsbCB0aHJvdyBhbiBleGNlcHRpb246XG4gIC8vIGBUeXBlRXJyb3I6IGVsZW1lbnQuZXZlbnRMaXN0ZW5lcnMgaXMgbm90IGEgZnVuY3Rpb25gLlxuICBpZiAodHlwZW9mIGVsZW1lbnQuZXZlbnRMaXN0ZW5lcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBldmVudExpc3RlbmVycyA9IGVsZW1lbnQuZXZlbnRMaXN0ZW5lcnMoZXZlbnQpO1xuXG4gIC8vIFJldHVybiBpZiBubyBldmVudCBsaXN0ZW5lcnMgYXJlIHByZXNlbnRcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50TGlzdGVuZXJzKSB8fCBldmVudExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhZGRFdmVudExpc3RlbmVyID0gZ2V0Wm9uZVVuUGF0Y2hlZEFwaShcbiAgICBlbGVtZW50LFxuICAgICdhZGRFdmVudExpc3RlbmVyJ1xuICApLmJpbmQoZWxlbWVudCkgYXMgdHlwZW9mIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICBjb25zdCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3RbXSA9IFtdO1xuICBldmVudExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgIC8vIFJlbW92ZSBhbmQgcmVhcHBseSBsaXN0ZW5lcnMgd2l0aCBwYXRjaGVkIEFQSVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIC8vIFJlYXBwbHkgbGlzdGVuZXJzIHdpdGggdW4tcGF0Y2hlZCBBUElcbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH0pO1xuXG4gIHJldHVybiBsaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogQERpcmVjdGl2ZSBSeFVucGF0Y2hcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGUgYHVucGF0Y2hgIGRpcmVjdGl2ZSBoZWxwcyBpbiBwYXJ0aWFsbHkgbWlncmF0aW5nIHRvIHpvbmUtbGVzcyBhcHBzIGFzIHdlbGwgYXMgZ2V0dGluZyByaWRcbiAqIG9mIHVubmVjZXNzYXJ5IHJlbmRlcmluZ3MgdGhyb3VnaCB6b25lcyBgYWRkRXZlbnRMaXN0ZW5lcmAgcGF0Y2hlcy5cbiAqIEl0IGNhbiBiZSB1c2VkIG9uIGFueSBlbGVtZW50IHlvdSBhcHBseSBldmVudCBiaW5kaW5ncy5cbiAqXG4gKiBUaGUgY3VycmVudCB3YXkgb2YgYmluZGluZyBldmVudHMgdG8gdGhlIERPTSBpcyB0byB1c2Ugb3V0cHV0IGJpbmRpbmdzOlxuICogIGBgYGh0bWxcbiAqIDxidXR0b24gKGNsaWNrKT1cImRvU3R1ZmYoJGV2ZW50KVwiPmNsaWNrIG1lPC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBUaGUgcHJvYmxlbSBpcyB0aGF0IGV2ZXJ5IGV2ZW50IHJlZ2lzdGVyZWQgb3ZlciBgKClgIHN5bnRheCwgZS5nLiBgKGNsaWNrKWBcbiAqIG1hcmtzIHRoZSBjb21wb25lbnQgYW5kIGFsbCBpdHMgYW5jZXN0b3JzIGFzIGRpcnR5IGFuZCByZS1yZW5kZXJzIHRoZSB3aG9sZSBjb21wb25lbnQgdHJlZS5cbiAqIFRoaXMgaXMgYmVjYXVzZSB6b25lLmpzIHBhdGNoZXMgdGhlIG5hdGl2ZSBicm93c2VyIEFQSSBhbmQgd2hlbmV2ZXIgb25lIG9mIHRoZSBwYXRjaGVkIEFQSXMgaXMgdXNlZCBpdCByZS1yZW5kZXJzLlxuICpcbiAqIFNvIGV2ZW4gaWYgeW91ciBidXR0b24gaXMgbm90IHJlbGF0ZWQgdG8gYSBjaGFuZ2UgdGhhdCBuZWVkcyBhIHJlLXJlbmRlciB0aGUgYXBwIHdpbGwgcmUtcmVuZGVyIGNvbXBsZXRlbHkuXG4gKiBUaGlzIGxlYWRzIHRvIGJhZCBwZXJmb3JtYW5jZS4gVGhpcyBpcyBlc3BlY2lhbGx5IGhlbHBmdWwgaWYgeW91IHdvcmsgd2l0aCBmcmVxdWVudGx5IGZpcmVkIGV2ZW50cyBsaWtlICdtb3VzZW1vdmUnXG4gKlxuICogYHVucGF0Y2hgIGRpcmVjdGl2ZSBzb2x2ZXMgdGhhdCBwcm9ibGVtLlxuICpcbiAqIEluY2x1ZGVkIEZlYXR1cmVzOlxuICogIC0gYnkgZGVmYXVsdCB1bi1wYXRjaCBhbGwgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMgb2YgdGhlIGhvc3QgaXQgaXMgYXBwbGllZCBvblxuICogIC0gdW4tcGF0Y2ggb25seSBhIHNwZWNpZmllZCBzZXQgb2YgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnNcbiAqICAtIHdvcmtzIHpvbmUgaW5kZXBlbmRlbnQgKGl0IGRpcmVjdGx5IGNoZWNrcyB0aGUgd2lkb3cgZm9yIHBhdGNoZWQgQVBJcyBhbmQgdW4tcGF0Y2hlcyB0aGVtIHdpdGhvdXQgdGhlIHVzZSBvZiBgcnVuT3V0c2lkZVpvbmVgIHdoaWNoIGJyaW5ncyBtb3JlIHBlcmZvcm1hbmNlKVxuICogIC0gTm90IGludGVyZmVyaW5nIHdpdGggYW55IGxvZ2ljIGV4ZWN1dGVkIGJ5IHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiBUaGUgYHVucGF0Y2hgIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBsaWtlIHNob3duIGhlcmU6XG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFt1bnBhdGNoXSAoY2xpY2spPVwidHJpZ2dlclNvbWVNZXRob2QoJGV2ZW50KVwiPmNsaWNrIG1lPC9idXR0b24+XG4gKiA8YnV0dG9uIFt1bnBhdGNoXT1cIlsnbW91c2Vtb3ZlJ11cIiAobW91c2Vtb3ZlKT1cImRvU3R1ZmYyKCRldmVudClcIiAoY2xpY2spPVwiZG9TdHVmZigkZXZlbnQpXCI+Y2xpY2sgbWU8L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW3VucGF0Y2hdJywgc3RhbmRhbG9uZTogdHJ1ZSB9KVxuZXhwb3J0IGNsYXNzIFJ4VW5wYXRjaCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBMaXN0IG9mIGV2ZW50cyB0aGF0IHRoZSBlbGVtZW50IHNob3VsZCBiZSB1bnBhdGNoZWQgZnJvbS4gV2hlbiBpbnB1dCBpcyBlbXB0eSBvciB1bmRlZmluZWQsXG4gICAqIHRoZSBlbGVtZW50IGlzIHVucGF0Y2hlZCBmcm9tIGFsbCB6b25lLXBhdGNoZWQgZXZlbnRzLlxuICAgKlxuICAgKiBGdWxsIGxpc3Qgb2Ygem9uZS1wYXRjaGVkIGJyb3dzZXIgZXZlbnRzIGNhbiBiZSBmb3VuZCBpblxuICAgKiBbdGhpcyBkb2N1bWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL21hc3Rlci9wYWNrYWdlcy96b25lLmpzL1NUQU5EQVJELUFQSVMubWQjYnJvd3NlcikuXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ3VucGF0Y2gnKSBldmVudHM/OiBzdHJpbmdbXTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgcHJpdmF0ZSBldmVudHMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT4oem9uZVBhdGNoZWRFdmVudHMpO1xuICBwcml2YXRlIGxpc3RlbmVycyA9IG5ldyBNYXA8c3RyaW5nLCBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0W10+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBob3N0OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Pikge31cblxuICBuZ09uQ2hhbmdlcyh7IGV2ZW50cyB9OiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGV2ZW50cyAmJiBBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzKSkge1xuICAgICAgdGhpcy5ldmVudHMkLm5leHQodGhpcy5ldmVudHMpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRzJC5zdWJzY3JpYmUoKGV2ZW50cykgPT4ge1xuICAgICAgdGhpcy5yZWFwcGx5VW5QYXRjaGVkRXZlbnRMaXN0ZW5lcnMoZXZlbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cbiAgICBmb3IgKGNvbnN0IFtldmVudCwgbGlzdGVuZXJzID0gW11dIG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWFwcGx5VW5QYXRjaGVkRXZlbnRMaXN0ZW5lcnMoZXZlbnRzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB1bnBhdGNoRXZlbnRMaXN0ZW5lcih0aGlzLmhvc3QubmF0aXZlRWxlbWVudCwgZXZlbnQpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KGV2ZW50LCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgfVxufVxuIl19