import { ChangeDetectorRef, Directive, ErrorHandler, inject, Injector, Input, isSignal, NgZone, Output, TemplateRef, ViewContainerRef, } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { coerceAllFactory } from '@rx-angular/cdk/coercing';
import { createTemplateNotifier, } from '@rx-angular/cdk/notifications';
import { RxStrategyProvider, } from '@rx-angular/cdk/render-strategies';
import { createTemplateManager, RxBaseTemplateNames, } from '@rx-angular/cdk/template';
import { defer, merge, NEVER, Observable, ReplaySubject, Subject, Subscription, } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import * as i0 from "@angular/core";
/** @internal */
const RxLetTemplateNames = {
    ...RxBaseTemplateNames,
    next: 'nextTpl',
};
/**
 * @Directive RxLet
 *
 * @description
 * In Angular there is one way to handle asynchronous values or streams in the template, the `async` pipe.
 * Even though the async pipe evaluates such values in the template, it is insufficient in many ways.
 * To name a few:
 * * it will only update the template when `NgZone` is also aware of the value change
 * * it leads to over rendering because it can only run global change detection
 * * it leads to too many subscriptions in the template
 * * it is cumbersome to work with values in the template
 *
 * read more about the LetDirective in the [official docs](https://www.rx-angular.io/docs/template/api/let-directive)
 *
 * **Conclusion - Structural directives**
 *
 * In contrast to global change detection, structural directives allow fine-grained control of change detection on a per directive basis.
 * The `LetDirective` comes with its own way to handle change detection in templates in a very efficient way.
 * However, the change detection behavior is configurable on a per directive or global basis.
 * This makes it possible to implement your own strategies, and also provides a migration path from large existing apps running with Angulars default change detection.
 *
 * This package helps to reduce code used to create composable action streams.
 * It mostly is used in combination with state management libs to handle user interaction and backend communication.
 *
 * ```html
 * <ng-container *rxLet="observableNumber$; let n">
 *  ...
 * </ng-container>
 * ```
 *
 *
 * @docsCategory LetDirective
 * @docsPage LetDirective
 * @publicApi
 */
export class RxLet {
    templateRef;
    /** @internal */
    strategyProvider = inject(RxStrategyProvider);
    /** @internal */
    cdRef = inject(ChangeDetectorRef);
    injector = inject(Injector);
    /** @internal */
    ngZone = inject(NgZone);
    /** @internal */
    viewContainerRef = inject(ViewContainerRef);
    /** @internal */
    errorHandler = inject(ErrorHandler);
    static ngTemplateGuard_rxLet;
    /**
     * @description
     * The Observable or value to be bound to the context of a template.
     *
     * @example
     * const hero1 = {name: 'Batman'};
     * const hero$ = of(hero);
     *
     * <ng-container *rxLet="hero1; let hero">
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     *
     * <ng-container *rxLet="hero$; let hero">
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     *
     * @param { ObservableInput<U> | U | null | undefined } rxLet
     */
    rxLet;
    /**
     * @description
     *
     * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxLet`. It accepts
     * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).
     *
     * The default value for strategy is
     * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#use-render-strategies-strategy).
     *
     * @example
     *
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *     <ng-container *rxLet="hero$; let hero; strategy: strategy">
     *       <app-hero [hero]="hero"></app-hero>
     *     </ng-container>
     *
     *     <ng-container *rxLet="hero$; let hero; strategy: strategy$">
     *       <app-hero [hero]="hero"></app-hero>
     *     </ng-container>
     *   `
     * })
     * export class AppComponent {
     *   strategy = 'low';
     *   strategy$ = of('immediate');
     * }
     *
     * @param { string | Observable<string> | undefined } strategyName
     * @see {@link RxStrategyNames}
     */
    set strategy(strategyName) {
        this.strategyHandler.next(strategyName);
    }
    /**
     * @description
     * Defines the template for the complete state. Will be
     * shown when the bound Observable is in "complete" state.
     *
     * @example
     * <ng-container *rxLet="hero$; let hero; complete: completeTemplate">
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     * <ng-template #completeTemplate>
     *   <mat-icon>thumb_up</mat-icon>
     * </ng-template>
     *
     * @param { TemplateRef<RxLetViewContext<U | undefined | null> | null> } complete
     */
    complete;
    /**
     * @description
     * Defines the template for the error state. Will be
     * shown when the bound Observable is in "error" state.
     *
     * @example
     * <ng-container *rxLet="hero$; let hero; error: errorTemplate">
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     * <ng-template #errorTemplate>
     *   <mat-icon>thumb_down</mat-icon>
     * </ng-template>
     *
     * @param { TemplateRef<RxLetViewContext<U | undefined | null> | null> } error
     */
    error;
    /**
     * @description
     * Defines the template for the suspense state. Will be
     * shown when the bound Observable is in "suspense" state.
     * Suspense means any undefined value, a never emitted value or `NEVER` itself.
     *
     * @example
     * <ng-container *rxLet="hero$; let hero; suspense: suspenseTemplate">
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     * <ng-template #suspenseTemplate>
     *   <mat-progress-spinner></mat-progress-spinner>
     * </ng-template>
     *
     * @param { TemplateRef<RxLetViewContext<U | undefined | null> | null> } suspense
     */
    suspense;
    /**
     * @description
     * A trigger to manually set the active template. It accepts a `RxNotificationKind`
     * which determines what template to display. If no template is given, a context
     * variable resembling the notification state is put into the `Next`
     * template of the directive
     *
     * @example
     * <ng-container
     *  *rxLet="
     *    hero$;
     *    let hero;
     *    let e = error;
     *    contextTrigger: contextTrigger$
     * ">
     *
     *   <app-hero [hero]="hero"></app-hero>
     *   <error *ngIf="e"></error>
     * </ng-container>
     *
     * // trigger template from component.ts
     * contextTrigger$.next(RxNotificationKind.error)
     *
     * @param { Observable<RxNotificationKind> } contextTrigger
     * @see {@link RxNotificationKind}
     */
    contextTrigger;
    /**
     * @description
     * A trigger to manually activate the complete template. It accepts any value,
     * on emission it will display the error template. If no template is given,
     * the complete context variable will complete set to true instead.
     *
     * @example
     * <ng-container
     *  *rxLet="
     *    hero$;
     *    let hero;
     *    let c = complete;
     *    completeTrigger: completeTrigger$
     * ">
     *
     *   <app-hero [hero]="hero"></app-hero>
     *   <done *ngIf="c"></done>
     * </ng-container>
     *
     * // trigger template from component.ts
     * completeTrigger$.next()
     *
     * @param { Observable<unknown> } completeTrigger
     */
    completeTrigger;
    /**
     * @description
     * A trigger to manually activate the error template. It accepts any value,
     * on emission it will display the error template. If no template is given,
     * the error context variable will be set to true instead.
     *
     * @example
     * <ng-container
     *  *rxLet="
     *    hero$;
     *    let hero;
     *    let e = error;
     *    errorTrigger: errorTrigger$
     * ">
     *
     *   <app-hero [hero]="hero"></app-hero>
     *   <error *ngIf="e"></error>
     * </ng-container>
     *
     * // trigger template from component.ts
     * errorTrigger$.next()
     *
     * @param { Observable<unknown> } errorTrigger
     */
    errorTrigger;
    /**
     * @description
     * A trigger to manually activate the suspense template. It accepts any value,
     * on emission it will display the suspense template. If no template is given,
     * the suspense context variable will be set to true instead.
     *
     * @example
     * <ng-container
     *  *rxLet="
     *    hero$;
     *    let hero;
     *    let s = suspense;
     *    suspenseTrigger: suspenseTrigger$
     * ">
     *
     *   <app-hero [hero]="hero"></app-hero>
     *   <loader *ngIf="s"></loader>
     * </ng-container>
     *
     *
     * // trigger template from component.ts
     * suspenseTrigger$.next()
     *
     * @param { Observable<unknown> } suspenseTrigger
     */
    suspenseTrigger;
    /**
     * @description
     * A trigger to manually activate the default template. It accepts any value,
     * on emission it will switch to the let directives default template.
     *
     * @example
     * <ng-container
     *  *rxLet="
     *    hero$;
     *    let hero;
     *    suspense: suspense
     *    nextTrigger: nextTrigger$
     * ">
     *
     *   <app-hero [hero]="hero"></app-hero>
     * </ng-container>
     *
     * <ng-template #suspense><loader></loader></ng-template>
     *
     * // trigger template from component.ts
     * nextTrigger$.next()
     *
     * @param { Observable<unknown> } nextTrigger
     */
    nextTrigger;
    /**
     * @description
     * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.
     * This enables developers to perform actions when a list has finished rendering.
     * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a
     * table after all items got rendered.
     * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This
     * way developers can hide a list as long as it has not finished rendering.
     *
     * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.
     *
     * @example
     * \Component({
     *   selector: 'app-root',
     *   template: `
     *   <app-list-component>
     *     <app-list-item
     *       *rxFor="
     *         let item of items$;
     *         trackBy: trackItem;
     *         renderCallback: itemsRendered;
     *       ">
     *       <div>{{ item.name }}</div>
     *     </app-list-item>
     *   </app-list-component>
     * `
     * })
     * export class AppComponent {
     *   items$: Observable<Item[]> = itemService.getItems();
     *   trackItem = (idx, item) => item.id;
     *   // this emits whenever rxFor finished rendering changes
     *   itemsRendered = new Subject<Item[]>();
     *
     *   constructor(elementRef: ElementRef<HTMLElement>) {
     *     itemsRendered.subscribe(() => {
     *       // items are rendered, we can now scroll
     *       elementRef.scrollTo({bottom: 0});
     *     })
     *   }
     * }
     *
     * @param callback
     */
    set renderCallback(callback) {
        this._renderObserver = callback;
    }
    /**
     * @description
     *
     * When local rendering strategies are used, we need to treat view and content queries in a
     * special way.
     * To make `*rxLet` in such situations, a certain mechanism is implemented to
     * execute change detection on the parent (`parent`).
     *
     * This is required if your components state is dependent on its view or content children:
     *
     * - `@ViewChild`
     * - `@ViewChildren`
     * - `@ContentChild`
     * - `@ContentChildren`
     *
     * Read more about this in the
     * [official
     * docs](https://www.rx-angular.io/docs/template/api/let-directive#local-strategies-and-view-content-queries-parent).
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-list-component>
     *      <app-list-item
     *        *rxLet="
     *          item$;
     *          let item;
     *          parent: true;
     *        "
     *      >
     *        <div>{{ item.name }}</div>
     *      </app-list-item>
     *    </app-list-component>
     *   `
     * })
     * export class AppComponent {
     *   item$ = itemService.getItem();
     * }
     *
     * @param boolean
     *
     * @deprecated this flag will be dropped soon, as it is no longer required when using signal based view & content queries
     */
    renderParent = this.strategyProvider.config.parent;
    /**
     * @description
     * A flag to control whether *rxLet templates are created within `NgZone` or not.
     * The default value is `true, `*rxLet` will create it's `EmbeddedViews` inside `NgZone`.
     *
     * Event listeners normally trigger zone. Especially high frequently events cause performance issues.
     *
     * Read more about this in the
     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#working-with-event-listeners-patchzone).
     *
     * @example
     * \@Component({
     *   selector: 'app-root',
     *   template: `
     *    <app-list-component>
     *      <app-list-item
     *        *rxLet="
     *          item$;
     *          let item;
     *          patchZone: false;
     *        "
     *      >
     *        <div>{{ item.name }}</div>
     *      </app-list-item>
     *    </app-list-component>
     *   `
     * })
     * export class AppComponent {
     *   item$ = itemService.getItem();
     * }
     */
    patchZone = this.strategyProvider.config.patchZone;
    /** @internal */
    observablesHandler = createTemplateNotifier();
    /** @internal */
    strategyHandler = coerceAllFactory(() => new ReplaySubject(1));
    /** @internal */
    triggerHandler = new ReplaySubject(1);
    /** @internal */
    _renderObserver;
    /** @internal */
    subscription = new Subscription();
    /** @internal */
    templateManager;
    /** @internal */
    rendered$ = new Subject();
    /** @internal */
    templateNotification$ = new Subject();
    /** @internal */
    values$ = this.observablesHandler.values$;
    rendered = defer(() => this.rendered$);
    /** @internal */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    /** @internal */
    ngOnInit() {
        this.subscription.add(this.templateManager
            .render(merge(this.values$, this.templateNotification$))
            .subscribe((n) => {
            this.rendered$.next(n);
            this._renderObserver?.next(n);
        }));
        this.subscription.add(merge(this.contextTrigger || NEVER, this.nextTrigger?.pipe(map(() => "next" /* RxNotificationKind.Next */)) || NEVER, this.suspenseTrigger?.pipe(map(() => "suspense" /* RxNotificationKind.Suspense */)) ||
            NEVER, this.completeTrigger?.pipe(map(() => "complete" /* RxNotificationKind.Complete */)) ||
            NEVER, this.errorTrigger?.pipe(map(() => "error" /* RxNotificationKind.Error */)) || NEVER)
            .pipe(filter((v) => !!v))
            .subscribe((t) => this.triggerHandler.next(t)));
    }
    /** @internal */
    ngOnChanges(changes) {
        if (!this.templateManager) {
            this._createTemplateManager();
        }
        if (changes.complete) {
            this.templateManager.addTemplateRef(RxLetTemplateNames.complete, this.complete);
        }
        if (changes.suspense) {
            this.templateManager.addTemplateRef(RxLetTemplateNames.suspense, this.suspense);
            this.observablesHandler.withInitialSuspense(!!this.suspense);
        }
        if (changes.error) {
            this.templateManager.addTemplateRef(RxLetTemplateNames.error, this.error);
        }
        if (changes.rxLet) {
            if (isSignal(this.rxLet)) {
                this.observablesHandler.next(toObservable(this.rxLet, { injector: this.injector }));
            }
            else {
                this.observablesHandler.next(this.rxLet);
            }
        }
    }
    /** @internal */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /** @internal */
    _createTemplateManager() {
        this.templateManager = createTemplateManager({
            templateSettings: {
                viewContainerRef: this.viewContainerRef,
                customContext: (rxLet) => ({ rxLet }),
            },
            renderSettings: {
                cdRef: this.cdRef,
                parent: !!this.renderParent,
                patchZone: this.patchZone ? this.ngZone : false,
                defaultStrategyName: this.strategyProvider.primaryStrategy,
                strategies: this.strategyProvider.strategies,
                errorHandler: this.errorHandler,
            },
            notificationToTemplateName: {
                ["suspense" /* RxNotificationKind.Suspense */]: () => this.suspense ? RxLetTemplateNames.suspense : RxLetTemplateNames.next,
                ["next" /* RxNotificationKind.Next */]: () => RxLetTemplateNames.next,
                ["error" /* RxNotificationKind.Error */]: () => this.error ? RxLetTemplateNames.error : RxLetTemplateNames.next,
                ["complete" /* RxNotificationKind.Complete */]: () => this.complete ? RxLetTemplateNames.complete : RxLetTemplateNames.next,
            },
            templateTrigger$: this.triggerHandler,
        });
        this.templateManager.addTemplateRef(RxLetTemplateNames.next, this.templateRef);
        this.templateManager.nextStrategy(this.strategyHandler.values$);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxLet, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: RxLet, isStandalone: true, selector: "[rxLet]", inputs: { rxLet: "rxLet", strategy: ["rxLetStrategy", "strategy"], complete: ["rxLetComplete", "complete"], error: ["rxLetError", "error"], suspense: ["rxLetSuspense", "suspense"], contextTrigger: ["rxLetContextTrigger", "contextTrigger"], completeTrigger: ["rxLetCompleteTrigger", "completeTrigger"], errorTrigger: ["rxLetErrorTrigger", "errorTrigger"], suspenseTrigger: ["rxLetSuspenseTrigger", "suspenseTrigger"], nextTrigger: ["rxLetNextTrigger", "nextTrigger"], renderCallback: ["rxLetRenderCallback", "renderCallback"], renderParent: ["rxLetParent", "renderParent"], patchZone: ["rxLetPatchZone", "patchZone"] }, outputs: { rendered: "rendered" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxLet, decorators: [{
            type: Directive,
            args: [{ selector: '[rxLet]', standalone: true }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }], propDecorators: { rxLet: [{
                type: Input
            }], strategy: [{
                type: Input,
                args: ['rxLetStrategy']
            }], complete: [{
                type: Input,
                args: ['rxLetComplete']
            }], error: [{
                type: Input,
                args: ['rxLetError']
            }], suspense: [{
                type: Input,
                args: ['rxLetSuspense']
            }], contextTrigger: [{
                type: Input,
                args: ['rxLetContextTrigger']
            }], completeTrigger: [{
                type: Input,
                args: ['rxLetCompleteTrigger']
            }], errorTrigger: [{
                type: Input,
                args: ['rxLetErrorTrigger']
            }], suspenseTrigger: [{
                type: Input,
                args: ['rxLetSuspenseTrigger']
            }], nextTrigger: [{
                type: Input,
                args: ['rxLetNextTrigger']
            }], renderCallback: [{
                type: Input,
                args: ['rxLetRenderCallback']
            }], renderParent: [{
                type: Input,
                args: ['rxLetParent']
            }], patchZone: [{
                type: Input,
                args: ['rxLetPatchZone']
            }], rendered: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvdGVtcGxhdGUvbGV0L3NyYy9saWIvbGV0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxFQUNOLFFBQVEsRUFDUixLQUFLLEVBQ0wsUUFBUSxFQUNSLE1BQU0sRUFJTixNQUFNLEVBR04sV0FBVyxFQUNYLGdCQUFnQixHQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDNUQsT0FBTyxFQUNMLHNCQUFzQixHQUd2QixNQUFNLCtCQUErQixDQUFDO0FBQ3ZDLE9BQU8sRUFFTCxrQkFBa0IsR0FDbkIsTUFBTSxtQ0FBbUMsQ0FBQztBQUMzQyxPQUFPLEVBQ0wscUJBQXFCLEVBQ3JCLG1CQUFtQixHQUdwQixNQUFNLDBCQUEwQixDQUFDO0FBQ2xDLE9BQU8sRUFDTCxLQUFLLEVBQ0wsS0FBSyxFQUNMLEtBQUssRUFFTCxVQUFVLEVBRVYsYUFBYSxFQUNiLE9BQU8sRUFFUCxZQUFZLEdBQ2IsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUs3QyxnQkFBZ0I7QUFDaEIsTUFBTSxrQkFBa0IsR0FBRztJQUN6QixHQUFHLG1CQUFtQjtJQUN0QixJQUFJLEVBQUUsU0FBUztDQUNQLENBQUM7QUFRWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtDRztBQUVILE1BQU0sT0FBTyxLQUFLO0lBcWJJO0lBcGJwQixnQkFBZ0I7SUFDUixnQkFBZ0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMs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LGdCQUFnQjtnQkFpQ0osUUFBUTtzQkFBMUIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBEaXJlY3RpdmUsXG4gIEVycm9ySGFuZGxlcixcbiAgaW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIGlzU2lnbmFsLFxuICBOZ1pvbmUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgU2lnbmFsLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0b09ic2VydmFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQgeyBjb2VyY2VBbGxGYWN0b3J5IH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL2NvZXJjaW5nJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRlbXBsYXRlTm90aWZpZXIsXG4gIFJ4Tm90aWZpY2F0aW9uLFxuICBSeE5vdGlmaWNhdGlvbktpbmQsXG59IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7XG4gIFJ4U3RyYXRlZ3lOYW1lcyxcbiAgUnhTdHJhdGVneVByb3ZpZGVyLFxufSBmcm9tICdAcngtYW5ndWxhci9jZGsvcmVuZGVyLXN0cmF0ZWdpZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVtcGxhdGVNYW5hZ2VyLFxuICBSeEJhc2VUZW1wbGF0ZU5hbWVzLFxuICBSeFRlbXBsYXRlTWFuYWdlcixcbiAgUnhWaWV3Q29udGV4dCxcbn0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3RlbXBsYXRlJztcbmltcG9ydCB7XG4gIGRlZmVyLFxuICBtZXJnZSxcbiAgTkVWRVIsXG4gIE5leHRPYnNlcnZlcixcbiAgT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2YWJsZUlucHV0LFxuICBSZXBsYXlTdWJqZWN0LFxuICBTdWJqZWN0LFxuICBTdWJzY3JpYmFibGUsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqIEBpbnRlcm5hbCAqL1xudHlwZSBSeExldFRlbXBsYXRlTmFtZXMgPSAnbmV4dFRwbCcgfCBSeEJhc2VUZW1wbGF0ZU5hbWVzO1xuXG4vKiogQGludGVybmFsICovXG5jb25zdCBSeExldFRlbXBsYXRlTmFtZXMgPSB7XG4gIC4uLlJ4QmFzZVRlbXBsYXRlTmFtZXMsXG4gIG5leHQ6ICduZXh0VHBsJyxcbn0gYXMgY29uc3Q7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnhMZXRWaWV3Q29udGV4dDxUPiBleHRlbmRzIFJ4Vmlld0NvbnRleHQ8VD4ge1xuICAvLyB0byBlbmFibGUgYGFzYCBzeW50YXggd2UgaGF2ZSB0byBhc3NpZ24gdGhlIGRpcmVjdGl2ZXMgc2VsZWN0b3IgKHZhciBhcyB2KVxuICByeExldDogVDtcbn1cblxuLyoqXG4gKiBARGlyZWN0aXZlIFJ4TGV0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJbiBBbmd1bGFyIHRoZXJlIGlzIG9uZSB3YXkgdG8gaGFuZGxlIGFzeW5jaHJvbm91cyB2YWx1ZXMgb3Igc3RyZWFtcyBpbiB0aGUgdGVtcGxhdGUsIHRoZSBgYXN5bmNgIHBpcGUuXG4gKiBFdmVuIHRob3VnaCB0aGUgYXN5bmMgcGlwZSBldmFsdWF0ZXMgc3VjaCB2YWx1ZXMgaW4gdGhlIHRlbXBsYXRlLCBpdCBpcyBpbnN1ZmZpY2llbnQgaW4gbWFueSB3YXlzLlxuICogVG8gbmFtZSBhIGZldzpcbiAqICogaXQgd2lsbCBvbmx5IHVwZGF0ZSB0aGUgdGVtcGxhdGUgd2hlbiBgTmdab25lYCBpcyBhbHNvIGF3YXJlIG9mIHRoZSB2YWx1ZSBjaGFuZ2VcbiAqICogaXQgbGVhZHMgdG8gb3ZlciByZW5kZXJpbmcgYmVjYXVzZSBpdCBjYW4gb25seSBydW4gZ2xvYmFsIGNoYW5nZSBkZXRlY3Rpb25cbiAqICogaXQgbGVhZHMgdG8gdG9vIG1hbnkgc3Vic2NyaXB0aW9ucyBpbiB0aGUgdGVtcGxhdGVcbiAqICogaXQgaXMgY3VtYmVyc29tZSB0byB3b3JrIHdpdGggdmFsdWVzIGluIHRoZSB0ZW1wbGF0ZVxuICpcbiAqIHJlYWQgbW9yZSBhYm91dCB0aGUgTGV0RGlyZWN0aXZlIGluIHRoZSBbb2ZmaWNpYWwgZG9jc10oaHR0cHM6Ly93d3cucngtYW5ndWxhci5pby9kb2NzL3RlbXBsYXRlL2FwaS9sZXQtZGlyZWN0aXZlKVxuICpcbiAqICoqQ29uY2x1c2lvbiAtIFN0cnVjdHVyYWwgZGlyZWN0aXZlcyoqXG4gKlxuICogSW4gY29udHJhc3QgdG8gZ2xvYmFsIGNoYW5nZSBkZXRlY3Rpb24sIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBhbGxvdyBmaW5lLWdyYWluZWQgY29udHJvbCBvZiBjaGFuZ2UgZGV0ZWN0aW9uIG9uIGEgcGVyIGRpcmVjdGl2ZSBiYXNpcy5cbiAqIFRoZSBgTGV0RGlyZWN0aXZlYCBjb21lcyB3aXRoIGl0cyBvd24gd2F5IHRvIGhhbmRsZSBjaGFuZ2UgZGV0ZWN0aW9uIGluIHRlbXBsYXRlcyBpbiBhIHZlcnkgZWZmaWNpZW50IHdheS5cbiAqIEhvd2V2ZXIsIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGJlaGF2aW9yIGlzIGNvbmZpZ3VyYWJsZSBvbiBhIHBlciBkaXJlY3RpdmUgb3IgZ2xvYmFsIGJhc2lzLlxuICogVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSB0byBpbXBsZW1lbnQgeW91ciBvd24gc3RyYXRlZ2llcywgYW5kIGFsc28gcHJvdmlkZXMgYSBtaWdyYXRpb24gcGF0aCBmcm9tIGxhcmdlIGV4aXN0aW5nIGFwcHMgcnVubmluZyB3aXRoIEFuZ3VsYXJzIGRlZmF1bHQgY2hhbmdlIGRldGVjdGlvbi5cbiAqXG4gKiBUaGlzIHBhY2thZ2UgaGVscHMgdG8gcmVkdWNlIGNvZGUgdXNlZCB0byBjcmVhdGUgY29tcG9zYWJsZSBhY3Rpb24gc3RyZWFtcy5cbiAqIEl0IG1vc3RseSBpcyB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggc3RhdGUgbWFuYWdlbWVudCBsaWJzIHRvIGhhbmRsZSB1c2VyIGludGVyYWN0aW9uIGFuZCBiYWNrZW5kIGNvbW11bmljYXRpb24uXG4gKlxuICogYGBgaHRtbFxuICogPG5nLWNvbnRhaW5lciAqcnhMZXQ9XCJvYnNlcnZhYmxlTnVtYmVyJDsgbGV0IG5cIj5cbiAqICAuLi5cbiAqIDwvbmctY29udGFpbmVyPlxuICogYGBgXG4gKlxuICpcbiAqIEBkb2NzQ2F0ZWdvcnkgTGV0RGlyZWN0aXZlXG4gKiBAZG9jc1BhZ2UgTGV0RGlyZWN0aXZlXG4gKiBAcHVibGljQXBpXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tyeExldF0nLCBzdGFuZGFsb25lOiB0cnVlIH0pXG5leHBvcnQgY2xhc3MgUnhMZXQ8VT4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0cmF0ZWd5UHJvdmlkZXIgPSBpbmplY3QoUnhTdHJhdGVneVByb3ZpZGVyKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGNkUmVmID0gaW5qZWN0KENoYW5nZURldGVjdG9yUmVmKTtcblxuICBwcml2YXRlIGluamVjdG9yID0gaW5qZWN0KEluamVjdG9yKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZiA9IGluamVjdChWaWV3Q29udGFpbmVyUmVmKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGVycm9ySGFuZGxlciA9IGluamVjdChFcnJvckhhbmRsZXIpO1xuXG4gIHN0YXRpYyBuZ1RlbXBsYXRlR3VhcmRfcnhMZXQ6ICdiaW5kaW5nJztcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBPYnNlcnZhYmxlIG9yIHZhbHVlIHRvIGJlIGJvdW5kIHRvIHRoZSBjb250ZXh0IG9mIGEgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGhlcm8xID0ge25hbWU6ICdCYXRtYW4nfTtcbiAgICogY29uc3QgaGVybyQgPSBvZihoZXJvKTtcbiAgICpcbiAgICogPG5nLWNvbnRhaW5lciAqcnhMZXQ9XCJoZXJvMTsgbGV0IGhlcm9cIj5cbiAgICogICA8YXBwLWhlcm8gW2hlcm9dPVwiaGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqIDwvbmctY29udGFpbmVyPlxuICAgKlxuICAgKiA8bmctY29udGFpbmVyICpyeExldD1cImhlcm8kOyBsZXQgaGVyb1wiPlxuICAgKiAgIDxhcHAtaGVybyBbaGVyb109XCJoZXJvXCI+PC9hcHAtaGVybz5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqIEBwYXJhbSB7IE9ic2VydmFibGVJbnB1dDxVPiB8IFUgfCBudWxsIHwgdW5kZWZpbmVkIH0gcnhMZXRcbiAgICovXG4gIEBJbnB1dCgpIHJ4TGV0OlxuICAgIHwgT2JzZXJ2YWJsZUlucHV0PFU+XG4gICAgfCBTdWJzY3JpYmFibGU8VT5cbiAgICB8IFNpZ25hbDxVPlxuICAgIHwgVVxuICAgIHwgbnVsbFxuICAgIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogWW91IGNhbiBjaGFuZ2UgdGhlIHVzZWQgYFJlbmRlclN0cmF0ZWd5YCBieSB1c2luZyB0aGUgYHN0cmF0ZWd5YCBpbnB1dCBvZiB0aGUgYCpyeExldGAuIEl0IGFjY2VwdHNcbiAgICogYW4gYE9ic2VydmFibGU8UnhTdHJhdGVneU5hbWVzPmAgb3IgW2BSeFN0cmF0ZWd5TmFtZXNgXShodHRwczovL2dpdGh1Yi5jb20vcngtYW5ndWxhci9yeC1hbmd1bGFyL2Jsb2IvYjA2MzBmNjkwMTdjYzE4NzFkMDkzZTk3NjAwNjA2NmQ1ZjIwMDViOS9saWJzL2Nkay9yZW5kZXItc3RyYXRlZ2llcy9zcmMvbGliL21vZGVsLnRzI0w1MikuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBzdHJhdGVneSBpc1xuICAgKiBbYG5vcm1hbGBdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9jZGsvcmVuZGVyLXN0cmF0ZWdpZXMvc3RyYXRlZ2llcy9jb25jdXJyZW50LXN0cmF0ZWdpZXMpLlxuICAgKlxuICAgKiBSZWFkIG1vcmUgYWJvdXQgdGhpcyBpbiB0aGVcbiAgICogW29mZmljaWFsIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9hcGkvbGV0LWRpcmVjdGl2ZSN1c2UtcmVuZGVyLXN0cmF0ZWdpZXMtc3RyYXRlZ3kpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgICA8bmctY29udGFpbmVyICpyeExldD1cImhlcm8kOyBsZXQgaGVybzsgc3RyYXRlZ3k6IHN0cmF0ZWd5XCI+XG4gICAqICAgICAgIDxhcHAtaGVybyBbaGVyb109XCJoZXJvXCI+PC9hcHAtaGVybz5cbiAgICogICAgIDwvbmctY29udGFpbmVyPlxuICAgKlxuICAgKiAgICAgPG5nLWNvbnRhaW5lciAqcnhMZXQ9XCJoZXJvJDsgbGV0IGhlcm87IHN0cmF0ZWd5OiBzdHJhdGVneSRcIj5cbiAgICogICAgICAgPGFwcC1oZXJvIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiAgICAgPC9uZy1jb250YWluZXI+XG4gICAqICAgYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICBzdHJhdGVneSA9ICdsb3cnO1xuICAgKiAgIHN0cmF0ZWd5JCA9IG9mKCdpbW1lZGlhdGUnKTtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4gfCB1bmRlZmluZWQgfSBzdHJhdGVneU5hbWVcbiAgICogQHNlZSB7QGxpbmsgUnhTdHJhdGVneU5hbWVzfVxuICAgKi9cbiAgQElucHV0KCdyeExldFN0cmF0ZWd5JylcbiAgc2V0IHN0cmF0ZWd5KHN0cmF0ZWd5TmFtZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+IHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdHJhdGVneUhhbmRsZXIubmV4dChzdHJhdGVneU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGNvbXBsZXRlIHN0YXRlLiBXaWxsIGJlXG4gICAqIHNob3duIHdoZW4gdGhlIGJvdW5kIE9ic2VydmFibGUgaXMgaW4gXCJjb21wbGV0ZVwiIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8bmctY29udGFpbmVyICpyeExldD1cImhlcm8kOyBsZXQgaGVybzsgY29tcGxldGU6IGNvbXBsZXRlVGVtcGxhdGVcIj5cbiAgICogICA8YXBwLWhlcm8gW2hlcm9dPVwiaGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqIDwvbmctY29udGFpbmVyPlxuICAgKiA8bmctdGVtcGxhdGUgI2NvbXBsZXRlVGVtcGxhdGU+XG4gICAqICAgPG1hdC1pY29uPnRodW1iX3VwPC9tYXQtaWNvbj5cbiAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICpcbiAgICogQHBhcmFtIHsgVGVtcGxhdGVSZWY8UnhMZXRWaWV3Q29udGV4dDxVIHwgdW5kZWZpbmVkIHwgbnVsbD4gfCBudWxsPiB9IGNvbXBsZXRlXG4gICAqL1xuICBASW5wdXQoJ3J4TGV0Q29tcGxldGUnKVxuICBjb21wbGV0ZTogVGVtcGxhdGVSZWY8UnhMZXRWaWV3Q29udGV4dDxVIHwgdW5kZWZpbmVkIHwgbnVsbD4gfCBudWxsPjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciB0aGUgZXJyb3Igc3RhdGUuIFdpbGwgYmVcbiAgICogc2hvd24gd2hlbiB0aGUgYm91bmQgT2JzZXJ2YWJsZSBpcyBpbiBcImVycm9yXCIgc3RhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxuZy1jb250YWluZXIgKnJ4TGV0PVwiaGVybyQ7IGxldCBoZXJvOyBlcnJvcjogZXJyb3JUZW1wbGF0ZVwiPlxuICAgKiAgIDxhcHAtaGVybyBbaGVyb109XCJoZXJvXCI+PC9hcHAtaGVybz5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqIDxuZy10ZW1wbGF0ZSAjZXJyb3JUZW1wbGF0ZT5cbiAgICogICA8bWF0LWljb24+dGh1bWJfZG93bjwvbWF0LWljb24+XG4gICAqIDwvbmctdGVtcGxhdGU+XG4gICAqXG4gICAqIEBwYXJhbSB7IFRlbXBsYXRlUmVmPFJ4TGV0Vmlld0NvbnRleHQ8VSB8IHVuZGVmaW5lZCB8IG51bGw+IHwgbnVsbD4gfSBlcnJvclxuICAgKi9cbiAgQElucHV0KCdyeExldEVycm9yJylcbiAgZXJyb3I6IFRlbXBsYXRlUmVmPFJ4TGV0Vmlld0NvbnRleHQ8VSB8IHVuZGVmaW5lZCB8IG51bGw+IHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHN1c3BlbnNlIHN0YXRlLiBXaWxsIGJlXG4gICAqIHNob3duIHdoZW4gdGhlIGJvdW5kIE9ic2VydmFibGUgaXMgaW4gXCJzdXNwZW5zZVwiIHN0YXRlLlxuICAgKiBTdXNwZW5zZSBtZWFucyBhbnkgdW5kZWZpbmVkIHZhbHVlLCBhIG5ldmVyIGVtaXR0ZWQgdmFsdWUgb3IgYE5FVkVSYCBpdHNlbGYuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxuZy1jb250YWluZXIgKnJ4TGV0PVwiaGVybyQ7IGxldCBoZXJvOyBzdXNwZW5zZTogc3VzcGVuc2VUZW1wbGF0ZVwiPlxuICAgKiAgIDxhcHAtaGVybyBbaGVyb109XCJoZXJvXCI+PC9hcHAtaGVybz5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqIDxuZy10ZW1wbGF0ZSAjc3VzcGVuc2VUZW1wbGF0ZT5cbiAgICogICA8bWF0LXByb2dyZXNzLXNwaW5uZXI+PC9tYXQtcHJvZ3Jlc3Mtc3Bpbm5lcj5cbiAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICpcbiAgICogQHBhcmFtIHsgVGVtcGxhdGVSZWY8UnhMZXRWaWV3Q29udGV4dDxVIHwgdW5kZWZpbmVkIHwgbnVsbD4gfCBudWxsPiB9IHN1c3BlbnNlXG4gICAqL1xuICBASW5wdXQoJ3J4TGV0U3VzcGVuc2UnKVxuICBzdXNwZW5zZTogVGVtcGxhdGVSZWY8UnhMZXRWaWV3Q29udGV4dDxVIHwgdW5kZWZpbmVkIHwgbnVsbD4gfCBudWxsPjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgdHJpZ2dlciB0byBtYW51YWxseSBzZXQgdGhlIGFjdGl2ZSB0ZW1wbGF0ZS4gSXQgYWNjZXB0cyBhIGBSeE5vdGlmaWNhdGlvbktpbmRgXG4gICAqIHdoaWNoIGRldGVybWluZXMgd2hhdCB0ZW1wbGF0ZSB0byBkaXNwbGF5LiBJZiBubyB0ZW1wbGF0ZSBpcyBnaXZlbiwgYSBjb250ZXh0XG4gICAqIHZhcmlhYmxlIHJlc2VtYmxpbmcgdGhlIG5vdGlmaWNhdGlvbiBzdGF0ZSBpcyBwdXQgaW50byB0aGUgYE5leHRgXG4gICAqIHRlbXBsYXRlIG9mIHRoZSBkaXJlY3RpdmVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPG5nLWNvbnRhaW5lclxuICAgKiAgKnJ4TGV0PVwiXG4gICAqICAgIGhlcm8kO1xuICAgKiAgICBsZXQgaGVybztcbiAgICogICAgbGV0IGUgPSBlcnJvcjtcbiAgICogICAgY29udGV4dFRyaWdnZXI6IGNvbnRleHRUcmlnZ2VyJFxuICAgKiBcIj5cbiAgICpcbiAgICogICA8YXBwLWhlcm8gW2hlcm9dPVwiaGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqICAgPGVycm9yICpuZ0lmPVwiZVwiPjwvZXJyb3I+XG4gICAqIDwvbmctY29udGFpbmVyPlxuICAgKlxuICAgKiAvLyB0cmlnZ2VyIHRlbXBsYXRlIGZyb20gY29tcG9uZW50LnRzXG4gICAqIGNvbnRleHRUcmlnZ2VyJC5uZXh0KFJ4Tm90aWZpY2F0aW9uS2luZC5lcnJvcilcbiAgICpcbiAgICogQHBhcmFtIHsgT2JzZXJ2YWJsZTxSeE5vdGlmaWNhdGlvbktpbmQ+IH0gY29udGV4dFRyaWdnZXJcbiAgICogQHNlZSB7QGxpbmsgUnhOb3RpZmljYXRpb25LaW5kfVxuICAgKi9cbiAgQElucHV0KCdyeExldENvbnRleHRUcmlnZ2VyJykgY29udGV4dFRyaWdnZXI/OiBPYnNlcnZhYmxlPFJ4Tm90aWZpY2F0aW9uS2luZD47XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHRyaWdnZXIgdG8gbWFudWFsbHkgYWN0aXZhdGUgdGhlIGNvbXBsZXRlIHRlbXBsYXRlLiBJdCBhY2NlcHRzIGFueSB2YWx1ZSxcbiAgICogb24gZW1pc3Npb24gaXQgd2lsbCBkaXNwbGF5IHRoZSBlcnJvciB0ZW1wbGF0ZS4gSWYgbm8gdGVtcGxhdGUgaXMgZ2l2ZW4sXG4gICAqIHRoZSBjb21wbGV0ZSBjb250ZXh0IHZhcmlhYmxlIHdpbGwgY29tcGxldGUgc2V0IHRvIHRydWUgaW5zdGVhZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPG5nLWNvbnRhaW5lclxuICAgKiAgKnJ4TGV0PVwiXG4gICAqICAgIGhlcm8kO1xuICAgKiAgICBsZXQgaGVybztcbiAgICogICAgbGV0IGMgPSBjb21wbGV0ZTtcbiAgICogICAgY29tcGxldGVUcmlnZ2VyOiBjb21wbGV0ZVRyaWdnZXIkXG4gICAqIFwiPlxuICAgKlxuICAgKiAgIDxhcHAtaGVybyBbaGVyb109XCJoZXJvXCI+PC9hcHAtaGVybz5cbiAgICogICA8ZG9uZSAqbmdJZj1cImNcIj48L2RvbmU+XG4gICAqIDwvbmctY29udGFpbmVyPlxuICAgKlxuICAgKiAvLyB0cmlnZ2VyIHRlbXBsYXRlIGZyb20gY29tcG9uZW50LnRzXG4gICAqIGNvbXBsZXRlVHJpZ2dlciQubmV4dCgpXG4gICAqXG4gICAqIEBwYXJhbSB7IE9ic2VydmFibGU8dW5rbm93bj4gfSBjb21wbGV0ZVRyaWdnZXJcbiAgICovXG4gIEBJbnB1dCgncnhMZXRDb21wbGV0ZVRyaWdnZXInKSBjb21wbGV0ZVRyaWdnZXI/OiBPYnNlcnZhYmxlPHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSB0cmlnZ2VyIHRvIG1hbnVhbGx5IGFjdGl2YXRlIHRoZSBlcnJvciB0ZW1wbGF0ZS4gSXQgYWNjZXB0cyBhbnkgdmFsdWUsXG4gICAqIG9uIGVtaXNzaW9uIGl0IHdpbGwgZGlzcGxheSB0aGUgZXJyb3IgdGVtcGxhdGUuIElmIG5vIHRlbXBsYXRlIGlzIGdpdmVuLFxuICAgKiB0aGUgZXJyb3IgY29udGV4dCB2YXJpYWJsZSB3aWxsIGJlIHNldCB0byB0cnVlIGluc3RlYWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxuZy1jb250YWluZXJcbiAgICogICpyeExldD1cIlxuICAgKiAgICBoZXJvJDtcbiAgICogICAgbGV0IGhlcm87XG4gICAqICAgIGxldCBlID0gZXJyb3I7XG4gICAqICAgIGVycm9yVHJpZ2dlcjogZXJyb3JUcmlnZ2VyJFxuICAgKiBcIj5cbiAgICpcbiAgICogICA8YXBwLWhlcm8gW2hlcm9dPVwiaGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqICAgPGVycm9yICpuZ0lmPVwiZVwiPjwvZXJyb3I+XG4gICAqIDwvbmctY29udGFpbmVyPlxuICAgKlxuICAgKiAvLyB0cmlnZ2VyIHRlbXBsYXRlIGZyb20gY29tcG9uZW50LnRzXG4gICAqIGVycm9yVHJpZ2dlciQubmV4dCgpXG4gICAqXG4gICAqIEBwYXJhbSB7IE9ic2VydmFibGU8dW5rbm93bj4gfSBlcnJvclRyaWdnZXJcbiAgICovXG4gIEBJbnB1dCgncnhMZXRFcnJvclRyaWdnZXInKSBlcnJvclRyaWdnZXI/OiBPYnNlcnZhYmxlPHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSB0cmlnZ2VyIHRvIG1hbnVhbGx5IGFjdGl2YXRlIHRoZSBzdXNwZW5zZSB0ZW1wbGF0ZS4gSXQgYWNjZXB0cyBhbnkgdmFsdWUsXG4gICAqIG9uIGVtaXNzaW9uIGl0IHdpbGwgZGlzcGxheSB0aGUgc3VzcGVuc2UgdGVtcGxhdGUuIElmIG5vIHRlbXBsYXRlIGlzIGdpdmVuLFxuICAgKiB0aGUgc3VzcGVuc2UgY29udGV4dCB2YXJpYWJsZSB3aWxsIGJlIHNldCB0byB0cnVlIGluc3RlYWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxuZy1jb250YWluZXJcbiAgICogICpyeExldD1cIlxuICAgKiAgICBoZXJvJDtcbiAgICogICAgbGV0IGhlcm87XG4gICAqICAgIGxldCBzID0gc3VzcGVuc2U7XG4gICAqICAgIHN1c3BlbnNlVHJpZ2dlcjogc3VzcGVuc2VUcmlnZ2VyJFxuICAgKiBcIj5cbiAgICpcbiAgICogICA8YXBwLWhlcm8gW2hlcm9dPVwiaGVyb1wiPjwvYXBwLWhlcm8+XG4gICAqICAgPGxvYWRlciAqbmdJZj1cInNcIj48L2xvYWRlcj5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqXG4gICAqXG4gICAqIC8vIHRyaWdnZXIgdGVtcGxhdGUgZnJvbSBjb21wb25lbnQudHNcbiAgICogc3VzcGVuc2VUcmlnZ2VyJC5uZXh0KClcbiAgICpcbiAgICogQHBhcmFtIHsgT2JzZXJ2YWJsZTx1bmtub3duPiB9IHN1c3BlbnNlVHJpZ2dlclxuICAgKi9cbiAgQElucHV0KCdyeExldFN1c3BlbnNlVHJpZ2dlcicpIHN1c3BlbnNlVHJpZ2dlcj86IE9ic2VydmFibGU8dW5rbm93bj47XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHRyaWdnZXIgdG8gbWFudWFsbHkgYWN0aXZhdGUgdGhlIGRlZmF1bHQgdGVtcGxhdGUuIEl0IGFjY2VwdHMgYW55IHZhbHVlLFxuICAgKiBvbiBlbWlzc2lvbiBpdCB3aWxsIHN3aXRjaCB0byB0aGUgbGV0IGRpcmVjdGl2ZXMgZGVmYXVsdCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPG5nLWNvbnRhaW5lclxuICAgKiAgKnJ4TGV0PVwiXG4gICAqICAgIGhlcm8kO1xuICAgKiAgICBsZXQgaGVybztcbiAgICogICAgc3VzcGVuc2U6IHN1c3BlbnNlXG4gICAqICAgIG5leHRUcmlnZ2VyOiBuZXh0VHJpZ2dlciRcbiAgICogXCI+XG4gICAqXG4gICAqICAgPGFwcC1oZXJvIFtoZXJvXT1cImhlcm9cIj48L2FwcC1oZXJvPlxuICAgKiA8L25nLWNvbnRhaW5lcj5cbiAgICpcbiAgICogPG5nLXRlbXBsYXRlICNzdXNwZW5zZT48bG9hZGVyPjwvbG9hZGVyPjwvbmctdGVtcGxhdGU+XG4gICAqXG4gICAqIC8vIHRyaWdnZXIgdGVtcGxhdGUgZnJvbSBjb21wb25lbnQudHNcbiAgICogbmV4dFRyaWdnZXIkLm5leHQoKVxuICAgKlxuICAgKiBAcGFyYW0geyBPYnNlcnZhYmxlPHVua25vd24+IH0gbmV4dFRyaWdnZXJcbiAgICovXG4gIEBJbnB1dCgncnhMZXROZXh0VHJpZ2dlcicpIG5leHRUcmlnZ2VyPzogT2JzZXJ2YWJsZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgYFN1YmplY3RgIHdoaWNoIGVtaXRzIHdoZW5ldmVyICpyeEZvciBmaW5pc2hlZCByZW5kZXJpbmcgYSBzZXQgY2hhbmdlcyB0byB0aGUgdmlldy5cbiAgICogVGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gcGVyZm9ybSBhY3Rpb25zIHdoZW4gYSBsaXN0IGhhcyBmaW5pc2hlZCByZW5kZXJpbmcuXG4gICAqIFRoZSBgcmVuZGVyQ2FsbGJhY2tgIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSByZWx5IG9uIHNwZWNpZmljIERPTSBwcm9wZXJ0aWVzIGxpa2UgdGhlIGBoZWlnaHRgIGFcbiAgICogdGFibGUgYWZ0ZXIgYWxsIGl0ZW1zIGdvdCByZW5kZXJlZC5cbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgdGhlIHJlbmRlckNhbGxiYWNrIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiBhIHZpZXcgc2hvdWxkIGJlIHZpc2libGUgb3Igbm90LiBUaGlzXG4gICAqIHdheSBkZXZlbG9wZXJzIGNhbiBoaWRlIGEgbGlzdCBhcyBsb25nIGFzIGl0IGhhcyBub3QgZmluaXNoZWQgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBgcmVuZGVyQ2FsbGJhY2tgIHdpbGwgY29udGFpbiB0aGUgY3VycmVudGx5IHJlbmRlcmVkIHNldCBvZiBpdGVtcyBpbiB0aGUgaXRlcmFibGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFxcQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgICogICB0ZW1wbGF0ZTogYFxuICAgKiAgIDxhcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgICA8YXBwLWxpc3QtaXRlbVxuICAgKiAgICAgICAqcnhGb3I9XCJcbiAgICogICAgICAgICBsZXQgaXRlbSBvZiBpdGVtcyQ7XG4gICAqICAgICAgICAgdHJhY2tCeTogdHJhY2tJdGVtO1xuICAgKiAgICAgICAgIHJlbmRlckNhbGxiYWNrOiBpdGVtc1JlbmRlcmVkO1xuICAgKiAgICAgICBcIj5cbiAgICogICAgICAgPGRpdj57eyBpdGVtLm5hbWUgfX08L2Rpdj5cbiAgICogICAgIDwvYXBwLWxpc3QtaXRlbT5cbiAgICogICA8L2FwcC1saXN0LWNvbXBvbmVudD5cbiAgICogYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICBpdGVtcyQ6IE9ic2VydmFibGU8SXRlbVtdPiA9IGl0ZW1TZXJ2aWNlLmdldEl0ZW1zKCk7XG4gICAqICAgdHJhY2tJdGVtID0gKGlkeCwgaXRlbSkgPT4gaXRlbS5pZDtcbiAgICogICAvLyB0aGlzIGVtaXRzIHdoZW5ldmVyIHJ4Rm9yIGZpbmlzaGVkIHJlbmRlcmluZyBjaGFuZ2VzXG4gICAqICAgaXRlbXNSZW5kZXJlZCA9IG5ldyBTdWJqZWN0PEl0ZW1bXT4oKTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Pikge1xuICAgKiAgICAgaXRlbXNSZW5kZXJlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgKiAgICAgICAvLyBpdGVtcyBhcmUgcmVuZGVyZWQsIHdlIGNhbiBub3cgc2Nyb2xsXG4gICAqICAgICAgIGVsZW1lbnRSZWYuc2Nyb2xsVG8oe2JvdHRvbTogMH0pO1xuICAgKiAgICAgfSlcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBASW5wdXQoJ3J4TGV0UmVuZGVyQ2FsbGJhY2snKVxuICBzZXQgcmVuZGVyQ2FsbGJhY2soY2FsbGJhY2s6IE5leHRPYnNlcnZlcjxVPikge1xuICAgIHRoaXMuX3JlbmRlck9ic2VydmVyID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFdoZW4gbG9jYWwgcmVuZGVyaW5nIHN0cmF0ZWdpZXMgYXJlIHVzZWQsIHdlIG5lZWQgdG8gdHJlYXQgdmlldyBhbmQgY29udGVudCBxdWVyaWVzIGluIGFcbiAgICogc3BlY2lhbCB3YXkuXG4gICAqIFRvIG1ha2UgYCpyeExldGAgaW4gc3VjaCBzaXR1YXRpb25zLCBhIGNlcnRhaW4gbWVjaGFuaXNtIGlzIGltcGxlbWVudGVkIHRvXG4gICAqIGV4ZWN1dGUgY2hhbmdlIGRldGVjdGlvbiBvbiB0aGUgcGFyZW50IChgcGFyZW50YCkuXG4gICAqXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgaWYgeW91ciBjb21wb25lbnRzIHN0YXRlIGlzIGRlcGVuZGVudCBvbiBpdHMgdmlldyBvciBjb250ZW50IGNoaWxkcmVuOlxuICAgKlxuICAgKiAtIGBAVmlld0NoaWxkYFxuICAgKiAtIGBAVmlld0NoaWxkcmVuYFxuICAgKiAtIGBAQ29udGVudENoaWxkYFxuICAgKiAtIGBAQ29udGVudENoaWxkcmVuYFxuICAgKlxuICAgKiBSZWFkIG1vcmUgYWJvdXQgdGhpcyBpbiB0aGVcbiAgICogW29mZmljaWFsXG4gICAqIGRvY3NdKGh0dHBzOi8vd3d3LnJ4LWFuZ3VsYXIuaW8vZG9jcy90ZW1wbGF0ZS9hcGkvbGV0LWRpcmVjdGl2ZSNsb2NhbC1zdHJhdGVnaWVzLWFuZC12aWV3LWNvbnRlbnQtcXVlcmllcy1wYXJlbnQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcXEBDb21wb25lbnQoe1xuICAgKiAgIHNlbGVjdG9yOiAnYXBwLXJvb3QnLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgIDxhcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgICAgPGFwcC1saXN0LWl0ZW1cbiAgICogICAgICAgICpyeExldD1cIlxuICAgKiAgICAgICAgICBpdGVtJDtcbiAgICogICAgICAgICAgbGV0IGl0ZW07XG4gICAqICAgICAgICAgIHBhcmVudDogdHJ1ZTtcbiAgICogICAgICAgIFwiXG4gICAqICAgICAgPlxuICAgKiAgICAgICAgPGRpdj57eyBpdGVtLm5hbWUgfX08L2Rpdj5cbiAgICogICAgICA8L2FwcC1saXN0LWl0ZW0+XG4gICAqICAgIDwvYXBwLWxpc3QtY29tcG9uZW50PlxuICAgKiAgIGBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAqICAgaXRlbSQgPSBpdGVtU2VydmljZS5nZXRJdGVtKCk7XG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIGJvb2xlYW5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdGhpcyBmbGFnIHdpbGwgYmUgZHJvcHBlZCBzb29uLCBhcyBpdCBpcyBubyBsb25nZXIgcmVxdWlyZWQgd2hlbiB1c2luZyBzaWduYWwgYmFzZWQgdmlldyAmIGNvbnRlbnQgcXVlcmllc1xuICAgKi9cbiAgQElucHV0KCdyeExldFBhcmVudCcpIHJlbmRlclBhcmVudCA9IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5jb25maWcucGFyZW50O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBmbGFnIHRvIGNvbnRyb2wgd2hldGhlciAqcnhMZXQgdGVtcGxhdGVzIGFyZSBjcmVhdGVkIHdpdGhpbiBgTmdab25lYCBvciBub3QuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlLCBgKnJ4TGV0YCB3aWxsIGNyZWF0ZSBpdCdzIGBFbWJlZGRlZFZpZXdzYCBpbnNpZGUgYE5nWm9uZWAuXG4gICAqXG4gICAqIEV2ZW50IGxpc3RlbmVycyBub3JtYWxseSB0cmlnZ2VyIHpvbmUuIEVzcGVjaWFsbHkgaGlnaCBmcmVxdWVudGx5IGV2ZW50cyBjYXVzZSBwZXJmb3JtYW5jZSBpc3N1ZXMuXG4gICAqXG4gICAqIFJlYWQgbW9yZSBhYm91dCB0aGlzIGluIHRoZVxuICAgKiBbb2ZmaWNpYWwgZG9jc10oaHR0cHM6Ly93d3cucngtYW5ndWxhci5pby9kb2NzL3RlbXBsYXRlL2FwaS9sZXQtZGlyZWN0aXZlI3dvcmtpbmctd2l0aC1ldmVudC1saXN0ZW5lcnMtcGF0Y2h6b25lKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogXFxAQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgICogICB0ZW1wbGF0ZTogYFxuICAgKiAgICA8YXBwLWxpc3QtY29tcG9uZW50PlxuICAgKiAgICAgIDxhcHAtbGlzdC1pdGVtXG4gICAqICAgICAgICAqcnhMZXQ9XCJcbiAgICogICAgICAgICAgaXRlbSQ7XG4gICAqICAgICAgICAgIGxldCBpdGVtO1xuICAgKiAgICAgICAgICBwYXRjaFpvbmU6IGZhbHNlO1xuICAgKiAgICAgICAgXCJcbiAgICogICAgICA+XG4gICAqICAgICAgICA8ZGl2Pnt7IGl0ZW0ubmFtZSB9fTwvZGl2PlxuICAgKiAgICAgIDwvYXBwLWxpc3QtaXRlbT5cbiAgICogICAgPC9hcHAtbGlzdC1jb21wb25lbnQ+XG4gICAqICAgYFxuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICogICBpdGVtJCA9IGl0ZW1TZXJ2aWNlLmdldEl0ZW0oKTtcbiAgICogfVxuICAgKi9cbiAgQElucHV0KCdyeExldFBhdGNoWm9uZScpIHBhdGNoWm9uZSA9IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5jb25maWcucGF0Y2hab25lO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvYnNlcnZhYmxlc0hhbmRsZXIgPSBjcmVhdGVUZW1wbGF0ZU5vdGlmaWVyPFU+KCk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdHJhdGVneUhhbmRsZXIgPSBjb2VyY2VBbGxGYWN0b3J5PHN0cmluZz4oXG4gICAgKCkgPT4gbmV3IFJlcGxheVN1YmplY3Q8UnhTdHJhdGVneU5hbWVzPigxKSxcbiAgKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHRyaWdnZXJIYW5kbGVyID0gbmV3IFJlcGxheVN1YmplY3Q8UnhOb3RpZmljYXRpb25LaW5kPigxKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3JlbmRlck9ic2VydmVyOiBOZXh0T2JzZXJ2ZXI8YW55PjtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHRlbXBsYXRlTWFuYWdlcjogUnhUZW1wbGF0ZU1hbmFnZXI8XG4gICAgVSxcbiAgICBSeExldFZpZXdDb250ZXh0PFUgfCB1bmRlZmluZWQgfCBudWxsPixcbiAgICBSeExldFRlbXBsYXRlTmFtZXNcbiAgPjtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVuZGVyZWQkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IHRlbXBsYXRlTm90aWZpY2F0aW9uJCA9IG5ldyBTdWJqZWN0PFJ4Tm90aWZpY2F0aW9uPFU+PigpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVhZG9ubHkgdmFsdWVzJCA9IHRoaXMub2JzZXJ2YWJsZXNIYW5kbGVyLnZhbHVlcyQ7XG5cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHJlbmRlcmVkID0gZGVmZXIoKCkgPT4gdGhpcy5yZW5kZXJlZCQpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIG5nVGVtcGxhdGVDb250ZXh0R3VhcmQ8VT4oXG4gICAgZGlyOiBSeExldDxVPixcbiAgICBjdHg6IHVua25vd24gfCBudWxsIHwgdW5kZWZpbmVkLFxuICApOiBjdHggaXMgUnhMZXRWaWV3Q29udGV4dDxVPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxSeExldFZpZXdDb250ZXh0PFU+Pikge31cblxuICAvKiogQGludGVybmFsICovXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyXG4gICAgICAgIC5yZW5kZXIobWVyZ2UodGhpcy52YWx1ZXMkLCB0aGlzLnRlbXBsYXRlTm90aWZpY2F0aW9uJCkpXG4gICAgICAgIC5zdWJzY3JpYmUoKG4pID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkJC5uZXh0KG4pO1xuICAgICAgICAgIHRoaXMuX3JlbmRlck9ic2VydmVyPy5uZXh0KG4pO1xuICAgICAgICB9KSxcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIG1lcmdlKFxuICAgICAgICB0aGlzLmNvbnRleHRUcmlnZ2VyIHx8IE5FVkVSLFxuICAgICAgICB0aGlzLm5leHRUcmlnZ2VyPy5waXBlKG1hcCgoKSA9PiBSeE5vdGlmaWNhdGlvbktpbmQuTmV4dCkpIHx8IE5FVkVSLFxuICAgICAgICB0aGlzLnN1c3BlbnNlVHJpZ2dlcj8ucGlwZShtYXAoKCkgPT4gUnhOb3RpZmljYXRpb25LaW5kLlN1c3BlbnNlKSkgfHxcbiAgICAgICAgICBORVZFUixcbiAgICAgICAgdGhpcy5jb21wbGV0ZVRyaWdnZXI/LnBpcGUobWFwKCgpID0+IFJ4Tm90aWZpY2F0aW9uS2luZC5Db21wbGV0ZSkpIHx8XG4gICAgICAgICAgTkVWRVIsXG4gICAgICAgIHRoaXMuZXJyb3JUcmlnZ2VyPy5waXBlKG1hcCgoKSA9PiBSeE5vdGlmaWNhdGlvbktpbmQuRXJyb3IpKSB8fCBORVZFUixcbiAgICAgIClcbiAgICAgICAgLnBpcGUoZmlsdGVyKCh2KSA9PiAhIXYpKVxuICAgICAgICAuc3Vic2NyaWJlKCh0KSA9PiB0aGlzLnRyaWdnZXJIYW5kbGVyLm5leHQodCkpLFxuICAgICk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoIXRoaXMudGVtcGxhdGVNYW5hZ2VyKSB7XG4gICAgICB0aGlzLl9jcmVhdGVUZW1wbGF0ZU1hbmFnZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5jb21wbGV0ZSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZU1hbmFnZXIuYWRkVGVtcGxhdGVSZWYoXG4gICAgICAgIFJ4TGV0VGVtcGxhdGVOYW1lcy5jb21wbGV0ZSxcbiAgICAgICAgdGhpcy5jb21wbGV0ZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuc3VzcGVuc2UpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyLmFkZFRlbXBsYXRlUmVmKFxuICAgICAgICBSeExldFRlbXBsYXRlTmFtZXMuc3VzcGVuc2UsXG4gICAgICAgIHRoaXMuc3VzcGVuc2UsXG4gICAgICApO1xuICAgICAgdGhpcy5vYnNlcnZhYmxlc0hhbmRsZXIud2l0aEluaXRpYWxTdXNwZW5zZSghIXRoaXMuc3VzcGVuc2UpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmVycm9yKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlTWFuYWdlci5hZGRUZW1wbGF0ZVJlZihSeExldFRlbXBsYXRlTmFtZXMuZXJyb3IsIHRoaXMuZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLnJ4TGV0KSB7XG4gICAgICBpZiAoaXNTaWduYWwodGhpcy5yeExldCkpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlc0hhbmRsZXIubmV4dChcbiAgICAgICAgICB0b09ic2VydmFibGUodGhpcy5yeExldCwgeyBpbmplY3RvcjogdGhpcy5pbmplY3RvciB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXNIYW5kbGVyLm5leHQodGhpcy5yeExldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9jcmVhdGVUZW1wbGF0ZU1hbmFnZXIoKTogdm9pZCB7XG4gICAgdGhpcy50ZW1wbGF0ZU1hbmFnZXIgPSBjcmVhdGVUZW1wbGF0ZU1hbmFnZXI8XG4gICAgICBVLFxuICAgICAgUnhMZXRWaWV3Q29udGV4dDxVPixcbiAgICAgIFJ4TGV0VGVtcGxhdGVOYW1lc1xuICAgID4oe1xuICAgICAgdGVtcGxhdGVTZXR0aW5nczoge1xuICAgICAgICB2aWV3Q29udGFpbmVyUmVmOiB0aGlzLnZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIGN1c3RvbUNvbnRleHQ6IChyeExldCkgPT4gKHsgcnhMZXQgfSksXG4gICAgICB9LFxuICAgICAgcmVuZGVyU2V0dGluZ3M6IHtcbiAgICAgICAgY2RSZWY6IHRoaXMuY2RSZWYsXG4gICAgICAgIHBhcmVudDogISF0aGlzLnJlbmRlclBhcmVudCxcbiAgICAgICAgcGF0Y2hab25lOiB0aGlzLnBhdGNoWm9uZSA/IHRoaXMubmdab25lIDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRTdHJhdGVneU5hbWU6IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5wcmltYXJ5U3RyYXRlZ3ksXG4gICAgICAgIHN0cmF0ZWdpZXM6IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5zdHJhdGVnaWVzLFxuICAgICAgICBlcnJvckhhbmRsZXI6IHRoaXMuZXJyb3JIYW5kbGVyLFxuICAgICAgfSxcbiAgICAgIG5vdGlmaWNhdGlvblRvVGVtcGxhdGVOYW1lOiB7XG4gICAgICAgIFtSeE5vdGlmaWNhdGlvbktpbmQuU3VzcGVuc2VdOiAoKSA9PlxuICAgICAgICAgIHRoaXMuc3VzcGVuc2UgPyBSeExldFRlbXBsYXRlTmFtZXMuc3VzcGVuc2UgOiBSeExldFRlbXBsYXRlTmFtZXMubmV4dCxcbiAgICAgICAgW1J4Tm90aWZpY2F0aW9uS2luZC5OZXh0XTogKCkgPT4gUnhMZXRUZW1wbGF0ZU5hbWVzLm5leHQsXG4gICAgICAgIFtSeE5vdGlmaWNhdGlvbktpbmQuRXJyb3JdOiAoKSA9PlxuICAgICAgICAgIHRoaXMuZXJyb3IgPyBSeExldFRlbXBsYXRlTmFtZXMuZXJyb3IgOiBSeExldFRlbXBsYXRlTmFtZXMubmV4dCxcbiAgICAgICAgW1J4Tm90aWZpY2F0aW9uS2luZC5Db21wbGV0ZV06ICgpID0+XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSA/IFJ4TGV0VGVtcGxhdGVOYW1lcy5jb21wbGV0ZSA6IFJ4TGV0VGVtcGxhdGVOYW1lcy5uZXh0LFxuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlVHJpZ2dlciQ6IHRoaXMudHJpZ2dlckhhbmRsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRlbXBsYXRlTWFuYWdlci5hZGRUZW1wbGF0ZVJlZihcbiAgICAgIFJ4TGV0VGVtcGxhdGVOYW1lcy5uZXh0LFxuICAgICAgdGhpcy50ZW1wbGF0ZVJlZixcbiAgICApO1xuICAgIHRoaXMudGVtcGxhdGVNYW5hZ2VyLm5leHRTdHJhdGVneSh0aGlzLnN0cmF0ZWd5SGFuZGxlci52YWx1ZXMkKTtcbiAgfVxufVxuIl19