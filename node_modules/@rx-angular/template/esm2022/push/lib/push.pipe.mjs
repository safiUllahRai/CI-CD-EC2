import { ChangeDetectorRef, inject, NgZone, Pipe, untracked, } from '@angular/core';
import { createTemplateNotifier, } from '@rx-angular/cdk/notifications';
import { RxStrategyProvider, strategyHandling, } from '@rx-angular/cdk/render-strategies';
import { Observable, Subscription, } from 'rxjs';
import { filter, shareReplay, skip, switchMap, tap, withLatestFrom, } from 'rxjs/operators';
import * as i0 from "@angular/core";
/**
 * @Pipe RxPush
 *
 * @description
 *
 * The push pipe serves as a drop-in replacement for angulars built-in async pipe.
 * Just like the *rxLet Directive, it leverages a
 * [RenderStrategy](https://rx-angular.io/docs/cdk/render-strategies)
 *   under the hood which takes care of optimizing the ChangeDetection of your component. The rendering behavior can be
 *   configured per RxPush instance using either a strategy name or provide a
 * `RxComponentInput` config.
 *
 * Usage in the template
 *
 * ```html
 * <hero-search [term]="searchTerm$ | push"> </hero-search>
 * <hero-list-component [heroes]="heroes$ | push"> </hero-list-component>
 * ```
 *
 * Using different strategies
 *
 * ```html
 * <hero-search [term]="searchTerm$ | push: 'immediate'"> </hero-search>
 * <hero-list-component [heroes]="heroes$ | push: 'normal'"> </hero-list-component>
 * ```
 *
 * Provide a config object
 *
 * ```html
 * <hero-search [term]="searchTerm$ | push: { strategy: 'immediate' }"> </hero-search>
 * <hero-list-component [heroes]="heroes$ | push: { strategy: 'normal' }"> </hero-list-component>
 * ```
 *
 * Other Features:
 *
 * - lazy rendering (see
 *  [LetDirective](https://github.com/rx-angular/rx-angular/tree/main/libs/template/docs/api/let-directive.md))
 * - Take observables or promises, retrieve their values and render the value to the template
 * - a unified/structured way of handling null, undefined or error
 * - distinct same values in a row skip not needed re-renderings
 *
 * @usageNotes
 *
 * ```html
 * {{observable$ | push}}
 * <ng-container *ngIf="observable$ | push as o">{{o}}</ng-container>
 * <component [value]="observable$ | push"></component>
 * ```
 *
 * @publicApi
 */
export class RxPush {
    cdRef;
    /** @internal */
    strategyProvider = inject(RxStrategyProvider);
    /** @internal */
    ngZone = inject(NgZone);
    /**
     * @internal
     * This is typed as `any` because the type cannot be inferred
     * without a class-level generic argument, which was removed to
     * fix https://github.com/rx-angular/rx-angular/pull/684
     */
    renderedValue;
    /** @internal */
    subscription;
    /** @internal */
    templateObserver = createTemplateNotifier();
    templateValues$ = this.templateObserver.values$.pipe(onlyValues(), shareReplay({ bufferSize: 1, refCount: true }));
    /** @internal */
    strategyHandler = strategyHandling(this.strategyProvider.primaryStrategy, this.strategyProvider.strategies);
    /** @internal */
    patchZone;
    /** @internal */
    _renderCallback;
    constructor(cdRef) {
        this.cdRef = cdRef;
    }
    transform(potentialObservable, config, renderCallback) {
        this._renderCallback = renderCallback;
        if (config) {
            if (isRxComponentInput(config)) {
                this.strategyHandler.next(config.strategy);
                this._renderCallback = config.renderCallback;
                // set fallback if patchZone is not set
                this.setPatchZone(config.patchZone);
            }
            else {
                this.strategyHandler.next(config);
            }
        }
        this.templateObserver.next(potentialObservable);
        if (!this.subscription) {
            this.subscription = this.handleChangeDetection();
        }
        return this.renderedValue;
    }
    /** @internal */
    ngOnDestroy() {
        untracked(() => this.subscription?.unsubscribe());
    }
    /** @internal */
    setPatchZone(patch) {
        const doPatch = patch == null ? this.strategyProvider.config.patchZone : patch;
        this.patchZone = doPatch ? this.ngZone : false;
    }
    /** @internal */
    handleChangeDetection() {
        const scope = this.cdRef.context;
        const sub = new Subscription();
        // Subscription can be side-effectful, and we don't want any signal reads which happen in the
        // side effect of the subscription to be tracked by a component's template when that
        // subscription is triggered via the async pipe. So we wrap the subscription in `untracked` to
        // decouple from the current reactive context.
        //
        // `untracked` also prevents signal _writes_ which happen in the subscription side effect from
        // being treated as signal writes during the template evaluation (which throws errors).
        const setRenderedValue = untracked(() => this.templateValues$.subscribe(({ value }) => {
            this.renderedValue = value;
        }));
        const render = untracked(() => this.hasInitialValue(this.templateValues$)
            .pipe(switchMap((isSync) => this.templateValues$.pipe(
        // skip ticking change detection
        // in case we have an initial value, we don't need to perform cd
        // the variable will be evaluated anyway because of the lifecycle
        skip(isSync ? 1 : 0), 
        // onlyValues(),
        this.render(scope), tap((v) => {
            this._renderCallback?.next(v);
        }))))
            .subscribe());
        sub.add(setRenderedValue);
        sub.add(render);
        return sub;
    }
    /** @internal */
    render(scope) {
        return (o$) => o$.pipe(withLatestFrom(this.strategyHandler.strategy$), switchMap(([notification, strategy]) => this.strategyProvider.schedule(() => {
            strategy.work(this.cdRef, scope);
            return notification.value;
        }, {
            scope,
            strategy: strategy.name,
            patchZone: this.patchZone,
        })));
    }
    /** @internal */
    hasInitialValue(value$) {
        return new Observable((subscriber) => {
            let hasInitialValue = false;
            const inner = value$.subscribe(() => {
                hasInitialValue = true;
            });
            inner.unsubscribe();
            subscriber.next(hasInitialValue);
            subscriber.complete();
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxPush, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });
    /** @nocollapse */ static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: RxPush, isStandalone: true, name: "push", pure: false });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxPush, decorators: [{
            type: Pipe,
            args: [{ name: 'push', pure: false, standalone: true }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }] });
// https://eslint.org/docs/rules/no-prototype-builtins
const hasOwnProperty = Object.prototype.hasOwnProperty;
function onlyValues() {
    return (o$) => o$.pipe(filter((n) => n.kind === "suspense" /* RxNotificationKind.Suspense */ ||
        n.kind === "next" /* RxNotificationKind.Next */));
}
function isRxComponentInput(value) {
    return (value != null &&
        (hasOwnProperty.call(value, 'strategy') ||
            hasOwnProperty.call(value, 'renderCallback') ||
            hasOwnProperty.call(value, 'patchZone')));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVzaC5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy90ZW1wbGF0ZS9wdXNoL3NyYy9saWIvcHVzaC5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsTUFBTSxFQUNOLE1BQU0sRUFFTixJQUFJLEVBRUosU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxzQkFBc0IsR0FHdkIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2QyxPQUFPLEVBRUwsa0JBQWtCLEVBQ2xCLGdCQUFnQixHQUNqQixNQUFNLG1DQUFtQyxDQUFDO0FBQzNDLE9BQU8sRUFHTCxVQUFVLEVBR1YsWUFBWSxHQUViLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUNMLE1BQU0sRUFDTixXQUFXLEVBQ1gsSUFBSSxFQUNKLFNBQVMsRUFDVCxHQUFHLEVBQ0gsY0FBYyxHQUNmLE1BQU0sZ0JBQWdCLENBQUM7O0FBRXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtERztBQUVILE1BQU0sT0FBTyxNQUFNO0lBOEJHO0lBN0JwQixnQkFBZ0I7SUFDUixnQkFBZ0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUN0RCxnQkFBZ0I7SUFDUixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDOzs7OztPQUtHO0lBQ0ssYUFBYSxDQUF5QjtJQUM5QyxnQkFBZ0I7SUFDUixZQUFZLENBQWlCO0lBQ3JDLGdCQUFnQjtJQUNDLGdCQUFnQixHQUFHLHNCQUFzQixFQUFPLENBQUM7SUFDakQsZUFBZSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUNuRSxVQUFVLEVBQUUsRUFDWixXQUFXLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFB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LFxuICBpbmplY3QsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBQaXBlLFxuICBQaXBlVHJhbnNmb3JtLFxuICB1bnRyYWNrZWQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVtcGxhdGVOb3RpZmllcixcbiAgUnhOb3RpZmljYXRpb24sXG4gIFJ4Tm90aWZpY2F0aW9uS2luZCxcbn0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL25vdGlmaWNhdGlvbnMnO1xuaW1wb3J0IHtcbiAgUnhTdHJhdGVneU5hbWVzLFxuICBSeFN0cmF0ZWd5UHJvdmlkZXIsXG4gIHN0cmF0ZWd5SGFuZGxpbmcsXG59IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9yZW5kZXItc3RyYXRlZ2llcyc7XG5pbXBvcnQge1xuICBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sXG4gIE5leHRPYnNlcnZlcixcbiAgT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2YWJsZUlucHV0LFxuICBPcGVyYXRvckZ1bmN0aW9uLFxuICBTdWJzY3JpcHRpb24sXG4gIFVuc3Vic2NyaWJhYmxlLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGZpbHRlcixcbiAgc2hhcmVSZXBsYXksXG4gIHNraXAsXG4gIHN3aXRjaE1hcCxcbiAgdGFwLFxuICB3aXRoTGF0ZXN0RnJvbSxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEBQaXBlIFJ4UHVzaFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoZSBwdXNoIHBpcGUgc2VydmVzIGFzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgYW5ndWxhcnMgYnVpbHQtaW4gYXN5bmMgcGlwZS5cbiAqIEp1c3QgbGlrZSB0aGUgKnJ4TGV0IERpcmVjdGl2ZSwgaXQgbGV2ZXJhZ2VzIGFcbiAqIFtSZW5kZXJTdHJhdGVneV0oaHR0cHM6Ly9yeC1hbmd1bGFyLmlvL2RvY3MvY2RrL3JlbmRlci1zdHJhdGVnaWVzKVxuICogICB1bmRlciB0aGUgaG9vZCB3aGljaCB0YWtlcyBjYXJlIG9mIG9wdGltaXppbmcgdGhlIENoYW5nZURldGVjdGlvbiBvZiB5b3VyIGNvbXBvbmVudC4gVGhlIHJlbmRlcmluZyBiZWhhdmlvciBjYW4gYmVcbiAqICAgY29uZmlndXJlZCBwZXIgUnhQdXNoIGluc3RhbmNlIHVzaW5nIGVpdGhlciBhIHN0cmF0ZWd5IG5hbWUgb3IgcHJvdmlkZSBhXG4gKiBgUnhDb21wb25lbnRJbnB1dGAgY29uZmlnLlxuICpcbiAqIFVzYWdlIGluIHRoZSB0ZW1wbGF0ZVxuICpcbiAqIGBgYGh0bWxcbiAqIDxoZXJvLXNlYXJjaCBbdGVybV09XCJzZWFyY2hUZXJtJCB8IHB1c2hcIj4gPC9oZXJvLXNlYXJjaD5cbiAqIDxoZXJvLWxpc3QtY29tcG9uZW50IFtoZXJvZXNdPVwiaGVyb2VzJCB8IHB1c2hcIj4gPC9oZXJvLWxpc3QtY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogVXNpbmcgZGlmZmVyZW50IHN0cmF0ZWdpZXNcbiAqXG4gKiBgYGBodG1sXG4gKiA8aGVyby1zZWFyY2ggW3Rlcm1dPVwic2VhcmNoVGVybSQgfCBwdXNoOiAnaW1tZWRpYXRlJ1wiPiA8L2hlcm8tc2VhcmNoPlxuICogPGhlcm8tbGlzdC1jb21wb25lbnQgW2hlcm9lc109XCJoZXJvZXMkIHwgcHVzaDogJ25vcm1hbCdcIj4gPC9oZXJvLWxpc3QtY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogUHJvdmlkZSBhIGNvbmZpZyBvYmplY3RcbiAqXG4gKiBgYGBodG1sXG4gKiA8aGVyby1zZWFyY2ggW3Rlcm1dPVwic2VhcmNoVGVybSQgfCBwdXNoOiB7IHN0cmF0ZWd5OiAnaW1tZWRpYXRlJyB9XCI+IDwvaGVyby1zZWFyY2g+XG4gKiA8aGVyby1saXN0LWNvbXBvbmVudCBbaGVyb2VzXT1cImhlcm9lcyQgfCBwdXNoOiB7IHN0cmF0ZWd5OiAnbm9ybWFsJyB9XCI+IDwvaGVyby1saXN0LWNvbXBvbmVudD5cbiAqIGBgYFxuICpcbiAqIE90aGVyIEZlYXR1cmVzOlxuICpcbiAqIC0gbGF6eSByZW5kZXJpbmcgKHNlZVxuICogIFtMZXREaXJlY3RpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9yeC1hbmd1bGFyL3J4LWFuZ3VsYXIvdHJlZS9tYWluL2xpYnMvdGVtcGxhdGUvZG9jcy9hcGkvbGV0LWRpcmVjdGl2ZS5tZCkpXG4gKiAtIFRha2Ugb2JzZXJ2YWJsZXMgb3IgcHJvbWlzZXMsIHJldHJpZXZlIHRoZWlyIHZhbHVlcyBhbmQgcmVuZGVyIHRoZSB2YWx1ZSB0byB0aGUgdGVtcGxhdGVcbiAqIC0gYSB1bmlmaWVkL3N0cnVjdHVyZWQgd2F5IG9mIGhhbmRsaW5nIG51bGwsIHVuZGVmaW5lZCBvciBlcnJvclxuICogLSBkaXN0aW5jdCBzYW1lIHZhbHVlcyBpbiBhIHJvdyBza2lwIG5vdCBuZWVkZWQgcmUtcmVuZGVyaW5nc1xuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogYGBgaHRtbFxuICoge3tvYnNlcnZhYmxlJCB8IHB1c2h9fVxuICogPG5nLWNvbnRhaW5lciAqbmdJZj1cIm9ic2VydmFibGUkIHwgcHVzaCBhcyBvXCI+e3tvfX08L25nLWNvbnRhaW5lcj5cbiAqIDxjb21wb25lbnQgW3ZhbHVlXT1cIm9ic2VydmFibGUkIHwgcHVzaFwiPjwvY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5AUGlwZSh7IG5hbWU6ICdwdXNoJywgcHVyZTogZmFsc2UsIHN0YW5kYWxvbmU6IHRydWUgfSlcbmV4cG9ydCBjbGFzcyBSeFB1c2ggaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtLCBPbkRlc3Ryb3kge1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RyYXRlZ3lQcm92aWRlciA9IGluamVjdChSeFN0cmF0ZWd5UHJvdmlkZXIpO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgbmdab25lID0gaW5qZWN0KE5nWm9uZSk7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBpcyB0eXBlZCBhcyBgYW55YCBiZWNhdXNlIHRoZSB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZFxuICAgKiB3aXRob3V0IGEgY2xhc3MtbGV2ZWwgZ2VuZXJpYyBhcmd1bWVudCwgd2hpY2ggd2FzIHJlbW92ZWQgdG9cbiAgICogZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9yeC1hbmd1bGFyL3J4LWFuZ3VsYXIvcHVsbC82ODRcbiAgICovXG4gIHByaXZhdGUgcmVuZGVyZWRWYWx1ZTogYW55IHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogVW5zdWJzY3JpYmFibGU7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZU9ic2VydmVyID0gY3JlYXRlVGVtcGxhdGVOb3RpZmllcjxhbnk+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVWYWx1ZXMkID0gdGhpcy50ZW1wbGF0ZU9ic2VydmVyLnZhbHVlcyQucGlwZShcbiAgICBvbmx5VmFsdWVzKCksXG4gICAgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KVxuICApO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RyYXRlZ3lIYW5kbGVyID0gc3RyYXRlZ3lIYW5kbGluZyhcbiAgICB0aGlzLnN0cmF0ZWd5UHJvdmlkZXIucHJpbWFyeVN0cmF0ZWd5LFxuICAgIHRoaXMuc3RyYXRlZ3lQcm92aWRlci5zdHJhdGVnaWVzXG4gICk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBwYXRjaFpvbmU6IGZhbHNlIHwgTmdab25lO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3JlbmRlckNhbGxiYWNrOiBOZXh0T2JzZXJ2ZXI8YW55PjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICB0cmFuc2Zvcm08VT4oXG4gICAgcG90ZW50aWFsT2JzZXJ2YWJsZTogbnVsbCxcbiAgICBjb25maWc/OiBSeFN0cmF0ZWd5TmFtZXMgfCBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz4sXG4gICAgcmVuZGVyQ2FsbGJhY2s/OiBOZXh0T2JzZXJ2ZXI8VT5cbiAgKTogbnVsbDtcbiAgdHJhbnNmb3JtPFU+KFxuICAgIHBvdGVudGlhbE9ic2VydmFibGU6IHVuZGVmaW5lZCxcbiAgICBjb25maWc/OiBSeFN0cmF0ZWd5TmFtZXMgfCBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz4sXG4gICAgcmVuZGVyQ2FsbGJhY2s/OiBOZXh0T2JzZXJ2ZXI8VT5cbiAgKTogdW5kZWZpbmVkO1xuICB0cmFuc2Zvcm08VT4oXG4gICAgcG90ZW50aWFsT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PFU+IHwgVSxcbiAgICBjb25maWc/OiBSeFN0cmF0ZWd5TmFtZXMgfCBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz4sXG4gICAgcmVuZGVyQ2FsbGJhY2s/OiBOZXh0T2JzZXJ2ZXI8VT5cbiAgKTogVTtcbiAgdHJhbnNmb3JtPFU+KFxuICAgIHBvdGVudGlhbE9ic2VydmFibGU6IE9ic2VydmFibGVJbnB1dDxVPixcbiAgICBjb25maWc/OiBQdXNoSW5wdXQ8VT5cbiAgKTogVTtcbiAgdHJhbnNmb3JtPFU+KFxuICAgIHBvdGVudGlhbE9ic2VydmFibGU6IE9ic2VydmFibGVJbnB1dDxVPiB8IFUgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIGNvbmZpZzpcbiAgICAgIHwgUHVzaElucHV0PFU+XG4gICAgICB8IFJ4U3RyYXRlZ3lOYW1lc1xuICAgICAgfCBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz5cbiAgICAgIHwgdW5kZWZpbmVkLFxuICAgIHJlbmRlckNhbGxiYWNrPzogTmV4dE9ic2VydmVyPFU+XG4gICk6IFUgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgICB0aGlzLl9yZW5kZXJDYWxsYmFjayA9IHJlbmRlckNhbGxiYWNrO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGlmIChpc1J4Q29tcG9uZW50SW5wdXQoY29uZmlnKSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5SGFuZGxlci5uZXh0KGNvbmZpZy5zdHJhdGVneSBhcyBzdHJpbmcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJDYWxsYmFjayA9IGNvbmZpZy5yZW5kZXJDYWxsYmFjaztcbiAgICAgICAgLy8gc2V0IGZhbGxiYWNrIGlmIHBhdGNoWm9uZSBpcyBub3Qgc2V0XG4gICAgICAgIHRoaXMuc2V0UGF0Y2hab25lKGNvbmZpZy5wYXRjaFpvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneUhhbmRsZXIubmV4dChjb25maWcgYXMgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50ZW1wbGF0ZU9ic2VydmVyLm5leHQocG90ZW50aWFsT2JzZXJ2YWJsZSk7XG4gICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmhhbmRsZUNoYW5nZURldGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlZFZhbHVlIGFzIFU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHVudHJhY2tlZCgoKSA9PiB0aGlzLnN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc2V0UGF0Y2hab25lKHBhdGNoPzogYm9vbGVhbik6IHZvaWQge1xuICAgIGNvbnN0IGRvUGF0Y2ggPVxuICAgICAgcGF0Y2ggPT0gbnVsbCA/IHRoaXMuc3RyYXRlZ3lQcm92aWRlci5jb25maWcucGF0Y2hab25lIDogcGF0Y2g7XG4gICAgdGhpcy5wYXRjaFpvbmUgPSBkb1BhdGNoID8gdGhpcy5uZ1pvbmUgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBoYW5kbGVDaGFuZ2VEZXRlY3Rpb24oKTogVW5zdWJzY3JpYmFibGUge1xuICAgIGNvbnN0IHNjb3BlID0gKHRoaXMuY2RSZWYgYXMgYW55KS5jb250ZXh0O1xuICAgIGNvbnN0IHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIC8vIFN1YnNjcmlwdGlvbiBjYW4gYmUgc2lkZS1lZmZlY3RmdWwsIGFuZCB3ZSBkb24ndCB3YW50IGFueSBzaWduYWwgcmVhZHMgd2hpY2ggaGFwcGVuIGluIHRoZVxuICAgIC8vIHNpZGUgZWZmZWN0IG9mIHRoZSBzdWJzY3JpcHRpb24gdG8gYmUgdHJhY2tlZCBieSBhIGNvbXBvbmVudCdzIHRlbXBsYXRlIHdoZW4gdGhhdFxuICAgIC8vIHN1YnNjcmlwdGlvbiBpcyB0cmlnZ2VyZWQgdmlhIHRoZSBhc3luYyBwaXBlLiBTbyB3ZSB3cmFwIHRoZSBzdWJzY3JpcHRpb24gaW4gYHVudHJhY2tlZGAgdG9cbiAgICAvLyBkZWNvdXBsZSBmcm9tIHRoZSBjdXJyZW50IHJlYWN0aXZlIGNvbnRleHQuXG4gICAgLy9cbiAgICAvLyBgdW50cmFja2VkYCBhbHNvIHByZXZlbnRzIHNpZ25hbCBfd3JpdGVzXyB3aGljaCBoYXBwZW4gaW4gdGhlIHN1YnNjcmlwdGlvbiBzaWRlIGVmZmVjdCBmcm9tXG4gICAgLy8gYmVpbmcgdHJlYXRlZCBhcyBzaWduYWwgd3JpdGVzIGR1cmluZyB0aGUgdGVtcGxhdGUgZXZhbHVhdGlvbiAod2hpY2ggdGhyb3dzIGVycm9ycykuXG4gICAgY29uc3Qgc2V0UmVuZGVyZWRWYWx1ZSA9IHVudHJhY2tlZCgoKSA9PlxuICAgICAgdGhpcy50ZW1wbGF0ZVZhbHVlcyQuc3Vic2NyaWJlKCh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZhbHVlID0gdmFsdWU7XG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgcmVuZGVyID0gdW50cmFja2VkKCgpID0+XG4gICAgICB0aGlzLmhhc0luaXRpYWxWYWx1ZSh0aGlzLnRlbXBsYXRlVmFsdWVzJClcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgc3dpdGNoTWFwKChpc1N5bmMpID0+XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVmFsdWVzJC5waXBlKFxuICAgICAgICAgICAgICAvLyBza2lwIHRpY2tpbmcgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgd2UgZG9uJ3QgbmVlZCB0byBwZXJmb3JtIGNkXG4gICAgICAgICAgICAgIC8vIHRoZSB2YXJpYWJsZSB3aWxsIGJlIGV2YWx1YXRlZCBhbnl3YXkgYmVjYXVzZSBvZiB0aGUgbGlmZWN5Y2xlXG4gICAgICAgICAgICAgIHNraXAoaXNTeW5jID8gMSA6IDApLFxuICAgICAgICAgICAgICAvLyBvbmx5VmFsdWVzKCksXG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyKHNjb3BlKSxcbiAgICAgICAgICAgICAgdGFwKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2FsbGJhY2s/Lm5leHQodik7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKVxuICAgICk7XG4gICAgc3ViLmFkZChzZXRSZW5kZXJlZFZhbHVlKTtcbiAgICBzdWIuYWRkKHJlbmRlcik7XG4gICAgcmV0dXJuIHN1YjtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSByZW5kZXI8VD4oc2NvcGU6IG9iamVjdCk6IE9wZXJhdG9yRnVuY3Rpb248UnhOb3RpZmljYXRpb248VD4sIFQ+IHtcbiAgICByZXR1cm4gKG8kKSA9PlxuICAgICAgbyQucGlwZShcbiAgICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdHJhdGVneUhhbmRsZXIuc3RyYXRlZ3kkKSxcbiAgICAgICAgc3dpdGNoTWFwKChbbm90aWZpY2F0aW9uLCBzdHJhdGVneV0pID0+XG4gICAgICAgICAgdGhpcy5zdHJhdGVneVByb3ZpZGVyLnNjaGVkdWxlKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBzdHJhdGVneS53b3JrKHRoaXMuY2RSZWYsIHNjb3BlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3kubmFtZSxcbiAgICAgICAgICAgICAgcGF0Y2hab25lOiB0aGlzLnBhdGNoWm9uZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgaGFzSW5pdGlhbFZhbHVlKHZhbHVlJDogT2JzZXJ2YWJsZTx1bmtub3duPik6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxib29sZWFuPigoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgbGV0IGhhc0luaXRpYWxWYWx1ZSA9IGZhbHNlO1xuICAgICAgY29uc3QgaW5uZXIgPSB2YWx1ZSQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaGFzSW5pdGlhbFZhbHVlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaW5uZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmliZXIubmV4dChoYXNJbml0aWFsVmFsdWUpO1xuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBQdXNoSW5wdXQ8VD4ge1xuICBzdHJhdGVneT86IFJ4U3RyYXRlZ3lOYW1lcyB8IE9ic2VydmFibGU8UnhTdHJhdGVneU5hbWVzPjtcbiAgcmVuZGVyQ2FsbGJhY2s/OiBOZXh0T2JzZXJ2ZXI8VD47XG4gIHBhdGNoWm9uZT86IGJvb2xlYW47XG59XG5cbi8vIGh0dHBzOi8vZXNsaW50Lm9yZy9kb2NzL3J1bGVzL25vLXByb3RvdHlwZS1idWlsdGluc1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBvbmx5VmFsdWVzPFQ+KCk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxSeE5vdGlmaWNhdGlvbjxUPj4ge1xuICByZXR1cm4gKG8kKSA9PlxuICAgIG8kLnBpcGUoXG4gICAgICBmaWx0ZXIoXG4gICAgICAgIChuKSA9PlxuICAgICAgICAgIG4ua2luZCA9PT0gUnhOb3RpZmljYXRpb25LaW5kLlN1c3BlbnNlIHx8XG4gICAgICAgICAgbi5raW5kID09PSBSeE5vdGlmaWNhdGlvbktpbmQuTmV4dFxuICAgICAgKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzUnhDb21wb25lbnRJbnB1dDxVPih2YWx1ZTogYW55KTogdmFsdWUgaXMgUHVzaElucHV0PFU+IHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdzdHJhdGVneScpIHx8XG4gICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAncmVuZGVyQ2FsbGJhY2snKSB8fFxuICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ3BhdGNoWm9uZScpKVxuICApO1xufVxuIl19