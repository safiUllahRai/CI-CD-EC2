import { AfterViewInit, ElementRef, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';
import * as i0 from "@angular/core";
/**
 *
 * @description
 *
 * This function takes an elem and event and re-applies the listeners from the passed event to the
 * passed element with the zone un-patched version of it.
 *
 * @param elem {HTMLElement} - The elem to re-apply the listeners to.
 * @param event {string} - The name of the event from which to re-apply the listeners.
 *
 * @returns void
 */
export declare function unpatchEventListener(element: HTMLElement & {
    eventListeners?: (event: string) => EventListenerOrEventListenerObject[];
}, event: string): EventListenerOrEventListenerObject[];
/**
 * @Directive RxUnpatch
 *
 * @description
 *
 * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid
 * of unnecessary renderings through zones `addEventListener` patches.
 * It can be used on any element you apply event bindings.
 *
 * The current way of binding events to the DOM is to use output bindings:
 *  ```html
 * <button (click)="doStuff($event)">click me</button>
 * ```
 *
 * The problem is that every event registered over `()` syntax, e.g. `(click)`
 * marks the component and all its ancestors as dirty and re-renders the whole component tree.
 * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.
 *
 * So even if your button is not related to a change that needs a re-render the app will re-render completely.
 * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'
 *
 * `unpatch` directive solves that problem.
 *
 * Included Features:
 *  - by default un-patch all registered listeners of the host it is applied on
 *  - un-patch only a specified set of registered event listeners
 *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)
 *  - Not interfering with any logic executed by the registered callback
 *
 * @usageNotes
 *
 * The `unpatch` directive can be used like shown here:
 * ```html
 * <button [unpatch] (click)="triggerSomeMethod($event)">click me</button>
 * <button [unpatch]="['mousemove']" (mousemove)="doStuff2($event)" (click)="doStuff($event)">click me</button>
 * ```
 *
 * @publicApi
 */
export declare class RxUnpatch implements OnChanges, AfterViewInit, OnDestroy {
    private host;
    /**
     * @description
     * List of events that the element should be unpatched from. When input is empty or undefined,
     * the element is unpatched from all zone-patched events.
     *
     * Full list of zone-patched browser events can be found in
     * [this document](https://github.com/angular/angular/blob/master/packages/zone.js/STANDARD-APIS.md#browser).
     *
     */
    events?: string[];
    private subscription;
    private events$;
    private listeners;
    constructor(host: ElementRef<HTMLElement>);
    ngOnChanges({ events }: SimpleChanges): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private reapplyUnPatchedEventListeners;
    static ɵfac: i0.ɵɵFactoryDeclaration<RxUnpatch, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<RxUnpatch, "[unpatch]", never, { "events": { "alias": "unpatch"; "required": false; }; }, {}, never, never, true, never>;
}
