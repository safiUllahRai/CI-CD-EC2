import { Observable, Subscription, } from 'rxjs';
import { coalescingManager } from './coalescingManager';
/**
 * @description
 * Limits the number of synchronous emitted a value from the source Observable to
 * one emitted value per
 *   durationSelector e.g. [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats
 * this process for every tick of the browsers event loop.
 *
 * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.
 * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope
 *   coalescing.
 *
 * @param {function(value: T): Observable} durationSelector - A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * It defaults to `requestAnimationFrame` as durationSelector.
 * @param scope
 * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.
 * @return {Observable<T>} An Observable that performs the coalesce operation to
 * limit the rate of emissions from the source.
 *
 * @usageNotes
 * Emit clicks at a rate of at most one click per second
 * ```typescript
 * import { interval, fromEvent } from 'rxjs';
 * import { coalesceWith } from '@rx-angular/cdk/coalescing';
 *
 * const setTimeoutDurationSelector = interval(500);
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(coalesceWith(setTimeoutDurationSelector));
 * result.subscribe(x => console.log(x));
 * ```
 */
export function coalesceWith(durationSelector, scope) {
    const _scope = scope || {};
    return (source) => {
        return new Observable((observer) => {
            const rootSubscription = new Subscription();
            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));
            return rootSubscription;
        });
        function createInnerObserver(outerObserver, rootSubscription) {
            let actionSubscription;
            let latestValue;
            const tryEmitLatestValue = () => {
                if (actionSubscription) {
                    // We only decrement the number if it is greater than 0 (isCoalescing)
                    coalescingManager.remove(_scope);
                    if (!coalescingManager.isCoalescing(_scope)) {
                        outerObserver.next(latestValue);
                    }
                }
            };
            return {
                complete: () => {
                    tryEmitLatestValue();
                    outerObserver.complete();
                },
                error: (error) => outerObserver.error(error),
                next: (value) => {
                    latestValue = value;
                    if (!actionSubscription) {
                        coalescingManager.add(_scope);
                        actionSubscription = durationSelector.subscribe({
                            error: (error) => outerObserver.error(error),
                            next: () => {
                                tryEmitLatestValue();
                                actionSubscription?.unsubscribe();
                                actionSubscription = undefined;
                            },
                            complete: () => {
                                tryEmitLatestValue();
                                actionSubscription = undefined;
                            },
                        });
                        rootSubscription.add(new Subscription(() => {
                            tryEmitLatestValue();
                            actionSubscription?.unsubscribe();
                            actionSubscription = undefined;
                        }));
                    }
                },
            };
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29hbGVzY2VXaXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvY29hbGVzY2luZy9zcmMvbGliL2NvYWxlc2NlV2l0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsVUFBVSxFQUdWLFlBQVksR0FFYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0JHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FDMUIsZ0JBQXFDLEVBQ3JDLEtBQStCO0lBRS9CLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUM7SUFFM0IsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxVQUFVLENBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUNwQyxNQUFNLGdCQUFnQixHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7WUFDNUMsZ0JBQWdCLENBQUMsR0FBRyxDQUNsQixNQUFNLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQ2xFLENBQUM7WUFDRixPQUFPLGdCQUFnQixDQUFDO1FBQzFCLENBQUMsQ0FBQyxDQUFDO1FBRUgsU0FBUyxtQkFBbUIsQ0FDMUIsYUFBNEIsRUFDNUIsZ0JBQThCO1lBRTlCLElBQUksa0JBQWtDLENBQUM7WUFDdkMsSUFBSSxXQUEwQixDQUFDO1lBRS9CLE1BQU0sa0JBQWtCLEdBQUcsR0FBRyxFQUFFO2dCQUM5QixJQUFJLGtCQUFrQixFQUFFLENBQUM7b0JBQ3ZCLHNFQUFzRTtvQkFDdEUsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUNqQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7d0JBQzVDLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ2xDLENBQUM7Z0JBQ0gsQ0FBQztZQUNILENBQUMsQ0FBQztZQUNGLE9BQU87Z0JBQ0wsUUFBUSxFQUFFLEdBQUcsRUFBRTtvQkFDYixrQkFBa0IsRUFBRSxDQUFDO29CQUNyQixhQUFhLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzNCLENBQUM7Z0JBQ0QsS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztnQkFDNUMsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQ2QsV0FBVyxHQUFHLEtBQUssQ0FBQztvQkFDcEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7d0JBQ3hCLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDOUIsa0JBQWtCLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDOzRCQUM5QyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDOzRCQUM1QyxJQUFJLEVBQUUsR0FBRyxFQUFFO2dDQUNULGtCQUFrQixFQUFFLENBQUM7Z0NBQ3JCLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxDQUFDO2dDQUNsQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7NEJBQ2pDLENBQUM7NEJBQ0QsUUFBUSxFQUFFLEdBQUcsRUFBRTtnQ0FDYixrQkFBa0IsRUFBRSxDQUFDO2dDQUNyQixrQkFBa0IsR0FBRyxTQUFTLENBQUM7NEJBQ2pDLENBQUM7eUJBQ0YsQ0FBQyxDQUFDO3dCQUNILGdCQUFnQixDQUFDLEdBQUcsQ0FDbEIsSUFBSSxZQUFZLENBQUMsR0FBRyxFQUFFOzRCQUNwQixrQkFBa0IsRUFBRSxDQUFDOzRCQUNyQixrQkFBa0IsRUFBRSxXQUFXLEVBQUUsQ0FBQzs0QkFDbEMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDO3dCQUNqQyxDQUFDLENBQUMsQ0FDSCxDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQzthQUNGLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbixcbiAgT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2ZXIsXG4gIFN1YnNjcmliZXIsXG4gIFN1YnNjcmlwdGlvbixcbiAgVW5zdWJzY3JpYmFibGUsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY29hbGVzY2luZ01hbmFnZXIgfSBmcm9tICcuL2NvYWxlc2NpbmdNYW5hZ2VyJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIExpbWl0cyB0aGUgbnVtYmVyIG9mIHN5bmNocm9ub3VzIGVtaXR0ZWQgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0b1xuICogb25lIGVtaXR0ZWQgdmFsdWUgcGVyXG4gKiAgIGR1cmF0aW9uU2VsZWN0b3IgZS5nLiBbYEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLCB0aGVuIHJlcGVhdHNcbiAqIHRoaXMgcHJvY2VzcyBmb3IgZXZlcnkgdGljayBvZiB0aGUgYnJvd3NlcnMgZXZlbnQgbG9vcC5cbiAqXG4gKiBUaGUgY29hbGVzY2Ugb3BlcmF0b3IgaXMgYmFzZWQgb24gdGhlIFt0aHJvdHRsZV0oaHR0cHM6Ly9yeGpzLWRldi5maXJlYmFzZWFwcC5jb20vYXBpL29wZXJhdG9ycy90aHJvdHRsZSkgb3BlcmF0b3IuXG4gKiBJbiBhZGRpdGlvbiB0byB0aGF0IGlzIHByb3ZpZGVzIGVtaXR0ZWQgdmFsdWVzIGZvciB0aGUgdHJhaWxpbmcgZW5kIG9ubHksIGFzIHdlbGwgYXMgbWFpbnRhaW5pbmcgYSBjb250ZXh0IHRvIHNjb3BlXG4gKiAgIGNvYWxlc2NpbmcuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IE9ic2VydmFibGV9IGR1cmF0aW9uU2VsZWN0b3IgLSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gZm9yIGVhY2ggc291cmNlIHZhbHVlLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEl0IGRlZmF1bHRzIHRvIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFzIGR1cmF0aW9uU2VsZWN0b3IuXG4gKiBAcGFyYW0gc2NvcGVcbiAqIERlZmF1bHRzIHRvIGB7IGxlYWRpbmc6IGZhbHNlLCB0cmFpbGluZzogdHJ1ZSB9YC4gVGhlIGRlZmF1bHQgc2NvcGluZyBpcyBwZXIgc3Vic2NyaWJlci5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgY29hbGVzY2Ugb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiBFbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZFxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgaW50ZXJ2YWwsIGZyb21FdmVudCB9IGZyb20gJ3J4anMnO1xuICogaW1wb3J0IHsgY29hbGVzY2VXaXRoIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL2NvYWxlc2NpbmcnO1xuICpcbiAqIGNvbnN0IHNldFRpbWVvdXREdXJhdGlvblNlbGVjdG9yID0gaW50ZXJ2YWwoNTAwKTtcbiAqIGNvbnN0IGNsaWNrcyA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZShjb2FsZXNjZVdpdGgoc2V0VGltZW91dER1cmF0aW9uU2VsZWN0b3IpKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvYWxlc2NlV2l0aDxUPihcbiAgZHVyYXRpb25TZWxlY3RvcjogT2JzZXJ2YWJsZTx1bmtub3duPixcbiAgc2NvcGU/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgY29uc3QgX3Njb3BlID0gc2NvcGUgfHwge307XG5cbiAgcmV0dXJuIChzb3VyY2UpID0+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8VD4oKG9ic2VydmVyKSA9PiB7XG4gICAgICBjb25zdCByb290U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgcm9vdFN1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlSW5uZXJPYnNlcnZlcihvYnNlcnZlciwgcm9vdFN1YnNjcmlwdGlvbikpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJvb3RTdWJzY3JpcHRpb247XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbm5lck9ic2VydmVyKFxuICAgICAgb3V0ZXJPYnNlcnZlcjogU3Vic2NyaWJlcjxUPixcbiAgICAgIHJvb3RTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICk6IE9ic2VydmVyPFQ+IHtcbiAgICAgIGxldCBhY3Rpb25TdWJzY3JpcHRpb246IFVuc3Vic2NyaWJhYmxlO1xuICAgICAgbGV0IGxhdGVzdFZhbHVlOiBUIHwgdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCB0cnlFbWl0TGF0ZXN0VmFsdWUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChhY3Rpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAvLyBXZSBvbmx5IGRlY3JlbWVudCB0aGUgbnVtYmVyIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiAwIChpc0NvYWxlc2NpbmcpXG4gICAgICAgICAgY29hbGVzY2luZ01hbmFnZXIucmVtb3ZlKF9zY29wZSk7XG4gICAgICAgICAgaWYgKCFjb2FsZXNjaW5nTWFuYWdlci5pc0NvYWxlc2NpbmcoX3Njb3BlKSkge1xuICAgICAgICAgICAgb3V0ZXJPYnNlcnZlci5uZXh0KGxhdGVzdFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHRyeUVtaXRMYXRlc3RWYWx1ZSgpO1xuICAgICAgICAgIG91dGVyT2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChlcnJvcikgPT4gb3V0ZXJPYnNlcnZlci5lcnJvcihlcnJvciksXG4gICAgICAgIG5leHQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxhdGVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKCFhY3Rpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGNvYWxlc2NpbmdNYW5hZ2VyLmFkZChfc2NvcGUpO1xuICAgICAgICAgICAgYWN0aW9uU3Vic2NyaXB0aW9uID0gZHVyYXRpb25TZWxlY3Rvci5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICBlcnJvcjogKGVycm9yKSA9PiBvdXRlck9ic2VydmVyLmVycm9yKGVycm9yKSxcbiAgICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeUVtaXRMYXRlc3RWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBhY3Rpb25TdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5RW1pdExhdGVzdFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb290U3Vic2NyaXB0aW9uLmFkZChcbiAgICAgICAgICAgICAgbmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5RW1pdExhdGVzdFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG4iXX0=