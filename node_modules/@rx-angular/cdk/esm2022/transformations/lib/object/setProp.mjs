import { isDefined, isKeyOf, isObjectGuard } from '../_internals/guards';
/**
 * @description
 * Accepts an object of type T, key of type K extends keyof T, and value of type T[K].
 * Sets the property and returns a newly updated shallow copy of an object while not mutating the original one.
 *
 * @example
 *
 * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
 *
 * const renamedCat = setProp(cat, 'name', 'Bella');
 *
 * // renamedCat will be:
 * // {id: 1, type: 'cat', name: 'Bella'};
 *
 * @example
 * // Usage with RxState
 *
 * export class ProfileComponent {
 *
 *    readonly changeName$ = new Subject<string>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        this.changeName$,
 *        (state, name) => {
 *            return setProp(state, 'name', name);
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    changeName(name: string): void {
 *        this.state.set(setProp(this.get(), 'name', name));
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage setProp
 * @docsCategory transformation-helpers
 */
export function setProp(object, key, value) {
    const objectIsObject = isObjectGuard(object);
    const keyIsValid = isKeyOf(key);
    const initialObject = objectIsObject ? object : {};
    if (!objectIsObject) {
        console.warn(`SetProp: original value (${object}) is not an object.`);
    }
    if (!keyIsValid) {
        console.warn(`SetProp: key argument (${key}) is invalid.`);
    }
    if (!isDefined(object) && !keyIsValid) {
        return object;
    }
    if (keyIsValid) {
        return {
            ...initialObject,
            [key]: value
        };
    }
    return { ...initialObject };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0UHJvcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2RrL3RyYW5zZm9ybWF0aW9ucy9zcmMvbGliL29iamVjdC9zZXRQcm9wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlDRztBQUNILE1BQU0sVUFBVSxPQUFPLENBQ3JCLE1BQVMsRUFDVCxHQUFNLEVBQ04sS0FBVztJQUVYLE1BQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUksR0FBRyxDQUFDLENBQUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFFLEVBQVEsQ0FBQztJQUUxRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDcEIsT0FBTyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsTUFBTSxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLElBQUksQ0FBQywwQkFBMEIsR0FBRyxlQUFlLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3RDLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxJQUFJLFVBQVUsRUFBRSxDQUFDO1FBQ2YsT0FBTztZQUNMLEdBQUcsYUFBYTtZQUNoQixDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUs7U0FDYixDQUFDO0lBQ0osQ0FBQztJQUVELE9BQU8sRUFBRSxHQUFHLGFBQWEsRUFBRSxDQUFDO0FBQzlCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0RlZmluZWQsIGlzS2V5T2YsIGlzT2JqZWN0R3VhcmQgfSBmcm9tICcuLi9faW50ZXJuYWxzL2d1YXJkcyc7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBY2NlcHRzIGFuIG9iamVjdCBvZiB0eXBlIFQsIGtleSBvZiB0eXBlIEsgZXh0ZW5kcyBrZXlvZiBULCBhbmQgdmFsdWUgb2YgdHlwZSBUW0tdLlxuICogU2V0cyB0aGUgcHJvcGVydHkgYW5kIHJldHVybnMgYSBuZXdseSB1cGRhdGVkIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3Qgd2hpbGUgbm90IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBjYXQgPSB7aWQ6IDEsIHR5cGU6ICdjYXQnLCBuYW1lOiAnRmx1ZmZ5J307XG4gKlxuICogY29uc3QgcmVuYW1lZENhdCA9IHNldFByb3AoY2F0LCAnbmFtZScsICdCZWxsYScpO1xuICpcbiAqIC8vIHJlbmFtZWRDYXQgd2lsbCBiZTpcbiAqIC8vIHtpZDogMSwgdHlwZTogJ2NhdCcsIG5hbWU6ICdCZWxsYSd9O1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBVc2FnZSB3aXRoIFJ4U3RhdGVcbiAqXG4gKiBleHBvcnQgY2xhc3MgUHJvZmlsZUNvbXBvbmVudCB7XG4gKlxuICogICAgcmVhZG9ubHkgY2hhbmdlTmFtZSQgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG4gKlxuICogICAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGF0ZTogUnhTdGF0ZTxDb21wb25lbnRTdGF0ZT4pIHtcbiAqICAgICAgLy8gUmVhY3RpdmUgaW1wbGVtZW50YXRpb25cbiAqICAgICAgc3RhdGUuY29ubmVjdChcbiAqICAgICAgICB0aGlzLmNoYW5nZU5hbWUkLFxuICogICAgICAgIChzdGF0ZSwgbmFtZSkgPT4ge1xuICogICAgICAgICAgICByZXR1cm4gc2V0UHJvcChzdGF0ZSwgJ25hbWUnLCBuYW1lKTtcbiAqICAgICAgICB9XG4gKiAgICAgICk7XG4gKiAgICB9XG4gKlxuICogICAgLy8gSW1wZXJhdGl2ZSBpbXBsZW1lbnRhdGlvblxuICogICAgY2hhbmdlTmFtZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAqICAgICAgICB0aGlzLnN0YXRlLnNldChzZXRQcm9wKHRoaXMuZ2V0KCksICduYW1lJywgbmFtZSkpO1xuICogICAgfVxuICogfVxuICpcbiAqIEByZXR1cm5zIFRcbiAqXG4gKiBAZG9jc1BhZ2Ugc2V0UHJvcFxuICogQGRvY3NDYXRlZ29yeSB0cmFuc2Zvcm1hdGlvbi1oZWxwZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wPFQgZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgb2JqZWN0OiBULFxuICBrZXk6IEssXG4gIHZhbHVlOiBUW0tdXG4pOiBUIHtcbiAgY29uc3Qgb2JqZWN0SXNPYmplY3QgPSBpc09iamVjdEd1YXJkKG9iamVjdCk7XG4gIGNvbnN0IGtleUlzVmFsaWQgPSBpc0tleU9mPFQ+KGtleSk7XG4gIGNvbnN0IGluaXRpYWxPYmplY3QgPSBvYmplY3RJc09iamVjdCA/IG9iamVjdCA6ICh7fSBhcyBUKTtcblxuICBpZiAoIW9iamVjdElzT2JqZWN0KSB7XG4gICAgY29uc29sZS53YXJuKGBTZXRQcm9wOiBvcmlnaW5hbCB2YWx1ZSAoJHtvYmplY3R9KSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICB9XG5cbiAgaWYgKCFrZXlJc1ZhbGlkKSB7XG4gICAgY29uc29sZS53YXJuKGBTZXRQcm9wOiBrZXkgYXJndW1lbnQgKCR7a2V5fSkgaXMgaW52YWxpZC5gKTtcbiAgfVxuXG4gIGlmICghaXNEZWZpbmVkKG9iamVjdCkgJiYgIWtleUlzVmFsaWQpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgaWYgKGtleUlzVmFsaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW5pdGlhbE9iamVjdCxcbiAgICAgIFtrZXldOiB2YWx1ZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyAuLi5pbml0aWFsT2JqZWN0IH07XG59XG4iXX0=