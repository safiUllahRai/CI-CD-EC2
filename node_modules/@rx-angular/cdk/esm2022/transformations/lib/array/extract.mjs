import { isDefined, isKeyOf } from '../_internals/guards';
/**
 * @description
 * Accepts an array of objects of type T and single key or array of keys (K extends keyof T).
 * The `exctract` method is pure and immutable, thus not touching the input values and returning a shallow
 * copy of the extracted source.
 *
 * @example
 *
 * const cats = [{id: 1, type: 'cat', name: 'Fluffy'}, {id: 2, type: 'cat', name: 'Emma'}];
 *
 * const catsWithoutTypes = extract(cats, ['name', 'id']);
 *
 * // catsWithoutTypes will be:
 * // [{id: 1, name: 'Fluffy'}, {id: 2, name: 'Emma'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class AnimalsListComponent {
 *
 *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
 *      state.connect(
 *        'animals'
 *        this.api.getAnimals(),
 *        (state, animals) => extract(animals, ['id', 'name'])
 *      );
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage slice
 * @docsCategory transformation-helpers
 */
export function extract(array, keys) {
    const arrayIsArray = isDefined(array) && Array.isArray(array);
    if (!arrayIsArray) {
        console.warn(`extract: original value (${array}) is not an array.`);
        return undefined;
    }
    const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(k => isKeyOf(k) && array.some(i => k in i));
    const length = sanitizedKeys.length;
    if (!sanitizedKeys.length) {
        console.warn(`extract: provided keys not found`);
        return undefined;
    }
    return array.map(item => {
        let i = 0;
        const result = {};
        for (i; i < length; i++) {
            result[sanitizedKeys[i]] = item[sanitizedKeys[i]];
        }
        return result;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmFjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2RrL3RyYW5zZm9ybWF0aW9ucy9zcmMvbGliL2FycmF5L2V4dHJhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUUxRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUNHO0FBQ0YsTUFBTSxVQUFVLE9BQU8sQ0FDdEIsS0FBVSxFQUNWLElBQWE7SUFFYixNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU5RCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbEIsT0FBTyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsS0FBSyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3BFLE9BQU8sU0FBZ0IsQ0FBQztJQUMxQixDQUFDO0lBRUQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQ2hFLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQzlDLENBQUM7SUFDRixNQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDO0lBRXBDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDMUIsT0FBTyxDQUFDLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1FBQ2pELE9BQU8sU0FBZ0IsQ0FBQztJQUMxQixDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLE1BQU0sTUFBTSxHQUFHLEVBQWdCLENBQUM7UUFFaEMsS0FBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3ZCLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUMsQ0FDQSxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRGVmaW5lZCwgaXNLZXlPZiB9IGZyb20gJy4uL19pbnRlcm5hbHMvZ3VhcmRzJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiB0eXBlIFQgYW5kIHNpbmdsZSBrZXkgb3IgYXJyYXkgb2Yga2V5cyAoSyBleHRlbmRzIGtleW9mIFQpLlxuICogVGhlIGBleGN0cmFjdGAgbWV0aG9kIGlzIHB1cmUgYW5kIGltbXV0YWJsZSwgdGh1cyBub3QgdG91Y2hpbmcgdGhlIGlucHV0IHZhbHVlcyBhbmQgcmV0dXJuaW5nIGEgc2hhbGxvd1xuICogY29weSBvZiB0aGUgZXh0cmFjdGVkIHNvdXJjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGNhdHMgPSBbe2lkOiAxLCB0eXBlOiAnY2F0JywgbmFtZTogJ0ZsdWZmeSd9LCB7aWQ6IDIsIHR5cGU6ICdjYXQnLCBuYW1lOiAnRW1tYSd9XTtcbiAqXG4gKiBjb25zdCBjYXRzV2l0aG91dFR5cGVzID0gZXh0cmFjdChjYXRzLCBbJ25hbWUnLCAnaWQnXSk7XG4gKlxuICogLy8gY2F0c1dpdGhvdXRUeXBlcyB3aWxsIGJlOlxuICogLy8gW3tpZDogMSwgbmFtZTogJ0ZsdWZmeSd9LCB7aWQ6IDIsIG5hbWU6ICdFbW1hJ31dO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBVc2FnZSB3aXRoIFJ4U3RhdGVcbiAqXG4gKiBleHBvcnQgY2xhc3MgQW5pbWFsc0xpc3RDb21wb25lbnQge1xuICpcbiAqICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RhdGU6IFJ4U3RhdGU8Q29tcG9uZW50U3RhdGU+LCBwcml2YXRlIGFwaTogQXBpU2VydmljZSkge1xuICogICAgICBzdGF0ZS5jb25uZWN0KFxuICogICAgICAgICdhbmltYWxzJ1xuICogICAgICAgIHRoaXMuYXBpLmdldEFuaW1hbHMoKSxcbiAqICAgICAgICAoc3RhdGUsIGFuaW1hbHMpID0+IGV4dHJhY3QoYW5pbWFscywgWydpZCcsICduYW1lJ10pXG4gKiAgICAgICk7XG4gKiAgICB9XG4gKiB9XG4gKlxuICogQHJldHVybnMgVFxuICpcbiAqIEBkb2NzUGFnZSBzbGljZVxuICogQGRvY3NDYXRlZ29yeSB0cmFuc2Zvcm1hdGlvbi1oZWxwZXJzXG4gKi9cbiBleHBvcnQgZnVuY3Rpb24gZXh0cmFjdDxUIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgVD4oXG4gIGFycmF5OiBUW10sXG4gIGtleXM6IEsgfCBLW11cbik6IFBpY2s8VCwgSz5bXSB7XG4gIGNvbnN0IGFycmF5SXNBcnJheSA9IGlzRGVmaW5lZChhcnJheSkgJiYgQXJyYXkuaXNBcnJheShhcnJheSk7XG5cbiAgaWYgKCFhcnJheUlzQXJyYXkpIHtcbiAgICBjb25zb2xlLndhcm4oYGV4dHJhY3Q6IG9yaWdpbmFsIHZhbHVlICgke2FycmF5fSkgaXMgbm90IGFuIGFycmF5LmApO1xuICAgIHJldHVybiB1bmRlZmluZWQgYXMgYW55O1xuICB9XG5cbiAgY29uc3Qgc2FuaXRpemVkS2V5cyA9IChBcnJheS5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtrZXlzXSkuZmlsdGVyKFxuICAgIGsgPT4gaXNLZXlPZjxUPihrKSAmJiBhcnJheS5zb21lKGkgPT4gayBpbiBpKVxuICApO1xuICBjb25zdCBsZW5ndGggPSBzYW5pdGl6ZWRLZXlzLmxlbmd0aDtcblxuICBpZiAoIXNhbml0aXplZEtleXMubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKGBleHRyYWN0OiBwcm92aWRlZCBrZXlzIG5vdCBmb3VuZGApO1xuICAgIHJldHVybiB1bmRlZmluZWQgYXMgYW55O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5Lm1hcChpdGVtID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge30gYXMgUGljazxULCBLPjtcblxuICAgIGZvcihpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtzYW5pdGl6ZWRLZXlzW2ldXSA9IGl0ZW1bc2FuaXRpemVkS2V5c1tpXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICApO1xufVxuIl19