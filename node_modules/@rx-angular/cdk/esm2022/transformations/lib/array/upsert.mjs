import { isObjectGuard } from '../_internals/guards';
import { valuesComparer } from '../_internals/valuesComparer.util';
/**
 * @description
 * Updates or inserts (if does not exist) one or multiple items in an array T[].
 * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if
 * items match.
 * If no comparison is provided, an equality check is used by default.
 * upsert is `pure` and `immutable`, your inputs won't be changed
 *
 *
 * @example
 * // Upsert (update) with key
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 1, type: 'lion'};
 *
 * const updatedCreatures = upsert(creatures, newCat, 'id');
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
 *
 * @example
 * // Upsert (insert) with key
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 3, type: 'lion'};
 *
 * const updatedCreatures = upsert(creatures, newCat, 'id');
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
 *
 * @example
 * // Upsert (update) with array of keys
 *
 * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *
 * const newCat = {id: 1, type: 'lion', name: 'Bella'};
 *
 * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *
 * @example
 * // Update (insert) with comparison function
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 3, type: 'lion'};
 *
 * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *
 *    // trigger which gets called on add/update (for reactive implementation)
 *    readonly addOrUpdateCreature = new Subject<Creature>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *      state.set({ creatures: initialCreatures });
 *      // Reactive implementation
 *      state.connect(
 *        'creatures',
 *        this.addOrUpdateCreature,
 *        ({ creatures }, creatureToUpsert) => {
 *            return upsert(creatures, creatureToUpsert, 'id');
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    updateCreature(creatureToUpdate: Creature): void {
 *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});
 *    }
 * }
 *
 * @returns T[]
 *
 * @docsPage upsert
 * @docsCategory transformation-helpers
 */
export function upsert(source, update, compare) {
    // check inputs for validity
    const updatesAsArray = update != null ? (Array.isArray(update) ? update : [update]) : [];
    // check inputs for validity
    const sourceIsNotArray = !Array.isArray(source);
    const invalidInput = sourceIsNotArray && updatesAsArray.length === 0;
    // if the source value is not an Array or the input is not defined return the original source
    // this is the case for any edge case:
    // '', null, undefined, CustomObjectOfDoomAndDarkness, ...
    if (invalidInput) {
        return source;
    }
    // if source is empty array or not an array, but the updates are valid:
    // return a shallow copy of the updates as result
    if (updatesAsArray.length > 0 && (sourceIsNotArray || source.length === 0)) {
        return [...updatesAsArray];
    }
    const inserts = [];
    const updates = {};
    // process updates/inserts
    for (const item of updatesAsArray) {
        const match = source.findIndex((sourceItem) => valuesComparer(item, sourceItem, compare));
        // if item already exists, save it as update
        if (match !== -1) {
            updates[match] = item;
        }
        else {
            // otherwise consider this as insert
            if (isObjectGuard(item)) {
                // create a shallow copy if item is an object
                inserts.push({ ...item });
            }
            else {
                // otherwise just push it
                inserts.push(item);
            }
        }
    }
    const updated = source.map((item, i) => {
        const updatedItem = updates[i];
        // process the updated
        if (updatedItem !== null && updatedItem !== undefined) {
            if (isObjectGuard(item)) {
                return { ...item, ...updatedItem };
            }
            else {
                return updatedItem;
            }
        }
        return item;
    });
    // return the combination of the updated source & the inserts as new array
    return updated.concat(inserts);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBzZXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvdHJhbnNmb3JtYXRpb25zL3NyYy9saWIvYXJyYXkvdXBzZXJ0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFHbkU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3Rkc7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUNwQixNQUFXLEVBQ1gsTUFBaUMsRUFDakMsT0FBMkI7SUFFM0IsNEJBQTRCO0lBQzVCLE1BQU0sY0FBYyxHQUNsQixNQUFNLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDcEUsNEJBQTRCO0lBQzVCLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hELE1BQU0sWUFBWSxHQUFHLGdCQUFnQixJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQ3JFLDZGQUE2RjtJQUM3RixzQ0FBc0M7SUFDdEMsMERBQTBEO0lBQzFELElBQUksWUFBWSxFQUFFLENBQUM7UUFDakIsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELHVFQUF1RTtJQUN2RSxpREFBaUQ7SUFDakQsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUMzRSxPQUFPLENBQUMsR0FBRyxjQUFjLENBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsTUFBTSxPQUFPLEdBQVEsRUFBRSxDQUFDO0lBQ3hCLE1BQU0sT0FBTyxHQUErQixFQUFFLENBQUM7SUFDL0MsMEJBQTBCO0lBQzFCLEtBQUssTUFBTSxJQUFJLElBQUksY0FBYyxFQUFFLENBQUM7UUFDbEMsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQzVDLGNBQWMsQ0FBQyxJQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUMvQyxDQUFDO1FBQ0YsNENBQTRDO1FBQzVDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDakIsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN4QixDQUFDO2FBQU0sQ0FBQztZQUNOLG9DQUFvQztZQUNwQyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUN4Qiw2Q0FBNkM7Z0JBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFJLElBQVUsRUFBRSxDQUFDLENBQUM7WUFDbkMsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLHlCQUF5QjtnQkFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyQixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3JDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQixzQkFBc0I7UUFDdEIsSUFBSSxXQUFXLEtBQUssSUFBSSxJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUN0RCxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUN4QixPQUFPLEVBQUUsR0FBRyxJQUFJLEVBQUUsR0FBRyxXQUFXLEVBQU8sQ0FBQztZQUMxQyxDQUFDO2lCQUFNLENBQUM7Z0JBQ04sT0FBTyxXQUFnQixDQUFDO1lBQzFCLENBQUM7UUFDSCxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDLENBQUMsQ0FBQztJQUVILDBFQUEwRTtJQUMxRSxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDakMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzT2JqZWN0R3VhcmQgfSBmcm9tICcuLi9faW50ZXJuYWxzL2d1YXJkcyc7XG5pbXBvcnQgeyB2YWx1ZXNDb21wYXJlciB9IGZyb20gJy4uL19pbnRlcm5hbHMvdmFsdWVzQ29tcGFyZXIudXRpbCc7XG5pbXBvcnQgeyBDb21wYXJhYmxlRGF0YSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcGFyYWJsZS1kYXRhLXR5cGUnO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVXBkYXRlcyBvciBpbnNlcnRzIChpZiBkb2VzIG5vdCBleGlzdCkgb25lIG9yIG11bHRpcGxlIGl0ZW1zIGluIGFuIGFycmF5IFRbXS5cbiAqIEZvciBjb21wYXJpc29uIHlvdSBjYW4gcHJvdmlkZSBhIGtleSwgYW4gYXJyYXkgb2Yga2V5cyBvciBhIGN1c3RvbSBjb21wYXJpc29uIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiB0cnVlIGlmXG4gKiBpdGVtcyBtYXRjaC5cbiAqIElmIG5vIGNvbXBhcmlzb24gaXMgcHJvdmlkZWQsIGFuIGVxdWFsaXR5IGNoZWNrIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqIHVwc2VydCBpcyBgcHVyZWAgYW5kIGBpbW11dGFibGVgLCB5b3VyIGlucHV0cyB3b24ndCBiZSBjaGFuZ2VkXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBVcHNlcnQgKHVwZGF0ZSkgd2l0aCBrZXlcbiAqXG4gKiBjb25zdCBjcmVhdHVyZXMgPSBbe2lkOiAxLCB0eXBlOiAnY2F0J30sIHtpZDogMiwgdHlwZTogJ2RvZyd9XTtcbiAqXG4gKiBjb25zdCBuZXdDYXQgPSB7aWQ6IDEsIHR5cGU6ICdsaW9uJ307XG4gKlxuICogY29uc3QgdXBkYXRlZENyZWF0dXJlcyA9IHVwc2VydChjcmVhdHVyZXMsIG5ld0NhdCwgJ2lkJyk7XG4gKlxuICogLy8gdXBkYXRlZENyZWF0dXJlcyB3aWxsIGJlOlxuICogLy8gW3tpZDogMSwgdHlwZTogJ2xpb24nfSwge2lkOiAyLCB0eXBlOiAnZG9nJ31dO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBVcHNlcnQgKGluc2VydCkgd2l0aCBrZXlcbiAqXG4gKiBjb25zdCBjcmVhdHVyZXMgPSBbe2lkOiAxLCB0eXBlOiAnY2F0J30sIHtpZDogMiwgdHlwZTogJ2RvZyd9XTtcbiAqXG4gKiBjb25zdCBuZXdDYXQgPSB7aWQ6IDMsIHR5cGU6ICdsaW9uJ307XG4gKlxuICogY29uc3QgdXBkYXRlZENyZWF0dXJlcyA9IHVwc2VydChjcmVhdHVyZXMsIG5ld0NhdCwgJ2lkJyk7XG4gKlxuICogLy8gdXBkYXRlZENyZWF0dXJlcyB3aWxsIGJlOlxuICogLy8gW3tpZDogMSwgdHlwZTogJ2NhdCd9LCB7aWQ6IDIsIHR5cGU6ICdkb2cnfSwge2lkOiAzLCB0eXBlOiAnbGlvbid9XTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVXBzZXJ0ICh1cGRhdGUpIHdpdGggYXJyYXkgb2Yga2V5c1xuICpcbiAqIGNvbnN0IGNyZWF0dXJlcyA9IFt7aWQ6IDEsIHR5cGU6ICdjYXQnLCBuYW1lOiAnQmVsbGEnfSwge2lkOiAyLCB0eXBlOiAnZG9nJywgbmFtZTogJ1NwYXJreSd9XTtcbiAqXG4gKiBjb25zdCBuZXdDYXQgPSB7aWQ6IDEsIHR5cGU6ICdsaW9uJywgbmFtZTogJ0JlbGxhJ307XG4gKlxuICogY29uc3QgdXBkYXRlZENyZWF0dXJlcyA9IHVwc2VydChjcmVhdHVyZXMsIG5ld0NhdCwgWydpZCcsICduYW1lJ10pO1xuICpcbiAqIC8vIHVwZGF0ZWRDcmVhdHVyZXMgd2lsbCBiZTpcbiAqIC8vIFt7aWQ6IDEsIHR5cGU6ICdsaW9uJywgbmFtZTogJ0JlbGxhJ30sIHtpZDogMiwgdHlwZTogJ2RvZycsIG5hbWU6ICdTcGFya3knfV07XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFVwZGF0ZSAoaW5zZXJ0KSB3aXRoIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqXG4gKiBjb25zdCBjcmVhdHVyZXMgPSBbe2lkOiAxLCB0eXBlOiAnY2F0J30sIHtpZDogMiwgdHlwZTogJ2RvZyd9XTtcbiAqXG4gKiBjb25zdCBuZXdDYXQgPSB7aWQ6IDMsIHR5cGU6ICdsaW9uJ307XG4gKlxuICogY29uc3QgdXBkYXRlZENyZWF0dXJlcyA9IHVwc2VydChjcmVhdHVyZXMsIG5ld0NhdCwgKGEsIGIpID0+IGEuaWQgPT09IGIuaWQpO1xuICpcbiAqIC8vIHVwZGF0ZWRDcmVhdHVyZXMgd2lsbCBiZTpcbiAqIC8vIFt7aWQ6IDEsIHR5cGU6ICdjYXQnfSwge2lkOiAyLCB0eXBlOiAnZG9nJ30sIHtpZDogMywgdHlwZTogJ2xpb24nfV07XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFVzYWdlIHdpdGggUnhTdGF0ZVxuICpcbiAqIGV4cG9ydCBjbGFzcyBMaXN0Q29tcG9uZW50IHtcbiAqXG4gKiAgICAvLyB0cmlnZ2VyIHdoaWNoIGdldHMgY2FsbGVkIG9uIGFkZC91cGRhdGUgKGZvciByZWFjdGl2ZSBpbXBsZW1lbnRhdGlvbilcbiAqICAgIHJlYWRvbmx5IGFkZE9yVXBkYXRlQ3JlYXR1cmUgPSBuZXcgU3ViamVjdDxDcmVhdHVyZT4oKTtcbiAqXG4gKiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0YXRlOiBSeFN0YXRlPENvbXBvbmVudFN0YXRlPikge1xuICogICAgICBjb25zdCBpbml0aWFsQ3JlYXR1cmVzID0gW3tpZDogMSwgdHlwZTogJ2NhdCcsIG5hbWU6ICdCZWxsYSd9LCB7aWQ6IDIsIHR5cGU6ICdkb2cnLCBuYW1lOiAnU3Bhcmt5J31dO1xuICogICAgICBzdGF0ZS5zZXQoeyBjcmVhdHVyZXM6IGluaXRpYWxDcmVhdHVyZXMgfSk7XG4gKiAgICAgIC8vIFJlYWN0aXZlIGltcGxlbWVudGF0aW9uXG4gKiAgICAgIHN0YXRlLmNvbm5lY3QoXG4gKiAgICAgICAgJ2NyZWF0dXJlcycsXG4gKiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZUNyZWF0dXJlLFxuICogICAgICAgICh7IGNyZWF0dXJlcyB9LCBjcmVhdHVyZVRvVXBzZXJ0KSA9PiB7XG4gKiAgICAgICAgICAgIHJldHVybiB1cHNlcnQoY3JlYXR1cmVzLCBjcmVhdHVyZVRvVXBzZXJ0LCAnaWQnKTtcbiAqICAgICAgICB9XG4gKiAgICAgICk7XG4gKiAgICB9XG4gKlxuICogICAgLy8gSW1wZXJhdGl2ZSBpbXBsZW1lbnRhdGlvblxuICogICAgdXBkYXRlQ3JlYXR1cmUoY3JlYXR1cmVUb1VwZGF0ZTogQ3JlYXR1cmUpOiB2b2lkIHtcbiAqICAgICAgICB0aGlzLnN0YXRlLnNldCh7IGNyZWF0dXJlczogdXBzZXJ0KHRoaXMuc3RhdGUuZ2V0KCdjcmVhdHVyZXMnKSwgY3JlYXR1cmVUb1VwZGF0ZSwgJ2lkJyl9KTtcbiAqICAgIH1cbiAqIH1cbiAqXG4gKiBAcmV0dXJucyBUW11cbiAqXG4gKiBAZG9jc1BhZ2UgdXBzZXJ0XG4gKiBAZG9jc0NhdGVnb3J5IHRyYW5zZm9ybWF0aW9uLWhlbHBlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwc2VydDxUPihcbiAgc291cmNlOiBUW10sXG4gIHVwZGF0ZTogUGFydGlhbDxUPltdIHwgUGFydGlhbDxUPixcbiAgY29tcGFyZT86IENvbXBhcmFibGVEYXRhPFQ+XG4pOiBUW10ge1xuICAvLyBjaGVjayBpbnB1dHMgZm9yIHZhbGlkaXR5XG4gIGNvbnN0IHVwZGF0ZXNBc0FycmF5ID1cbiAgICB1cGRhdGUgIT0gbnVsbCA/IChBcnJheS5pc0FycmF5KHVwZGF0ZSkgPyB1cGRhdGUgOiBbdXBkYXRlXSkgOiBbXTtcbiAgLy8gY2hlY2sgaW5wdXRzIGZvciB2YWxpZGl0eVxuICBjb25zdCBzb3VyY2VJc05vdEFycmF5ID0gIUFycmF5LmlzQXJyYXkoc291cmNlKTtcbiAgY29uc3QgaW52YWxpZElucHV0ID0gc291cmNlSXNOb3RBcnJheSAmJiB1cGRhdGVzQXNBcnJheS5sZW5ndGggPT09IDA7XG4gIC8vIGlmIHRoZSBzb3VyY2UgdmFsdWUgaXMgbm90IGFuIEFycmF5IG9yIHRoZSBpbnB1dCBpcyBub3QgZGVmaW5lZCByZXR1cm4gdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAvLyB0aGlzIGlzIHRoZSBjYXNlIGZvciBhbnkgZWRnZSBjYXNlOlxuICAvLyAnJywgbnVsbCwgdW5kZWZpbmVkLCBDdXN0b21PYmplY3RPZkRvb21BbmREYXJrbmVzcywgLi4uXG4gIGlmIChpbnZhbGlkSW5wdXQpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gaWYgc291cmNlIGlzIGVtcHR5IGFycmF5IG9yIG5vdCBhbiBhcnJheSwgYnV0IHRoZSB1cGRhdGVzIGFyZSB2YWxpZDpcbiAgLy8gcmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSB1cGRhdGVzIGFzIHJlc3VsdFxuICBpZiAodXBkYXRlc0FzQXJyYXkubGVuZ3RoID4gMCAmJiAoc291cmNlSXNOb3RBcnJheSB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiBbLi4udXBkYXRlc0FzQXJyYXldIGFzIFRbXTtcbiAgfVxuXG4gIGNvbnN0IGluc2VydHM6IFRbXSA9IFtdO1xuICBjb25zdCB1cGRhdGVzOiBSZWNvcmQ8bnVtYmVyLCBQYXJ0aWFsPFQ+PiA9IHt9O1xuICAvLyBwcm9jZXNzIHVwZGF0ZXMvaW5zZXJ0c1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgdXBkYXRlc0FzQXJyYXkpIHtcbiAgICBjb25zdCBtYXRjaCA9IHNvdXJjZS5maW5kSW5kZXgoKHNvdXJjZUl0ZW0pID0+XG4gICAgICB2YWx1ZXNDb21wYXJlcihpdGVtIGFzIFQsIHNvdXJjZUl0ZW0sIGNvbXBhcmUpXG4gICAgKTtcbiAgICAvLyBpZiBpdGVtIGFscmVhZHkgZXhpc3RzLCBzYXZlIGl0IGFzIHVwZGF0ZVxuICAgIGlmIChtYXRjaCAhPT0gLTEpIHtcbiAgICAgIHVwZGF0ZXNbbWF0Y2hdID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGNvbnNpZGVyIHRoaXMgYXMgaW5zZXJ0XG4gICAgICBpZiAoaXNPYmplY3RHdWFyZChpdGVtKSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBzaGFsbG93IGNvcHkgaWYgaXRlbSBpcyBhbiBvYmplY3RcbiAgICAgICAgaW5zZXJ0cy5wdXNoKHsgLi4uKGl0ZW0gYXMgVCkgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UganVzdCBwdXNoIGl0XG4gICAgICAgIGluc2VydHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1cGRhdGVkID0gc291cmNlLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gdXBkYXRlc1tpXTtcbiAgICAvLyBwcm9jZXNzIHRoZSB1cGRhdGVkXG4gICAgaWYgKHVwZGF0ZWRJdGVtICE9PSBudWxsICYmIHVwZGF0ZWRJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpc09iamVjdEd1YXJkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB7IC4uLml0ZW0sIC4uLnVwZGF0ZWRJdGVtIH0gYXMgVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVkSXRlbSBhcyBUO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG5cbiAgLy8gcmV0dXJuIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgdXBkYXRlZCBzb3VyY2UgJiB0aGUgaW5zZXJ0cyBhcyBuZXcgYXJyYXlcbiAgcmV0dXJuIHVwZGF0ZWQuY29uY2F0KGluc2VydHMpO1xufVxuIl19