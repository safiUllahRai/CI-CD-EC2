import { onStrategy, strategyHandling, } from '@rx-angular/cdk/render-strategies';
import { combineLatest, of } from 'rxjs';
import { catchError, distinctUntilChanged, map, switchMap, tap, } from 'rxjs/operators';
import { getTemplateHandler } from './list-view-handler';
import { createErrorHandler } from './render-error';
import { notifyAllParentsIfNeeded } from './utils';
export function createListTemplateManager(config) {
    const { templateSettings, renderSettings, trackBy, iterableDiffers } = config;
    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;
    const errorHandler = createErrorHandler(renderSettings.errorHandler);
    const ngZone = patchZone ? patchZone : undefined;
    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);
    let _differ;
    function getDiffer(values) {
        if (_differ) {
            return _differ;
        }
        return values
            ? (_differ = iterableDiffers.find(values).create(trackBy))
            : null;
    }
    //               type,  context
    /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide
     functions for not only create. developers than should have to provide create, move, remove,... the whole thing.
     i don't know if this is the right decision for a first RC */
    const listViewHandler = getTemplateHandler({
        ...templateSettings,
        initialTemplateRef: templateSettings.templateRef,
    });
    const viewContainerRef = templateSettings.viewContainerRef;
    let notifyParent = false;
    let changesArr;
    let partiallyFinished = false;
    return {
        nextStrategy(nextConfig) {
            strategyHandling$.next(nextConfig);
        },
        render(values$) {
            return values$.pipe(render());
        },
    };
    function handleError() {
        return (o$) => o$.pipe(catchError((err) => {
            partiallyFinished = false;
            errorHandler.handleError(err);
            return of(null);
        }));
    }
    function render() {
        return (o$) => combineLatest([
            o$,
            strategyHandling$.strategy$.pipe(distinctUntilChanged()),
        ]).pipe(map(([iterable, strategy]) => {
            const differ = getDiffer(iterable);
            let changes;
            if (differ) {
                if (partiallyFinished) {
                    const currentIterable = [];
                    for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {
                        const viewRef = viewContainerRef.get(i);
                        currentIterable[i] = viewRef.context.$implicit;
                    }
                    differ.diff(currentIterable);
                }
                changes = differ.diff(iterable);
            }
            return {
                changes,
                iterable,
                strategy,
            };
        }), 
        // Cancel old renders
        switchMap(({ changes, iterable, strategy }) => {
            if (!changes) {
                return of([]);
            }
            const values = iterable || [];
            // TODO: we might want to treat other iterables in a more performant way than Array.from()
            const items = Array.isArray(values) ? values : Array.from(iterable);
            const listChanges = listViewHandler.getListChanges(changes, items);
            changesArr = listChanges[0];
            const insertedOrRemoved = listChanges[1];
            const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);
            partiallyFinished = true;
            notifyParent = insertedOrRemoved && parent;
            return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => (partiallyFinished = false)), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));
        }), handleError());
    }
    /**
     * @internal
     *
     * returns an array of streams which process all of the view updates needed to reflect the latest diff to the
     * viewContainer.
     * I
     *
     * @param changes
     * @param strategy
     * @param count
     */
    function getObservablesFromChangesArray(changes, strategy, count) {
        return changes.length > 0
            ? changes.map((change) => {
                const payload = change[1];
                return onStrategy(change[0], strategy, (type) => {
                    switch (type) {
                        case 0 /* RxListTemplateChangeType.insert */:
                            listViewHandler.insertView(payload[0], payload[1], count);
                            break;
                        case 2 /* RxListTemplateChangeType.move */:
                            listViewHandler.moveView(payload[2], payload[0], payload[1], count);
                            break;
                        case 1 /* RxListTemplateChangeType.remove */:
                            listViewHandler.removeView(payload[1]);
                            break;
                        case 3 /* RxListTemplateChangeType.update */:
                            listViewHandler.updateView(payload[0], payload[1], count);
                            break;
                        case 4 /* RxListTemplateChangeType.context */:
                            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);
                            break;
                    }
                }, { ngZone });
            })
            : [of(null)];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdC10ZW1wbGF0ZS1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvdGVtcGxhdGUvc3JjL2xpYi9saXN0LXRlbXBsYXRlLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBU0EsT0FBTyxFQUNMLFVBQVUsRUFHVixnQkFBZ0IsR0FDakIsTUFBTSxtQ0FBbUMsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUF3QyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0UsT0FBTyxFQUNMLFVBQVUsRUFDVixvQkFBb0IsRUFDcEIsR0FBRyxFQUNILFNBQVMsRUFDVCxHQUFHLEdBQ0osTUFBTSxnQkFBZ0IsQ0FBQztBQUt4QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQU96RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFRbkQsTUFBTSxVQUFVLHlCQUF5QixDQUd2QyxNQU9EO0lBQ0MsTUFBTSxFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBQzlFLE1BQU0sRUFDSixtQkFBbUIsRUFDbkIsVUFBVSxFQUNWLEtBQUssRUFBRSxrQkFBa0IsRUFDekIsU0FBUyxFQUNULE1BQU0sR0FDUCxHQUFHLGNBQWMsQ0FBQztJQUNuQixNQUFNLFlBQVksR0FBRyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDckUsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUNqRCxNQUFNLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDLG1CQUFtQixFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRTVFLElBQUks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QUFFLENBQ1gsQ0FBQztZQUNKLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBJdGVyYWJsZUNoYW5nZXMsXG4gIEl0ZXJhYmxlRGlmZmVyLFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIE5nSXRlcmFibGUsXG4gIFRlbXBsYXRlUmVmLFxuICBUcmFja0J5RnVuY3Rpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgb25TdHJhdGVneSxcbiAgUnhTdHJhdGVneUNyZWRlbnRpYWxzLFxuICBSeFN0cmF0ZWd5TmFtZXMsXG4gIHN0cmF0ZWd5SGFuZGxpbmcsXG59IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9yZW5kZXItc3RyYXRlZ2llcyc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgbWFwLFxuICBzd2l0Y2hNYXAsXG4gIHRhcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgUnhMaXN0Vmlld0NvbXB1dGVkQ29udGV4dCxcbiAgUnhMaXN0Vmlld0NvbnRleHQsXG59IGZyb20gJy4vbGlzdC12aWV3LWNvbnRleHQnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGVIYW5kbGVyIH0gZnJvbSAnLi9saXN0LXZpZXctaGFuZGxlcic7XG5pbXBvcnQge1xuICBSeExpc3RUZW1wbGF0ZUNoYW5nZSxcbiAgUnhMaXN0VGVtcGxhdGVDaGFuZ2VUeXBlLFxuICBSeExpc3RUZW1wbGF0ZVNldHRpbmdzLFxuICBSeFJlbmRlclNldHRpbmdzLFxufSBmcm9tICcuL21vZGVsJztcbmltcG9ydCB7IGNyZWF0ZUVycm9ySGFuZGxlciB9IGZyb20gJy4vcmVuZGVyLWVycm9yJztcbmltcG9ydCB7IG5vdGlmeUFsbFBhcmVudHNJZk5lZWRlZCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJ4TGlzdE1hbmFnZXI8VD4ge1xuICBuZXh0U3RyYXRlZ3k6IChjb25maWc6IFJ4U3RyYXRlZ3lOYW1lcyB8IE9ic2VydmFibGU8UnhTdHJhdGVneU5hbWVzPikgPT4gdm9pZDtcblxuICByZW5kZXIoY2hhbmdlcyQ6IE9ic2VydmFibGU8TmdJdGVyYWJsZTxUPj4pOiBPYnNlcnZhYmxlPE5nSXRlcmFibGU8VD4gfCBudWxsPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpc3RUZW1wbGF0ZU1hbmFnZXI8XG4gIFQsXG4gIEMgZXh0ZW5kcyBSeExpc3RWaWV3Q29udGV4dDxUPlxuPihjb25maWc6IHtcbiAgcmVuZGVyU2V0dGluZ3M6IFJ4UmVuZGVyU2V0dGluZ3M7XG4gIHRlbXBsYXRlU2V0dGluZ3M6IFJ4TGlzdFRlbXBsYXRlU2V0dGluZ3M8VCwgQywgUnhMaXN0Vmlld0NvbXB1dGVkQ29udGV4dD4gJiB7XG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPEM+O1xuICB9O1xuICB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248VD47XG4gIGl0ZXJhYmxlRGlmZmVyczogSXRlcmFibGVEaWZmZXJzO1xufSk6IFJ4TGlzdE1hbmFnZXI8VD4ge1xuICBjb25zdCB7IHRlbXBsYXRlU2V0dGluZ3MsIHJlbmRlclNldHRpbmdzLCB0cmFja0J5LCBpdGVyYWJsZURpZmZlcnMgfSA9IGNvbmZpZztcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRTdHJhdGVneU5hbWUsXG4gICAgc3RyYXRlZ2llcyxcbiAgICBjZFJlZjogaW5qZWN0aW5nVmlld0NkUmVmLFxuICAgIHBhdGNoWm9uZSxcbiAgICBwYXJlbnQsXG4gIH0gPSByZW5kZXJTZXR0aW5ncztcbiAgY29uc3QgZXJyb3JIYW5kbGVyID0gY3JlYXRlRXJyb3JIYW5kbGVyKHJlbmRlclNldHRpbmdzLmVycm9ySGFuZGxlcik7XG4gIGNvbnN0IG5nWm9uZSA9IHBhdGNoWm9uZSA/IHBhdGNoWm9uZSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc3RyYXRlZ3lIYW5kbGluZyQgPSBzdHJhdGVneUhhbmRsaW5nKGRlZmF1bHRTdHJhdGVneU5hbWUsIHN0cmF0ZWdpZXMpO1xuXG4gIGxldCBfZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPiB8IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gZ2V0RGlmZmVyKHZhbHVlczogTmdJdGVyYWJsZTxUPik6IEl0ZXJhYmxlRGlmZmVyPFQ+IHwgbnVsbCB7XG4gICAgaWYgKF9kaWZmZXIpIHtcbiAgICAgIHJldHVybiBfZGlmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gICAgICA/IChfZGlmZmVyID0gaXRlcmFibGVEaWZmZXJzLmZpbmQodmFsdWVzKS5jcmVhdGUodHJhY2tCeSkpXG4gICAgICA6IG51bGw7XG4gIH1cbiAgLy8gICAgICAgICAgICAgICB0eXBlLCAgY29udGV4dFxuICAvKiBUT0RPIChyZWdhcmRpbmcgY3JlYXRlVmlldyk6IHRoaXMgaXMgY3VycmVudGx5IG5vdCBpbiB1c2UuIGZvciB0aGUgbGlzdC1tYW5hZ2VyIHRoaXMgd291bGQgbWVhbiB0byBwcm92aWRlXG4gICBmdW5jdGlvbnMgZm9yIG5vdCBvbmx5IGNyZWF0ZS4gZGV2ZWxvcGVycyB0aGFuIHNob3VsZCBoYXZlIHRvIHByb3ZpZGUgY3JlYXRlLCBtb3ZlLCByZW1vdmUsLi4uIHRoZSB3aG9sZSB0aGluZy5cbiAgIGkgZG9uJ3Qga25vdyBpZiB0aGlzIGlzIHRoZSByaWdodCBkZWNpc2lvbiBmb3IgYSBmaXJzdCBSQyAqL1xuICBjb25zdCBsaXN0Vmlld0hhbmRsZXIgPSBnZXRUZW1wbGF0ZUhhbmRsZXIoe1xuICAgIC4uLnRlbXBsYXRlU2V0dGluZ3MsXG4gICAgaW5pdGlhbFRlbXBsYXRlUmVmOiB0ZW1wbGF0ZVNldHRpbmdzLnRlbXBsYXRlUmVmLFxuICB9KTtcbiAgY29uc3Qgdmlld0NvbnRhaW5lclJlZiA9IHRlbXBsYXRlU2V0dGluZ3Mudmlld0NvbnRhaW5lclJlZjtcblxuICBsZXQgbm90aWZ5UGFyZW50ID0gZmFsc2U7XG4gIGxldCBjaGFuZ2VzQXJyOiBSeExpc3RUZW1wbGF0ZUNoYW5nZVtdO1xuICBsZXQgcGFydGlhbGx5RmluaXNoZWQgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIG5leHRTdHJhdGVneShuZXh0Q29uZmlnOiBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lOYW1lcz4pOiB2b2lkIHtcbiAgICAgIHN0cmF0ZWd5SGFuZGxpbmckLm5leHQobmV4dENvbmZpZyk7XG4gICAgfSxcbiAgICByZW5kZXIoXG4gICAgICB2YWx1ZXMkOiBPYnNlcnZhYmxlPE5nSXRlcmFibGU8VD4+XG4gICAgKTogT2JzZXJ2YWJsZTxOZ0l0ZXJhYmxlPFQ+IHwgbnVsbD4ge1xuICAgICAgcmV0dXJuIHZhbHVlcyQucGlwZShyZW5kZXIoKSk7XG4gICAgfSxcbiAgfTtcblxuICBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICByZXR1cm4gKG8kKSA9PlxuICAgICAgbyQucGlwZShcbiAgICAgICAgY2F0Y2hFcnJvcigoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHBhcnRpYWxseUZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuIG9mKG51bGwpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlcigpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248TmdJdGVyYWJsZTxUPiB8IG51bGw+IHtcbiAgICByZXR1cm4gKG8kOiBPYnNlcnZhYmxlPE5nSXRlcmFibGU8VD4+KTogT2JzZXJ2YWJsZTxOZ0l0ZXJhYmxlPFQ+IHwgbnVsbD4gPT5cbiAgICAgIGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICBvJCxcbiAgICAgICAgc3RyYXRlZ3lIYW5kbGluZyQuc3RyYXRlZ3kkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSksXG4gICAgICBdKS5waXBlKFxuICAgICAgICBtYXAoKFtpdGVyYWJsZSwgc3RyYXRlZ3ldKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGlmZmVyID0gZ2V0RGlmZmVyKGl0ZXJhYmxlKTtcbiAgICAgICAgICBsZXQgY2hhbmdlczogSXRlcmFibGVDaGFuZ2VzPFQ+O1xuICAgICAgICAgIGlmIChkaWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsbHlGaW5pc2hlZCkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SXRlcmFibGUgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aWV3Q29udGFpbmVyUmVmLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdSZWYgPSA8RW1iZWRkZWRWaWV3UmVmPEM+PnZpZXdDb250YWluZXJSZWYuZ2V0KGkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYWJsZVtpXSA9IHZpZXdSZWYuY29udGV4dC4kaW1wbGljaXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlmZmVyLmRpZmYoY3VycmVudEl0ZXJhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZXMgPSBkaWZmZXIuZGlmZihpdGVyYWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgaXRlcmFibGUsXG4gICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLy8gQ2FuY2VsIG9sZCByZW5kZXJzXG4gICAgICAgIHN3aXRjaE1hcCgoeyBjaGFuZ2VzLCBpdGVyYWJsZSwgc3RyYXRlZ3kgfSkgPT4ge1xuICAgICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG9mKFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gaXRlcmFibGUgfHwgW107XG4gICAgICAgICAgLy8gVE9ETzogd2UgbWlnaHQgd2FudCB0byB0cmVhdCBvdGhlciBpdGVyYWJsZXMgaW4gYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRoYW4gQXJyYXkuZnJvbSgpXG4gICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcbiAgICAgICAgICBjb25zdCBsaXN0Q2hhbmdlcyA9IGxpc3RWaWV3SGFuZGxlci5nZXRMaXN0Q2hhbmdlcyhjaGFuZ2VzLCBpdGVtcyk7XG4gICAgICAgICAgY2hhbmdlc0FyciA9IGxpc3RDaGFuZ2VzWzBdO1xuICAgICAgICAgIGNvbnN0IGluc2VydGVkT3JSZW1vdmVkID0gbGlzdENoYW5nZXNbMV07XG4gICAgICAgICAgY29uc3QgYXBwbHlDaGFuZ2VzJCA9IGdldE9ic2VydmFibGVzRnJvbUNoYW5nZXNBcnJheShcbiAgICAgICAgICAgIGNoYW5nZXNBcnIsXG4gICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICAgIGl0ZW1zLmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFydGlhbGx5RmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIG5vdGlmeVBhcmVudCA9IGluc2VydGVkT3JSZW1vdmVkICYmIHBhcmVudDtcbiAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlcyQubGVuZ3RoID4gMCA/IGFwcGx5Q2hhbmdlcyQgOiBbb2YobnVsbCldXG4gICAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgdGFwKCgpID0+IChwYXJ0aWFsbHlGaW5pc2hlZCA9IGZhbHNlKSksXG4gICAgICAgICAgICBub3RpZnlBbGxQYXJlbnRzSWZOZWVkZWQoXG4gICAgICAgICAgICAgIGluamVjdGluZ1ZpZXdDZFJlZixcbiAgICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICgpID0+IG5vdGlmeVBhcmVudCxcbiAgICAgICAgICAgICAgbmdab25lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgaGFuZGxlRXJyb3IoKSxcbiAgICAgICAgICAgIG1hcCgoKSA9PiBpdGVyYWJsZSlcbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgICAgaGFuZGxlRXJyb3IoKVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogcmV0dXJucyBhbiBhcnJheSBvZiBzdHJlYW1zIHdoaWNoIHByb2Nlc3MgYWxsIG9mIHRoZSB2aWV3IHVwZGF0ZXMgbmVlZGVkIHRvIHJlZmxlY3QgdGhlIGxhdGVzdCBkaWZmIHRvIHRoZVxuICAgKiB2aWV3Q29udGFpbmVyLlxuICAgKiBJXG4gICAqXG4gICAqIEBwYXJhbSBjaGFuZ2VzXG4gICAqIEBwYXJhbSBzdHJhdGVneVxuICAgKiBAcGFyYW0gY291bnRcbiAgICovXG4gIGZ1bmN0aW9uIGdldE9ic2VydmFibGVzRnJvbUNoYW5nZXNBcnJheShcbiAgICBjaGFuZ2VzOiBSeExpc3RUZW1wbGF0ZUNoYW5nZTxUPltdLFxuICAgIHN0cmF0ZWd5OiBSeFN0cmF0ZWd5Q3JlZGVudGlhbHMsXG4gICAgY291bnQ6IG51bWJlclxuICApOiBPYnNlcnZhYmxlPFJ4TGlzdFRlbXBsYXRlQ2hhbmdlVHlwZT5bXSB7XG4gICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID4gMFxuICAgICAgPyBjaGFuZ2VzLm1hcCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNoYW5nZVsxXTtcbiAgICAgICAgICByZXR1cm4gb25TdHJhdGVneShcbiAgICAgICAgICAgIGNoYW5nZVswXSxcbiAgICAgICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICAgICAgKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSeExpc3RUZW1wbGF0ZUNoYW5nZVR5cGUuaW5zZXJ0OlxuICAgICAgICAgICAgICAgICAgbGlzdFZpZXdIYW5kbGVyLmluc2VydFZpZXcocGF5bG9hZFswXSwgcGF5bG9hZFsxXSwgY291bnQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSeExpc3RUZW1wbGF0ZUNoYW5nZVR5cGUubW92ZTpcbiAgICAgICAgICAgICAgICAgIGxpc3RWaWV3SGFuZGxlci5tb3ZlVmlldyhcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsyXSxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY291bnRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJ4TGlzdFRlbXBsYXRlQ2hhbmdlVHlwZS5yZW1vdmU6XG4gICAgICAgICAgICAgICAgICBsaXN0Vmlld0hhbmRsZXIucmVtb3ZlVmlldyhwYXlsb2FkWzFdKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUnhMaXN0VGVtcGxhdGVDaGFuZ2VUeXBlLnVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgIGxpc3RWaWV3SGFuZGxlci51cGRhdGVWaWV3KHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUnhMaXN0VGVtcGxhdGVDaGFuZ2VUeXBlLmNvbnRleHQ6XG4gICAgICAgICAgICAgICAgICBsaXN0Vmlld0hhbmRsZXIudXBkYXRlVW5jaGFuZ2VkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY291bnRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbmdab25lIH1cbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgOiBbb2YobnVsbCldO1xuICB9XG59XG4iXX0=