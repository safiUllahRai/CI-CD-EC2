import { onStrategy, strategyHandling, } from '@rx-angular/cdk/render-strategies';
import { EMPTY, merge, of } from 'rxjs';
import { catchError, map, switchMap, tap, withLatestFrom, } from 'rxjs/operators';
import { createErrorHandler } from './render-error';
import { notifyAllParentsIfNeeded, templateHandling } from './utils';
/**
 * @internal
 *
 * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)
 *
 * @param customNextContext - projection function to provide custom properties as well as override existing
 */
export function notificationKindToViewContext(customNextContext) {
    // @TODO rethink overrides
    return {
        suspense: (notification) => {
            const $implicit = notification.value;
            return {
                $implicit,
                suspense: true,
                error: false,
                complete: false,
                ...customNextContext($implicit),
            };
        },
        next: (notification) => {
            const $implicit = notification.value;
            return {
                $implicit,
                suspense: false,
                error: false,
                complete: false,
                ...customNextContext($implicit),
            };
        },
        error: (notification) => {
            const $implicit = notification.value;
            return {
                $implicit,
                complete: false,
                error: notification.error || true,
                suspense: false,
                ...customNextContext($implicit),
            };
        },
        complete: (notification) => {
            const $implicit = notification.value;
            return {
                $implicit,
                error: false,
                complete: true,
                suspense: false,
                ...customNextContext($implicit),
            };
        },
    };
}
export function createTemplateManager(config) {
    const { renderSettings, notificationToTemplateName, templateSettings } = config;
    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;
    const errorHandler = createErrorHandler(renderSettings.errorHandler);
    const ngZone = patchZone ? patchZone : undefined;
    let activeTemplate;
    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);
    const templates = templateHandling(templateSettings.viewContainerRef);
    const viewContainerRef = templateSettings.viewContainerRef;
    const triggerHandling = config.templateTrigger$ || EMPTY;
    const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));
    return {
        addTemplateRef: (name, templateRef) => {
            templates.add(name, templateRef);
        },
        nextStrategy: strategyHandling$.next,
        render(values$) {
            let trg;
            let notification = {
                value: undefined,
                complete: false,
                error: false,
                kind: "suspense" /* RxNotificationKind.Suspense */,
                hasValue: false,
            };
            return merge(values$.pipe(tap((n) => (notification = n))), triggerHandling.pipe(tap((trigger) => (trg = trigger)))).pipe(switchMap(() => {
                const contextKind = trg || notification.kind;
                trg = undefined;
                const value = notification.value;
                const templateName = notificationToTemplateName[contextKind](value, templates);
                return templates.get$(templateName).pipe(map((template) => ({
                    template,
                    templateName,
                    notification,
                    contextKind,
                })));
            }), withLatestFrom(strategyHandling$.strategy$), 
            // Cancel old renders
            switchMap(([{ template, templateName, notification, contextKind }, strategy,]) => {
                const isNewTemplate = activeTemplate !== template || !template;
                const notifyParent = isNewTemplate && parent;
                return onStrategy(notification.value, strategy, (v, work, options) => {
                    const context = getContext[contextKind](notification);
                    if (isNewTemplate) {
                        // template has changed (undefined => next; suspense => next; ...)
                        // handle remove & insert
                        // remove current view if there is any
                        if (viewContainerRef.length > 0) {
                            // patch removal if needed
                            viewContainerRef.clear();
                        }
                        // create new view if any
                        if (template) {
                            // createEmbeddedView is already patched, no need for workFactory
                            templates.createEmbeddedView(templateName, context);
                        }
                    }
                    else if (template) {
                        // template didn't change, update it
                        // handle update
                        const view = viewContainerRef.get(0);
                        Object.keys(context).forEach((k) => {
                            view.context[k] = context[k];
                        });
                        // update view context, patch if needed
                        work(view, options.scope, notification);
                    }
                    activeTemplate = template;
                }, { ngZone }
                // we don't need to specify any scope here. The template manager is the only one
                // who will call `viewRef#detectChanges` on any of the templates it manages.
                // whenever a new value comes in, any pre-scheduled work of this taskManager will
                // be nooped before a new work will be scheduled. This happens because of the implementation
                // of `StrategyCredential#behavior`
                ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError((e) => {
                    errorHandler.handleError(e);
                    return of(e);
                }));
            }));
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGUtbWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2RrL3RlbXBsYXRlL3NyYy9saWIvdGVtcGxhdGUtbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQ0wsVUFBVSxFQUVWLGdCQUFnQixHQUNqQixNQUFNLG1DQUFtQyxDQUFDO0FBQzNDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQ0wsVUFBVSxFQUNWLEdBQUcsRUFDSCxTQUFTLEVBQ1QsR0FBRyxFQUNILGNBQWMsR0FDZixNQUFNLGdCQUFnQixDQUFDO0FBUXhCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQVVyRTs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsNkJBQTZCLENBQzNDLGlCQUF1QztJQUV2QywwQkFBMEI7SUFDMUIsT0FBTztRQUNMLFFBQVEsRUFBRSxDQUFDLFlBQXVDLEVBQUUsRUFBRTtZQUNwRCxNQUFNLFNBQVMsR0FBeUIsWUFBWSxDQUFDLEtBQVUsQ0FBQztZQUNoRSxPQUFPO2dCQUNMLFNBQVM7Z0JBQ1QsUUFBUSxFQUFFLElBQUk7Z0JBQ2QsS0FBSyxFQUFFLEtBQUs7Z0JBQ1osUUFBUSxFQUFFLEtBQUs7Z0JBQ2YsR0FBRyxpQkFBaUIsQ0FBQyxTQUFTLENBQUM7YUFDaEMsQ0FBQztRQUNKLENBQUM7UUFDRCxJQUFJLEVBQUUsQ0FBQyxZQUFtQyxFQUFFLEVBQUU7WUFDNUMsTUFBTSxTQUFTLEdBQXlCLFlBQVksQ0FBQyxLQUFVLENBQUM7WUFDaEUsT0FBTztnQkFDTCxTQUFTO2dCQUNULFFBQVEsRUFBRSxLQUFLO2dCQUNmLEtBQUssRUFBRSxLQUFLO2dCQUNaLFFB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Q0FDSCxDQUFDO1lBQ0osQ0FBQyxDQUNGLENBQ0YsQ0FBQztRQUNKLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVtYmVkZGVkVmlld1JlZiwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJ4Q29hbGVzY2luZ09wdGlvbnMgfSBmcm9tICdAcngtYW5ndWxhci9jZGsvY29hbGVzY2luZyc7XG5pbXBvcnQge1xuICBSeENvbXBsZXRlTm90aWZpY2F0aW9uLFxuICBSeEVycm9yTm90aWZpY2F0aW9uLFxuICBSeE5leHROb3RpZmljYXRpb24sXG4gIFJ4Tm90aWZpY2F0aW9uLFxuICBSeE5vdGlmaWNhdGlvbktpbmQsXG4gIFJ4U3VzcGVuc2VOb3RpZmljYXRpb24sXG59IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7XG4gIG9uU3RyYXRlZ3ksXG4gIFJ4UmVuZGVyV29yayxcbiAgc3RyYXRlZ3lIYW5kbGluZyxcbn0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3JlbmRlci1zdHJhdGVnaWVzJztcbmltcG9ydCB7IEVNUFRZLCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIG1hcCxcbiAgc3dpdGNoTWFwLFxuICB0YXAsXG4gIHdpdGhMYXRlc3RGcm9tLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICByeEJhc2VUZW1wbGF0ZU5hbWVzLFxuICBSeFJlbmRlckF3YXJlLFxuICBSeFJlbmRlclNldHRpbmdzLFxuICBSeFRlbXBsYXRlU2V0dGluZ3MsXG4gIFJ4Vmlld0NvbnRleHQsXG59IGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHsgY3JlYXRlRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi9yZW5kZXItZXJyb3InO1xuaW1wb3J0IHsgbm90aWZ5QWxsUGFyZW50c0lmTmVlZGVkLCB0ZW1wbGF0ZUhhbmRsaW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnhUZW1wbGF0ZU1hbmFnZXI8XG4gIFQsXG4gIEMgZXh0ZW5kcyBSeFZpZXdDb250ZXh0PFQ+LFxuICBOID0gcnhCYXNlVGVtcGxhdGVOYW1lcyB8IHN0cmluZ1xuPiBleHRlbmRzIFJ4UmVuZGVyQXdhcmU8VD4ge1xuICBhZGRUZW1wbGF0ZVJlZjogKG5hbWU6IE4sIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxDPikgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBBIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbWFwIG9mIHByb2plY3Rpb25zIHRvIHR1cm4gYSBub3RpZmljYXRpb24gb2YgYSBPYnNlcnZhYmxlIChuZXh0LCBlcnJvciwgY29tcGxldGUpXG4gKlxuICogQHBhcmFtIGN1c3RvbU5leHRDb250ZXh0IC0gcHJvamVjdGlvbiBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSBwcm9wZXJ0aWVzIGFzIHdlbGwgYXMgb3ZlcnJpZGUgZXhpc3RpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmaWNhdGlvbktpbmRUb1ZpZXdDb250ZXh0PFQ+KFxuICBjdXN0b21OZXh0Q29udGV4dDogKHZhbHVlOiBUKSA9PiBvYmplY3Rcbik6IFJ4Vmlld0NvbnRleHRNYXA8VD4ge1xuICAvLyBAVE9ETyByZXRoaW5rIG92ZXJyaWRlc1xuICByZXR1cm4ge1xuICAgIHN1c3BlbnNlOiAobm90aWZpY2F0aW9uOiBSeFN1c3BlbnNlTm90aWZpY2F0aW9uPFQ+KSA9PiB7XG4gICAgICBjb25zdCAkaW1wbGljaXQ6IFQgfCBudWxsIHwgdW5kZWZpbmVkID0gbm90aWZpY2F0aW9uLnZhbHVlIGFzIFQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkaW1wbGljaXQsXG4gICAgICAgIHN1c3BlbnNlOiB0cnVlLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgLi4uY3VzdG9tTmV4dENvbnRleHQoJGltcGxpY2l0KSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBuZXh0OiAobm90aWZpY2F0aW9uOiBSeE5leHROb3RpZmljYXRpb248VD4pID0+IHtcbiAgICAgIGNvbnN0ICRpbXBsaWNpdDogVCB8IG51bGwgfCB1bmRlZmluZWQgPSBub3RpZmljYXRpb24udmFsdWUgYXMgVDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRpbXBsaWNpdCxcbiAgICAgICAgc3VzcGVuc2U6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgLi4uY3VzdG9tTmV4dENvbnRleHQoJGltcGxpY2l0KSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBlcnJvcjogKG5vdGlmaWNhdGlvbjogUnhFcnJvck5vdGlmaWNhdGlvbjxUPikgPT4ge1xuICAgICAgY29uc3QgJGltcGxpY2l0OiBUIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG5vdGlmaWNhdGlvbi52YWx1ZSBhcyBUO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJGltcGxpY2l0LFxuICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBub3RpZmljYXRpb24uZXJyb3IgfHwgdHJ1ZSxcbiAgICAgICAgc3VzcGVuc2U6IGZhbHNlLFxuICAgICAgICAuLi5jdXN0b21OZXh0Q29udGV4dCgkaW1wbGljaXQpLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiAobm90aWZpY2F0aW9uOiBSeENvbXBsZXRlTm90aWZpY2F0aW9uPFQ+KSA9PiB7XG4gICAgICBjb25zdCAkaW1wbGljaXQ6IFQgfCBudWxsIHwgdW5kZWZpbmVkID0gbm90aWZpY2F0aW9uLnZhbHVlIGFzIFQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkaW1wbGljaXQsXG4gICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgY29tcGxldGU6IHRydWUsXG4gICAgICAgIHN1c3BlbnNlOiBmYWxzZSxcbiAgICAgICAgLi4uY3VzdG9tTmV4dENvbnRleHQoJGltcGxpY2l0KSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn1cbmV4cG9ydCB0eXBlIFJ4Vmlld0NvbnRleHRNYXA8VD4gPSBSZWNvcmQ8XG4gIFJ4Tm90aWZpY2F0aW9uS2luZCxcbiAgKHZhbHVlPzogYW55KSA9PiBQYXJ0aWFsPFJ4Vmlld0NvbnRleHQ8VD4+XG4+O1xuXG5leHBvcnQgdHlwZSBSeE5vdGlmaWNhdGlvblRlbXBsYXRlTmFtZU1hcDxULCBDLCBOPiA9IFJlY29yZDxcbiAgUnhOb3RpZmljYXRpb25LaW5kLFxuICAodmFsdWU/OiBULCB0ZW1wbGF0ZXM/OiB7IGdldDogKG5hbWU6IE4pID0+IFRlbXBsYXRlUmVmPEM+IH0pID0+IE5cbj47XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZU1hbmFnZXI8XG4gIFQsXG4gIEMgZXh0ZW5kcyBSeFZpZXdDb250ZXh0PFQ+LFxuICBOIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nXG4+KGNvbmZpZzoge1xuICByZW5kZXJTZXR0aW5nczogUnhSZW5kZXJTZXR0aW5ncztcbiAgdGVtcGxhdGVTZXR0aW5nczogUnhUZW1wbGF0ZVNldHRpbmdzPFQsIEM+O1xuICB0ZW1wbGF0ZVRyaWdnZXIkPzogT2JzZXJ2YWJsZTxSeE5vdGlmaWNhdGlvbktpbmQ+O1xuICBub3RpZmljYXRpb25Ub1RlbXBsYXRlTmFtZTogUnhOb3RpZmljYXRpb25UZW1wbGF0ZU5hbWVNYXA8VCwgQywgTj47XG59KTogUnhUZW1wbGF0ZU1hbmFnZXI8VCwgQywgTj4ge1xuICBjb25zdCB7IHJlbmRlclNldHRpbmdzLCBub3RpZmljYXRpb25Ub1RlbXBsYXRlTmFtZSwgdGVtcGxhdGVTZXR0aW5ncyB9ID1cbiAgICBjb25maWc7XG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0U3RyYXRlZ3lOYW1lLFxuICAgIHN0cmF0ZWdpZXMsXG4gICAgY2RSZWY6IGluamVjdGluZ1ZpZXdDZFJlZixcbiAgICBwYXRjaFpvbmUsXG4gICAgcGFyZW50LFxuICB9ID0gcmVuZGVyU2V0dGluZ3M7XG5cbiAgY29uc3QgZXJyb3JIYW5kbGVyID0gY3JlYXRlRXJyb3JIYW5kbGVyKHJlbmRlclNldHRpbmdzLmVycm9ySGFuZGxlcik7XG4gIGNvbnN0IG5nWm9uZSA9IHBhdGNoWm9uZSA/IHBhdGNoWm9uZSA6IHVuZGVmaW5lZDtcblxuICBsZXQgYWN0aXZlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPEM+O1xuXG4gIGNvbnN0IHN0cmF0ZWd5SGFuZGxpbmckID0gc3RyYXRlZ3lIYW5kbGluZyhkZWZhdWx0U3RyYXRlZ3lOYW1lLCBzdHJhdGVnaWVzKTtcbiAgY29uc3QgdGVtcGxhdGVzID0gdGVtcGxhdGVIYW5kbGluZzxOLCBDPih0ZW1wbGF0ZVNldHRpbmdzLnZpZXdDb250YWluZXJSZWYpO1xuICBjb25zdCB2aWV3Q29udGFpbmVyUmVmID0gdGVtcGxhdGVTZXR0aW5ncy52aWV3Q29udGFpbmVyUmVmO1xuXG4gIGNvbnN0IHRyaWdnZXJIYW5kbGluZyA9IGNvbmZpZy50ZW1wbGF0ZVRyaWdnZXIkIHx8IEVNUFRZO1xuICBjb25zdCBnZXRDb250ZXh0ID0gbm90aWZpY2F0aW9uS2luZFRvVmlld0NvbnRleHQoXG4gICAgdGVtcGxhdGVTZXR0aW5ncy5jdXN0b21Db250ZXh0IHx8ICgoKSA9PiAoe30pKVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgYWRkVGVtcGxhdGVSZWY6IChuYW1lOiBOLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8Qz4pID0+IHtcbiAgICAgIHRlbXBsYXRlcy5hZGQobmFtZSwgdGVtcGxhdGVSZWYpO1xuICAgIH0sXG4gICAgbmV4dFN0cmF0ZWd5OiBzdHJhdGVneUhhbmRsaW5nJC5uZXh0LFxuICAgIHJlbmRlcih2YWx1ZXMkOiBPYnNlcnZhYmxlPFJ4Tm90aWZpY2F0aW9uPFQ+Pik6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICBsZXQgdHJnOiBSeE5vdGlmaWNhdGlvbktpbmQgfCB1bmRlZmluZWQ7XG4gICAgICBsZXQgbm90aWZpY2F0aW9uOiBSeE5vdGlmaWNhdGlvbjxUPiA9IHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIGtpbmQ6IFJ4Tm90aWZpY2F0aW9uS2luZC5TdXNwZW5zZSxcbiAgICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG1lcmdlKFxuICAgICAgICB2YWx1ZXMkLnBpcGUodGFwKChuKSA9PiAobm90aWZpY2F0aW9uID0gbikpKSxcbiAgICAgICAgdHJpZ2dlckhhbmRsaW5nLnBpcGUoXG4gICAgICAgICAgdGFwPFJ4Tm90aWZpY2F0aW9uS2luZD4oKHRyaWdnZXIpID0+ICh0cmcgPSB0cmlnZ2VyKSlcbiAgICAgICAgKVxuICAgICAgKS5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHRLaW5kOiBSeE5vdGlmaWNhdGlvbktpbmQgPSB0cmcgfHwgbm90aWZpY2F0aW9uLmtpbmQ7XG4gICAgICAgICAgdHJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHZhbHVlOiBUID0gbm90aWZpY2F0aW9uLnZhbHVlIGFzIFQ7XG4gICAgICAgICAgY29uc3QgdGVtcGxhdGVOYW1lID0gbm90aWZpY2F0aW9uVG9UZW1wbGF0ZU5hbWVbY29udGV4dEtpbmRdKFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0ZW1wbGF0ZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZXMuZ2V0JCh0ZW1wbGF0ZU5hbWUpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKHRlbXBsYXRlKSA9PiAoe1xuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVOYW1lLFxuICAgICAgICAgICAgICBub3RpZmljYXRpb24sXG4gICAgICAgICAgICAgIGNvbnRleHRLaW5kLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHN0cmF0ZWd5SGFuZGxpbmckLnN0cmF0ZWd5JCksXG4gICAgICAgIC8vIENhbmNlbCBvbGQgcmVuZGVyc1xuICAgICAgICBzd2l0Y2hNYXAoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIHsgdGVtcGxhdGUsIHRlbXBsYXRlTmFtZSwgbm90aWZpY2F0aW9uLCBjb250ZXh0S2luZCB9LFxuICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNOZXdUZW1wbGF0ZSA9IGFjdGl2ZVRlbXBsYXRlICE9PSB0ZW1wbGF0ZSB8fCAhdGVtcGxhdGU7XG4gICAgICAgICAgICBjb25zdCBub3RpZnlQYXJlbnQgPSBpc05ld1RlbXBsYXRlICYmIHBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBvblN0cmF0ZWd5KFxuICAgICAgICAgICAgICBub3RpZmljYXRpb24udmFsdWUsXG4gICAgICAgICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAodjogVCwgd29yazogUnhSZW5kZXJXb3JrLCBvcHRpb25zOiBSeENvYWxlc2NpbmdPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IDxDPmdldENvbnRleHRbY29udGV4dEtpbmRdKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRlbXBsYXRlIGhhcyBjaGFuZ2VkICh1bmRlZmluZWQgPT4gbmV4dDsgc3VzcGVuc2UgPT4gbmV4dDsgLi4uKVxuICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHJlbW92ZSAmIGluc2VydFxuICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgdmlldyBpZiB0aGVyZSBpcyBhbnlcbiAgICAgICAgICAgICAgICAgIGlmICh2aWV3Q29udGFpbmVyUmVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0Y2ggcmVtb3ZhbCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgdmlld0NvbnRhaW5lclJlZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyB2aWV3IGlmIGFueVxuICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZUVtYmVkZGVkVmlldyBpcyBhbHJlYWR5IHBhdGNoZWQsIG5vIG5lZWQgZm9yIHdvcmtGYWN0b3J5XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5jcmVhdGVFbWJlZGRlZFZpZXcodGVtcGxhdGVOYW1lLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAvLyB0ZW1wbGF0ZSBkaWRuJ3QgY2hhbmdlLCB1cGRhdGUgaXRcbiAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSA8RW1iZWRkZWRWaWV3UmVmPEM+PnZpZXdDb250YWluZXJSZWYuZ2V0KDApO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGV4dCkuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRleHRba10gPSBjb250ZXh0W2tdO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlldyBjb250ZXh0LCBwYXRjaCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgIHdvcmsodmlldywgb3B0aW9ucy5zY29wZSwgbm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aXZlVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeyBuZ1pvbmUgfVxuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHNwZWNpZnkgYW55IHNjb3BlIGhlcmUuIFRoZSB0ZW1wbGF0ZSBtYW5hZ2VyIGlzIHRoZSBvbmx5IG9uZVxuICAgICAgICAgICAgICAvLyB3aG8gd2lsbCBjYWxsIGB2aWV3UmVmI2RldGVjdENoYW5nZXNgIG9uIGFueSBvZiB0aGUgdGVtcGxhdGVzIGl0IG1hbmFnZXMuXG4gICAgICAgICAgICAgIC8vIHdoZW5ldmVyIGEgbmV3IHZhbHVlIGNvbWVzIGluLCBhbnkgcHJlLXNjaGVkdWxlZCB3b3JrIG9mIHRoaXMgdGFza01hbmFnZXIgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSBub29wZWQgYmVmb3JlIGEgbmV3IHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQuIFRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAvLyBvZiBgU3RyYXRlZ3lDcmVkZW50aWFsI2JlaGF2aW9yYFxuICAgICAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgICBub3RpZnlBbGxQYXJlbnRzSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgaW5qZWN0aW5nVmlld0NkUmVmLFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICgpID0+IG5vdGlmeVBhcmVudCxcbiAgICAgICAgICAgICAgICBuZ1pvbmVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YoZSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICB9O1xufVxuIl19