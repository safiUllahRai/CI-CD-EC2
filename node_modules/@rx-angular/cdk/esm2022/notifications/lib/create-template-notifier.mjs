import { from, isObservable, NEVER, Observable, ReplaySubject, } from 'rxjs';
import { distinctUntilChanged, map, startWith, switchMap, tap, } from 'rxjs/operators';
import { toRxSuspenseNotification } from './notification-transforms';
import { rxMaterialize } from './rx-materialize';
/**
 * @description
 * Sends value and an initial `undefined` as value With a NEVER.
 * This is needed to render the suspense template and avoid completing (and render the complete template).
 * @param value
 */
const emitAndDontComplete = (value) => NEVER.pipe(startWith(value));
/**
 * This helper is responsible for turning a stream of materialized notifications
 * (next error, complete as object in the next stream) into an enriched version with an additional suspense
 * notification type.
 *
 * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.
 * This value is important in the template to show an e.g. error and also have access to the last emitted value of
 * next.
 * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner
 * in case of the suspense state.
 *
 * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification
 * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification
 * and assign it as new value to the notification
 */
const handleSuspenseAndLastValueInNotifications = () => {
    // Used to store the last value per handleSuspenseAndLastValueInNotifications call
    let latestNextValue;
    // returns a projection function with a lastValue cache
    return (notification) => {
        // if it is the notification is of type next we take its value
        // otherwise we keep the existing last value
        if (notification.kind === "next" /* RxNotificationKind.Next */) {
            latestNextValue = notification.value;
        }
        // If a next notification enters with a value of undefined we turn it into a suspense notification
        if (notification.kind === "next" /* RxNotificationKind.Next */ &&
            notification.value === undefined) {
            return toRxSuspenseNotification(undefined);
        }
        // If a Notification of type error, complete or suspense enters we assign the latest last value to them.
        // This is needed to access the old value in case of error or complete.
        // Next notifications will pass as they are.
        if (notification.kind === "error" /* RxNotificationKind.Error */ ||
            notification.kind === "complete" /* RxNotificationKind.Complete */ ||
            notification.kind === "suspense" /* RxNotificationKind.Suspense */) {
            notification.value = latestNextValue;
        }
        return notification;
    };
};
/**
 * @internal
 *
 * @description
 * This factory function returns an object that can be driven imperatively over a `next` method.
 * Internally it prepares the incoming values for rendering by turning them into "template notifications",
 * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing
 *   or suspense states.
 *
 * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.
 * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the
 *   display of the default template as well as the suspense, error, complete templates.
 */
export function createTemplateNotifier() {
    // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties
    const observablesSubject = new ReplaySubject(1);
    let emittedValueOnce = false;
    const values$ = observablesSubject.pipe(distinctUntilChanged(), 
    // handle static values inc null assignment and new Observable or Promises
    map((observable$) => {
        if (isObservableInput(observable$)) {
            return skipSuspenseIfHasValue(observable$);
        }
        else if (isSubscribableInput(observable$)) {
            return skipSuspenseIfHasValue(mapSubscribableToObservable(observable$));
        }
        else if (!emittedValueOnce && observable$ === undefined) {
            return NEVER;
        }
        return emitAndDontComplete(observable$);
    }), switchMap((o) => {
        return o.pipe(tap(() => (emittedValueOnce = true)), distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));
    }));
    return {
        next(observable) {
            observablesSubject.next(observable);
        },
        withInitialSuspense(withInitialSuspense) {
            emittedValueOnce = emittedValueOnce || withInitialSuspense;
        },
        values$,
    };
    /**
     * @description
     * returns an observable that starts with an undefined value in case the input
     * observable$ does not emit a value immediately.
     * This is needed in order to skip the suspense template when we already know
     * there will be a next template rendered afterwards
     * @param observable$
     */
    function skipSuspenseIfHasValue(observable$) {
        return new Observable((subscriber) => {
            let startWithUndefined = true;
            const inner = from(observable$).subscribe({
                next: (v) => {
                    startWithUndefined = false;
                    subscriber.next(v);
                },
                error: (e) => {
                    startWithUndefined = false;
                    subscriber.error(e);
                },
                complete: () => subscriber.complete(),
            });
            if (emittedValueOnce && startWithUndefined) {
                subscriber.next(undefined);
            }
            return () => {
                inner.unsubscribe();
            };
        });
    }
}
function isObservableInput(input) {
    return (typeof input?.then === 'function' || isObservable(input));
}
function isSubscribableInput(input) {
    return typeof input?.subscribe === 'function';
}
function mapSubscribableToObservable(input) {
    return new Observable((subscriber) => {
        const sub = input.subscribe({ next: (value) => subscriber.next(value) });
        return () => {
            sub.unsubscribe();
        };
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLXRlbXBsYXRlLW5vdGlmaWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvbm90aWZpY2F0aW9ucy9zcmMvbGliL2NyZWF0ZS10ZW1wbGF0ZS1ub3RpZmllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsSUFBSSxFQUNKLFlBQVksRUFDWixLQUFLLEVBQ0wsVUFBVSxFQUVWLGFBQWEsR0FFZCxNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsR0FBRyxFQUNILFNBQVMsRUFDVCxTQUFTLEVBQ1QsR0FBRyxHQUNKLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDckUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRWpEOzs7OztHQUtHO0FBQ0gsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUVwRTs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0seUNBQXlDLEdBQUcsR0FBTSxFQUFFO0lBQ3hELGtGQUFrRjtJQUNsRixJQUFJLGVBQWtCLENBQUM7SUFFdkIsdURBQXVEO0lBQ3ZELE9BQU8sQ0FBQyxZQUErQixFQUFxQixFQUFFO1FBQzVELDhEQUE4RDtRQUM5RCw0Q0FBNEM7UUFDNUMsSUFBSSxZQUFZLENBQUMsSUFBSSx5Q0FBNEIsRUFBRSxDQUFDO1lBQ2xELGVBQWUsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDO1FBQ3ZDLENBQUM7UUFFRCxrR0FBa0c7UUFDbEcsSUFDRSxZQUFZLENBQUMsSUFBSSx5Q0FBNEI7WUFDN0MsWUFBWSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQ2hDLENBQUM7WUFDRCxPQUFPLHdCQUF3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QyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDN0IsQ0FBQztZQUNELE9BQU8sR0FBRyxFQUFFO2dCQUNWLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUN0QixDQUFDLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBSSxLQUFjO0lBQzFDLE9BQU8sQ0FDTCxPQUFRLEtBQW9CLEVBQUUsSUFBSSxLQUFLLFVBQVUsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQ3pFLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBSSxLQUFjO0lBQzVDLE9BQU8sT0FBUSxLQUF5QixFQUFFLFNBQVMsS0FBSyxVQUFVLENBQUM7QUFDckUsQ0FBQztBQUVELFNBQVMsMkJBQTJCLENBQUksS0FBc0I7SUFDNUQsT0FBTyxJQUFJLFVBQVUsQ0FBSSxDQUFDLFVBQVUsRUFBRSxFQUFFO1FBQ3RDLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLE9BQU8sR0FBRyxFQUFFO1lBQ1YsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BCLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGZyb20sXG4gIGlzT2JzZXJ2YWJsZSxcbiAgTkVWRVIsXG4gIE9ic2VydmFibGUsXG4gIE9ic2VydmFibGVJbnB1dCxcbiAgUmVwbGF5U3ViamVjdCxcbiAgU3Vic2NyaWJhYmxlLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuICBtYXAsXG4gIHN0YXJ0V2l0aCxcbiAgc3dpdGNoTWFwLFxuICB0YXAsXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFJ4Tm90aWZpY2F0aW9uLCBSeE5vdGlmaWNhdGlvbktpbmQgfSBmcm9tICcuL21vZGVsJztcbmltcG9ydCB7IHRvUnhTdXNwZW5zZU5vdGlmaWNhdGlvbiB9IGZyb20gJy4vbm90aWZpY2F0aW9uLXRyYW5zZm9ybXMnO1xuaW1wb3J0IHsgcnhNYXRlcmlhbGl6ZSB9IGZyb20gJy4vcngtbWF0ZXJpYWxpemUnO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU2VuZHMgdmFsdWUgYW5kIGFuIGluaXRpYWwgYHVuZGVmaW5lZGAgYXMgdmFsdWUgV2l0aCBhIE5FVkVSLlxuICogVGhpcyBpcyBuZWVkZWQgdG8gcmVuZGVyIHRoZSBzdXNwZW5zZSB0ZW1wbGF0ZSBhbmQgYXZvaWQgY29tcGxldGluZyAoYW5kIHJlbmRlciB0aGUgY29tcGxldGUgdGVtcGxhdGUpLlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmNvbnN0IGVtaXRBbmREb250Q29tcGxldGUgPSAodmFsdWUpID0+IE5FVkVSLnBpcGUoc3RhcnRXaXRoKHZhbHVlKSk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgaXMgcmVzcG9uc2libGUgZm9yIHR1cm5pbmcgYSBzdHJlYW0gb2YgbWF0ZXJpYWxpemVkIG5vdGlmaWNhdGlvbnNcbiAqIChuZXh0IGVycm9yLCBjb21wbGV0ZSBhcyBvYmplY3QgaW4gdGhlIG5leHQgc3RyZWFtKSBpbnRvIGFuIGVucmljaGVkIHZlcnNpb24gd2l0aCBhbiBhZGRpdGlvbmFsIHN1c3BlbnNlXG4gKiBub3RpZmljYXRpb24gdHlwZS5cbiAqXG4gKiBJZiBhIG5vdGlmaWNhdGlvbiBlbnRlcnMgYW5kIGlzIG9mIHR5cGUgbmV4dCB3ZSBzdG9yZSB0bmUgdmFsdWUgb2YgYG5vdGlmaWNhdGlvbi5uZXh0YCBhcyBsYXN0IHZhbHVlIGVtaXR0ZWQuXG4gKiBUaGlzIHZhbHVlIGlzIGltcG9ydGFudCBpbiB0aGUgdGVtcGxhdGUgdG8gc2hvdyBhbiBlLmcuIGVycm9yIGFuZCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoZSBsYXN0IGVtaXR0ZWQgdmFsdWUgb2ZcbiAqIG5leHQuXG4gKiBUaGUgdmFsdWUgY2FuIGJlIHZlcnkgdXNlZnVsIGluIGVycm9yIG9yIGNvbXBsZXRlIG1lc3NhZ2VzIG9yIHRvIGRpc3BsYXkgdGhlIG9sZCB2YWx1ZSBvdmVybGF5cyBieSBhIGxvYWRpbmcgc3Bpbm5lclxuICogaW4gY2FzZSBvZiB0aGUgc3VzcGVuc2Ugc3RhdGUuXG4gKlxuICogSWYgYSBub3RpZmljYXRpb24gb2Yga2luZCBgbmV4dGAgZW50ZXJzIGFuZCBpdHMgdmFsdWUgaXMgdW5kZWZpbmVkIHdlIHR1cm4gaXQgaW50byBhIHN1c3BlbnNlIG5vdGlmaWNhdGlvblxuICogSWYgYSBub3RpZmljYXRpb24gb2Yga2luZCBgZXJyb3JgLCBgY29tcGxldGVgLCBgc3VzcGVuc2VgIGVudGVycyB3ZSB0YWtlIHRoZSBsYXN0IHZhbHVlIGZyb20gb2YgYSBuZXh0IG5vdGlmaWNhdGlvblxuICogYW5kIGFzc2lnbiBpdCBhcyBuZXcgdmFsdWUgdG8gdGhlIG5vdGlmaWNhdGlvblxuICovXG5jb25zdCBoYW5kbGVTdXNwZW5zZUFuZExhc3RWYWx1ZUluTm90aWZpY2F0aW9ucyA9IDxUPigpID0+IHtcbiAgLy8gVXNlZCB0byBzdG9yZSB0aGUgbGFzdCB2YWx1ZSBwZXIgaGFuZGxlU3VzcGVuc2VBbmRMYXN0VmFsdWVJbk5vdGlmaWNhdGlvbnMgY2FsbFxuICBsZXQgbGF0ZXN0TmV4dFZhbHVlOiBUO1xuXG4gIC8vIHJldHVybnMgYSBwcm9qZWN0aW9uIGZ1bmN0aW9uIHdpdGggYSBsYXN0VmFsdWUgY2FjaGVcbiAgcmV0dXJuIChub3RpZmljYXRpb246IFJ4Tm90aWZpY2F0aW9uPFQ+KTogUnhOb3RpZmljYXRpb248VD4gPT4ge1xuICAgIC8vIGlmIGl0IGlzIHRoZSBub3RpZmljYXRpb24gaXMgb2YgdHlwZSBuZXh0IHdlIHRha2UgaXRzIHZhbHVlXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGtlZXAgdGhlIGV4aXN0aW5nIGxhc3QgdmFsdWVcbiAgICBpZiAobm90aWZpY2F0aW9uLmtpbmQgPT09IFJ4Tm90aWZpY2F0aW9uS2luZC5OZXh0KSB7XG4gICAgICBsYXRlc3ROZXh0VmFsdWUgPSBub3RpZmljYXRpb24udmFsdWU7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBuZXh0IG5vdGlmaWNhdGlvbiBlbnRlcnMgd2l0aCBhIHZhbHVlIG9mIHVuZGVmaW5lZCB3ZSB0dXJuIGl0IGludG8gYSBzdXNwZW5zZSBub3RpZmljYXRpb25cbiAgICBpZiAoXG4gICAgICBub3RpZmljYXRpb24ua2luZCA9PT0gUnhOb3RpZmljYXRpb25LaW5kLk5leHQgJiZcbiAgICAgIG5vdGlmaWNhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gdG9SeFN1c3BlbnNlTm90aWZpY2F0aW9uKHVuZGVmaW5lZCkgYXMgUnhOb3RpZmljYXRpb248VD47XG4gICAgfVxuXG4gICAgLy8gSWYgYSBOb3RpZmljYXRpb24gb2YgdHlwZSBlcnJvciwgY29tcGxldGUgb3Igc3VzcGVuc2UgZW50ZXJzIHdlIGFzc2lnbiB0aGUgbGF0ZXN0IGxhc3QgdmFsdWUgdG8gdGhlbS5cbiAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhY2Nlc3MgdGhlIG9sZCB2YWx1ZSBpbiBjYXNlIG9mIGVycm9yIG9yIGNvbXBsZXRlLlxuICAgIC8vIE5leHQgbm90aWZpY2F0aW9ucyB3aWxsIHBhc3MgYXMgdGhleSBhcmUuXG4gICAgaWYgKFxuICAgICAgbm90aWZpY2F0aW9uLmtpbmQgPT09IFJ4Tm90aWZpY2F0aW9uS2luZC5FcnJvciB8fFxuICAgICAgbm90aWZpY2F0aW9uLmtpbmQgPT09IFJ4Tm90aWZpY2F0aW9uS2luZC5Db21wbGV0ZSB8fFxuICAgICAgbm90aWZpY2F0aW9uLmtpbmQgPT09IFJ4Tm90aWZpY2F0aW9uS2luZC5TdXNwZW5zZVxuICAgICkge1xuICAgICAgbm90aWZpY2F0aW9uLnZhbHVlID0gbGF0ZXN0TmV4dFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBub3RpZmljYXRpb24gYXMgUnhOb3RpZmljYXRpb248VD47XG4gIH07XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGRyaXZlbiBpbXBlcmF0aXZlbHkgb3ZlciBhIGBuZXh0YCBtZXRob2QuXG4gKiBJbnRlcm5hbGx5IGl0IHByZXBhcmVzIHRoZSBpbmNvbWluZyB2YWx1ZXMgZm9yIHJlbmRlcmluZyBieSB0dXJuaW5nIHRoZW0gaW50byBcInRlbXBsYXRlIG5vdGlmaWNhdGlvbnNcIixcbiAqIGFuIGV4dGVuZGVkIGBPYnNlcnZhYmxlTm90aWZpY2F0aW9uYCBvYmplY3QgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJlc3BlY3RpdmUgdGVtcGxhdGUgZm9yIHZhbHVlcywgZXJyb3JzLCBjb21wbGV0aW5nXG4gKiAgIG9yIHN1c3BlbnNlIHN0YXRlcy5cbiAqXG4gKiBJbnRlcm5hbGx5IGl0IGhhbmRsZXMgZGlmZmVyZW50IGVkZ2UgY2FzZXMgZm9yIGluaXRpYWwgZW1pdHMuIFRoaXMgaGVscHMgdG8gaGF2ZSBvciB0ZW1wbGF0ZSBjcmVhdGlvbiBsYXp5LlxuICogQWxzbyBpdCBtYXBzIGFueSBPYnNlcnZhYmxlIHRvIFJ4Tm90aWZpY2F0aW9ucy4gVGhlc2Ugbm90aWZpY2F0aW9ucyBhcmUgYm91bmQgdG8gdGhlIHZpZXcgbGF0ZXIgYW5kIGhhbmRsZSB0aGVcbiAqICAgZGlzcGxheSBvZiB0aGUgZGVmYXVsdCB0ZW1wbGF0ZSBhcyB3ZWxsIGFzIHRoZSBzdXNwZW5zZSwgZXJyb3IsIGNvbXBsZXRlIHRlbXBsYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlTm90aWZpZXI8VT4oKToge1xuICB2YWx1ZXMkOiBPYnNlcnZhYmxlPFJ4Tm90aWZpY2F0aW9uPFU+PjtcbiAgbmV4dChvYnNlcnZhYmxlOiBPYnNlcnZhYmxlSW5wdXQ8VT4gfCBVIHwgU3Vic2NyaWJhYmxlPFU+KTogdm9pZDtcbiAgd2l0aEluaXRpYWxTdXNwZW5zZSh3aXRoSW5pdGlhbFN1c3BlbnNlOiBib29sZWFuKTogdm9pZDtcbn0ge1xuICAvLyBBIFN1YmplY3QgZHJpdmVuIGZyb20gdGhlIG91dHNpZGUsIGl0IGNhbiBjb250YWluIE9ic2VydmFibGVzLCBzdGF0aWMgdmFsdWVzIG51bGwgYW5kIHVuZGVmaW5lZCBvbiBwdXJwb3NlIG9mIGZyb20gdW5hc3NpZ25lZCBwcm9wZXJ0aWVzXG4gIGNvbnN0IG9ic2VydmFibGVzU3ViamVjdCA9IG5ldyBSZXBsYXlTdWJqZWN0PFxuICAgIE9ic2VydmFibGVJbnB1dDxVPiB8IFUgfCBTdWJzY3JpYmFibGU8VT5cbiAgPigxKTtcblxuICBsZXQgZW1pdHRlZFZhbHVlT25jZSA9IGZhbHNlO1xuXG4gIGNvbnN0IHZhbHVlcyQgPSBvYnNlcnZhYmxlc1N1YmplY3QucGlwZShcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgIC8vIGhhbmRsZSBzdGF0aWMgdmFsdWVzIGluYyBudWxsIGFzc2lnbm1lbnQgYW5kIG5ldyBPYnNlcnZhYmxlIG9yIFByb21pc2VzXG4gICAgbWFwKChvYnNlcnZhYmxlJCk6IE9ic2VydmFibGVJbnB1dDxVPiB8IFUgPT4ge1xuICAgICAgaWYgKGlzT2JzZXJ2YWJsZUlucHV0PFU+KG9ic2VydmFibGUkKSkge1xuICAgICAgICByZXR1cm4gc2tpcFN1c3BlbnNlSWZIYXNWYWx1ZShvYnNlcnZhYmxlJCk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3Vic2NyaWJhYmxlSW5wdXQ8VT4ob2JzZXJ2YWJsZSQpKSB7XG4gICAgICAgIHJldHVybiBza2lwU3VzcGVuc2VJZkhhc1ZhbHVlKG1hcFN1YnNjcmliYWJsZVRvT2JzZXJ2YWJsZShvYnNlcnZhYmxlJCkpO1xuICAgICAgfSBlbHNlIGlmICghZW1pdHRlZFZhbHVlT25jZSAmJiBvYnNlcnZhYmxlJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBORVZFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbWl0QW5kRG9udENvbXBsZXRlKG9ic2VydmFibGUkKTtcbiAgICB9KSxcbiAgICBzd2l0Y2hNYXAoKG86IE9ic2VydmFibGU8VT4pID0+IHtcbiAgICAgIHJldHVybiBvLnBpcGUoXG4gICAgICAgIHRhcCgoKSA9PiAoZW1pdHRlZFZhbHVlT25jZSA9IHRydWUpKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgcnhNYXRlcmlhbGl6ZSgpLFxuICAgICAgICBtYXAoaGFuZGxlU3VzcGVuc2VBbmRMYXN0VmFsdWVJbk5vdGlmaWNhdGlvbnM8VT4oKSksXG4gICAgICApO1xuICAgIH0pLFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgbmV4dChvYnNlcnZhYmxlOiBPYnNlcnZhYmxlSW5wdXQ8VT4gfCBVIHwgU3Vic2NyaWJhYmxlPFU+KSB7XG4gICAgICBvYnNlcnZhYmxlc1N1YmplY3QubmV4dChvYnNlcnZhYmxlKTtcbiAgICB9LFxuICAgIHdpdGhJbml0aWFsU3VzcGVuc2Uod2l0aEluaXRpYWxTdXNwZW5zZTogYm9vbGVhbikge1xuICAgICAgZW1pdHRlZFZhbHVlT25jZSA9IGVtaXR0ZWRWYWx1ZU9uY2UgfHwgd2l0aEluaXRpYWxTdXNwZW5zZTtcbiAgICB9LFxuICAgIHZhbHVlcyQsXG4gIH07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiByZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBzdGFydHMgd2l0aCBhbiB1bmRlZmluZWQgdmFsdWUgaW4gY2FzZSB0aGUgaW5wdXRcbiAgICogb2JzZXJ2YWJsZSQgZG9lcyBub3QgZW1pdCBhIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgKiBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBza2lwIHRoZSBzdXNwZW5zZSB0ZW1wbGF0ZSB3aGVuIHdlIGFscmVhZHkga25vd1xuICAgKiB0aGVyZSB3aWxsIGJlIGEgbmV4dCB0ZW1wbGF0ZSByZW5kZXJlZCBhZnRlcndhcmRzXG4gICAqIEBwYXJhbSBvYnNlcnZhYmxlJFxuICAgKi9cbiAgZnVuY3Rpb24gc2tpcFN1c3BlbnNlSWZIYXNWYWx1ZTxUPihcbiAgICBvYnNlcnZhYmxlJDogT2JzZXJ2YWJsZUlucHV0PFQ+LFxuICApOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgIGxldCBzdGFydFdpdGhVbmRlZmluZWQgPSB0cnVlO1xuICAgICAgY29uc3QgaW5uZXIgPSBmcm9tKG9ic2VydmFibGUkKS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAodikgPT4ge1xuICAgICAgICAgIHN0YXJ0V2l0aFVuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChlKSA9PiB7XG4gICAgICAgICAgc3RhcnRXaXRoVW5kZWZpbmVkID0gZmFsc2U7XG4gICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHN1YnNjcmliZXIuY29tcGxldGUoKSxcbiAgICAgIH0pO1xuICAgICAgaWYgKGVtaXR0ZWRWYWx1ZU9uY2UgJiYgc3RhcnRXaXRoVW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaW5uZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlSW5wdXQ8VD4oaW5wdXQ6IHVua25vd24pOiBpbnB1dCBpcyBPYnNlcnZhYmxlSW5wdXQ8VD4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiAoaW5wdXQgYXMgUHJvbWlzZTxUPik/LnRoZW4gPT09ICdmdW5jdGlvbicgfHwgaXNPYnNlcnZhYmxlKGlucHV0KVxuICApO1xufVxuXG5mdW5jdGlvbiBpc1N1YnNjcmliYWJsZUlucHV0PFQ+KGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgU3Vic2NyaWJhYmxlPFQ+IHtcbiAgcmV0dXJuIHR5cGVvZiAoaW5wdXQgYXMgU3Vic2NyaWJhYmxlPFQ+KT8uc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBtYXBTdWJzY3JpYmFibGVUb09ic2VydmFibGU8VD4oaW5wdXQ6IFN1YnNjcmliYWJsZTxUPik6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGU8VD4oKHN1YnNjcmliZXIpID0+IHtcbiAgICBjb25zdCBzdWIgPSBpbnB1dC5zdWJzY3JpYmUoeyBuZXh0OiAodmFsdWUpID0+IHN1YnNjcmliZXIubmV4dCh2YWx1ZSkgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0pO1xufVxuIl19