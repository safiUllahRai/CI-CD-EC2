// see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js
import { ɵglobal } from '@angular/core';
import { peek, pop, push, } from './schedulerMinHeap';
let getCurrentTime;
const hasPerformanceNow = typeof ɵglobal.performance === 'object' &&
    typeof ɵglobal.performance.now === 'function';
if (hasPerformanceNow) {
    const localPerformance = ɵglobal.performance;
    getCurrentTime = () => localPerformance.now();
}
else {
    const localDate = Date;
    const initialTime = localDate.now();
    getCurrentTime = () => localDate.now() - initialTime;
}
// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
const maxSigned31BitInt = 1073741823;
// Times out immediately
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
// Tasks are stored on a min heap
const taskQueue = [];
const timerQueue = [];
// Incrementing id counter. Used to maintain insertion order.
let taskIdCounter = 1;
let currentTask = null;
let currentPriorityLevel = 3 /* PriorityLevel.NormalPriority */;
// This is set while performing work, to prevent re-entrancy.
let isPerformingWork = false;
let isHostCallbackScheduled = false;
let isHostTimeoutScheduled = false;
// Capture local references to native APIs, in case a polyfill overrides them.
const setTimeout = ɵglobal.setTimeout;
const clearTimeout = ɵglobal.clearTimeout;
const setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom
const messageChannel = ɵglobal.MessageChannel;
const defaultZone = {
    run: (fn) => fn(),
};
function advanceTimers(currentTime) {
    // Check for tasks that are no longer delayed and add them to the queue.
    let timer = peek(timerQueue);
    while (timer !== null) {
        if (timer.callback === null) {
            // Timer was cancelled.
            pop(timerQueue);
        }
        else if (timer.startTime <= currentTime) {
            // Timer fired. Transfer to the task queue.
            pop(timerQueue);
            timer.sortIndex = timer.expirationTime;
            push(taskQueue, timer);
        }
        else {
            // Remaining timers are pending.
            return;
        }
        timer = peek(timerQueue);
    }
}
function handleTimeout(currentTime) {
    isHostTimeoutScheduled = false;
    advanceTimers(currentTime);
    if (!isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
        else {
            const firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
    }
}
function flushWork(hasTimeRemaining, initialTime) {
    // We'll need a host callback the next time work is scheduled.
    isHostCallbackScheduled = false;
    if (isHostTimeoutScheduled) {
        // We scheduled a timeout but it's no longer needed. Cancel it.
        isHostTimeoutScheduled = false;
        cancelHostTimeout();
    }
    isPerformingWork = true;
    const previousPriorityLevel = currentPriorityLevel;
    try {
        return workLoop(hasTimeRemaining, initialTime);
    }
    finally {
        currentTask = null;
        currentPriorityLevel = previousPriorityLevel;
        isPerformingWork = false;
    }
}
function workLoop(hasTimeRemaining, initialTime, _currentTask) {
    let currentTime = initialTime;
    if (_currentTask) {
        currentTask = _currentTask;
    }
    else {
        advanceTimers(currentTime);
        currentTask = peek(taskQueue);
    }
    let zoneChanged = false;
    const hitDeadline = () => currentTask &&
        currentTask.expirationTime > currentTime &&
        (!hasTimeRemaining || shouldYieldToHost());
    if (!hitDeadline()) {
        const ngZone = currentTask.ngZone || defaultZone;
        ngZone.run(() => {
            while (currentTask !== null && !zoneChanged) {
                if (hitDeadline()) {
                    break;
                }
                const callback = currentTask.callback;
                if (typeof callback === 'function') {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                    const continuationCallback = callback(didUserCallbackTimeout);
                    currentTime = getCurrentTime();
                    if (typeof continuationCallback === 'function') {
                        currentTask.callback = continuationCallback;
                    }
                    else {
                        if (currentTask === peek(taskQueue)) {
                            pop(taskQueue);
                        }
                    }
                    advanceTimers(currentTime);
                }
                else {
                    pop(taskQueue);
                }
                currentTask = peek(taskQueue);
                zoneChanged =
                    currentTask?.ngZone != null && currentTask.ngZone !== ngZone;
            }
        });
    }
    // we need to check if leaving `NgZone` (tick => detectChanges) caused other
    // directives to add tasks to the queue. If there is one and we still didn't
    // hit the deadline, run the workLoop again in order to flush everything thats
    // left.
    // Otherwise, newly added tasks won't run as `performingWork` is still `true`
    currentTask = currentTask ?? peek(taskQueue);
    // We should also re-calculate the currentTime, as we need to account for the execution
    // time of the NgZone tasks as well.
    // If there is still a task in the queue, but no time is left for executing it,
    // the scheduler will re-schedule the next tick anyway
    currentTime = getCurrentTime();
    if (zoneChanged || (currentTask && !hitDeadline())) {
        return workLoop(hasTimeRemaining, currentTime, currentTask);
    }
    // Return whether there's additional work
    if (currentTask !== null) {
        return true;
    }
    else {
        const firstTimer = peek(timerQueue);
        if (firstTimer !== null) {
            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
        return false;
    }
}
export function scheduleCallback(priorityLevel, callback, options) {
    const currentTime = getCurrentTime();
    let startTime;
    if (typeof options === 'object' && options !== null) {
        const delay = options.delay;
        if (typeof delay === 'number' && delay > 0) {
            startTime = currentTime + delay;
        }
        else {
            startTime = currentTime;
        }
    }
    else {
        startTime = currentTime;
    }
    let timeout;
    switch (priorityLevel) {
        case 1 /* PriorityLevel.ImmediatePriority */:
            timeout = IMMEDIATE_PRIORITY_TIMEOUT;
            break;
        case 2 /* PriorityLevel.UserBlockingPriority */:
            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
            break;
        case 5 /* PriorityLevel.IdlePriority */:
            timeout = IDLE_PRIORITY_TIMEOUT;
            break;
        case 4 /* PriorityLevel.LowPriority */:
            timeout = LOW_PRIORITY_TIMEOUT;
            break;
        case 3 /* PriorityLevel.NormalPriority */:
        default:
            timeout = NORMAL_PRIORITY_TIMEOUT;
            break;
    }
    const expirationTime = startTime + timeout;
    const newTask = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime,
        expirationTime,
        sortIndex: -1,
        ngZone: options?.ngZone || null,
    };
    if (startTime > currentTime) {
        // This is a delayed task.
        newTask.sortIndex = startTime;
        push(timerQueue, newTask);
        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
            // All tasks are delayed, and this is the task with the earliest delay.
            if (isHostTimeoutScheduled) {
                // Cancel an existing timeout.
                cancelHostTimeout();
            }
            else {
                isHostTimeoutScheduled = true;
            }
            // Schedule a timeout.
            requestHostTimeout(handleTimeout, startTime - currentTime);
        }
    }
    else {
        newTask.sortIndex = expirationTime;
        push(taskQueue, newTask);
        // Schedule a host callback, if needed. If we're already performing work,
        // wait until the next time we yield.
        if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
    }
    return newTask;
}
export function cancelCallback(task) {
    // Null out the callback to indicate the task has been canceled. (Can't
    // remove from the queue because you can't remove arbitrary nodes from an
    // array based heap, only the first one.)
    task.callback = null;
}
let isMessageLoopRunning = false;
let scheduledHostCallback = null;
let taskTimeoutID = -1;
// Scheduler periodically yields in case there is other work on the main
// thread, like user events. By default, it yields multiple times per frame.
// It does not attempt to align with frame boundaries, since most tasks don't
// need to be frame aligned; for those that do, use requestAnimationFrame.
let yieldInterval = 16;
let needsPaint = false;
let queueStartTime = -1;
function shouldYieldToHost() {
    if (needsPaint) {
        // There's a pending paint (signaled by `requestPaint`). Yield now.
        return true;
    }
    const timeElapsed = getCurrentTime() - queueStartTime;
    if (timeElapsed < yieldInterval) {
        // The main thread has only been blocked for a really short amount of time;
        // smaller than a single frame. Don't yield yet.
        return false;
    }
    // `isInputPending` isn't available. Yield now.
    return true;
}
function requestPaint() {
    needsPaint = true;
}
export function forceFrameRate(fps) {
    if (fps < 0 || fps > 125) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            console.error('forceFrameRate takes a positive int between 0 and 125, ' +
                'forcing frame rates higher than 125 fps is not supported');
        }
        return;
    }
    if (fps > 0) {
        yieldInterval = Math.floor(1000 / fps);
    }
    else {
        // reset the framerate
        yieldInterval = 5;
    }
    // be aware of browser housekeeping work (~6ms per frame)
    // according to https://developers.google.com/web/fundamentals/performance/rendering
    yieldInterval = Math.max(5, yieldInterval - 6);
}
const performWorkUntilDeadline = () => {
    if (scheduledHostCallback !== null) {
        const currentTime = getCurrentTime();
        // Yield after `yieldInterval` ms, regardless of where we are in the vsync
        // cycle. This means there's always time remaining at the beginning of
        // the message event.
        queueStartTime = currentTime;
        const hasTimeRemaining = true;
        // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        //
        // Intentionally not using a try-catch, since that makes some debugging
        // techniques harder. Instead, if `scheduledHostCallback` errors, then
        // `hasMoreWork` will remain true, and we'll continue the work loop.
        let hasMoreWork = true;
        try {
            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
        }
        finally {
            if (hasMoreWork) {
                // If there's more work, schedule the next message event at the end
                // of the preceding one.
                schedulePerformWorkUntilDeadline();
            }
            else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
            }
        }
    }
    else {
        isMessageLoopRunning = false;
    }
    // Yielding to the browser will give it a chance to paint, so we can
    // reset this.
    needsPaint = false;
};
let schedulePerformWorkUntilDeadline;
if (typeof setImmediate === 'function') {
    // Node.js and old IE.
    // There's a few reasons for why we prefer setImmediate.
    //
    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
    // (Even though this is a DOM fork of the Scheduler, you could get here
    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
    // https://github.com/facebook/react/issues/20756
    //
    // But also, it runs earlier which is the semantic we want.
    // If other browsers ever implement it, it's better to use it.
    // Although both of these would be inferior to native scheduling.
    schedulePerformWorkUntilDeadline = () => {
        setImmediate(performWorkUntilDeadline);
    };
}
else if (typeof messageChannel !== 'undefined') {
    const channel = new messageChannel();
    const port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    schedulePerformWorkUntilDeadline = () => {
        port.postMessage(null);
    };
}
else {
    // We should only fallback here in non-browser environments.
    schedulePerformWorkUntilDeadline = () => {
        setTimeout(performWorkUntilDeadline, 0);
    };
}
function requestHostCallback(callback) {
    scheduledHostCallback = callback;
    if (!isMessageLoopRunning) {
        isMessageLoopRunning = true;
        schedulePerformWorkUntilDeadline();
    }
}
function requestHostTimeout(callback, ms) {
    taskTimeoutID = setTimeout(() => {
        callback(getCurrentTime());
    }, ms);
}
function cancelHostTimeout() {
    clearTimeout(taskTimeoutID);
    taskTimeoutID = -1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZWR1bGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvaW50ZXJuYWxzL3NjaGVkdWxlci9zcmMvbGliL3NjaGVkdWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0RkFBNEY7QUFFNUYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4QyxPQUFPLEVBQ0wsSUFBSSxFQUNKLEdBQUcsRUFDSCxJQUFJLEdBR0wsTUFBTSxvQkFBb0IsQ0FBQztBQVM1QixJQUFJLGNBQTRCLENBQUM7QUFDakMsTUFBTSxpQkFBaUIsR0FDckIsT0FBTyxPQUFPLENBQUMsV0FBVyxLQUFLLFFBQVE7SUFDdkMsT0FBTyxPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxVQUFVLENBQUM7QUFFaEQsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO0lBQ3RCLE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQztJQUM3QyxjQUFjLEdBQUcsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDaEQsQ0FBQztLQUFNLENBQUM7SUFDTixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFDdkIsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3BDLGNBQWMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLEdBQUcsV0FBVyxDQUFDO0FBQ3ZELENBQUM7QUFFRCxxRUFBcUU7QUFDckUsc0JBQXNCO0FBQ3RCLG1DQUFtQztBQUNuQyxNQUFNLGlCQUFpQixHQUFHLFVBQVUsQ0FBQztBQUVyQyx3QkFBd0I7QUFDeEIsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN0Qyx1QkFBdUI7QUFDdkIsTUFBTSw4QkFBOEIsR0FBRyxHQUFHLENBQUM7QUFDM0MsTUFBTSx1QkFBdUIsR0FBRyxJQUFJ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LENBQUM7SUFDTiw0REFBNEQ7SUFDNUQsZ0NBQWdDLEdBQUcsR0FBRyxFQUFFO1FBQ3RDLFVBQVUsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxRQUFRO0lBQ25DLHFCQUFxQixHQUFHLFFBQVEsQ0FBQztJQUNqQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUMxQixvQkFBb0IsR0FBRyxJQUFJLENBQUM7UUFDNUIsZ0NBQWdDLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUMsUUFBUSxFQUFFLEVBQUU7SUFDdEMsYUFBYSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDOUIsUUFBUSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7SUFDN0IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ1QsQ0FBQztBQUVELFNBQVMsaUJBQWlCO0lBQ3hCLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUM1QixhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3NjaGVkdWxlci9zcmMvZm9ya3MvU2NoZWR1bGVyLmpzXG5cbmltcG9ydCB7IMm1Z2xvYmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBwZWVrLFxuICBwb3AsXG4gIHB1c2gsXG4gIFJlYWN0U2NoZWR1bGVyVGFzayxcbiAgU2NoZWR1bGVyVGFza1pvbmUsXG59IGZyb20gJy4vc2NoZWR1bGVyTWluSGVhcCc7XG5pbXBvcnQgeyBQcmlvcml0eUxldmVsIH0gZnJvbSAnLi9zY2hlZHVsZXJQcmlvcml0aWVzJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gV2lsbCBiZSBwcm92aWRlZCB0aHJvdWdoIFRlcnNlciBnbG9iYWwgZGVmaW5pdGlvbnMgYnkgQW5ndWxhciBDTElcbiAqIGR1cmluZyB0aGUgcHJvZHVjdGlvbiBidWlsZC5cbiAqL1xuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XG5cbmxldCBnZXRDdXJyZW50VGltZTogKCkgPT4gbnVtYmVyO1xuY29uc3QgaGFzUGVyZm9ybWFuY2VOb3cgPVxuICB0eXBlb2YgybVnbG9iYWwucGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiDJtWdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICBjb25zdCBsb2NhbFBlcmZvcm1hbmNlID0gybVnbG9iYWwucGVyZm9ybWFuY2U7XG4gIGdldEN1cnJlbnRUaW1lID0gKCkgPT4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbn0gZWxzZSB7XG4gIGNvbnN0IGxvY2FsRGF0ZSA9IERhdGU7XG4gIGNvbnN0IGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICBnZXRDdXJyZW50VGltZSA9ICgpID0+IGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xufVxuXG4vLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5jb25zdCBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7XG5cbi8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuY29uc3QgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTtcbi8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5jb25zdCBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG5jb25zdCBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwO1xuLy8gTmV2ZXIgdGltZXMgb3V0XG5jb25zdCBJRExFX1BSSU9SSVRZX1RJTUVPVVQgPSBtYXhTaWduZWQzMUJpdEludDtcblxuLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5jb25zdCB0YXNrUXVldWUgPSBbXTtcbmNvbnN0IHRpbWVyUXVldWUgPSBbXTtcblxuLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxubGV0IHRhc2tJZENvdW50ZXIgPSAxO1xuXG5sZXQgY3VycmVudFRhc2s6IFJlYWN0U2NoZWR1bGVyVGFzayA9IG51bGw7XG5sZXQgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBQcmlvcml0eUxldmVsLk5vcm1hbFByaW9yaXR5O1xuXG4vLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY3kuXG5sZXQgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuXG5sZXQgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG5cbi8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuY29uc3Qgc2V0VGltZW91dCA9IMm1Z2xvYmFsLnNldFRpbWVvdXQ7XG5jb25zdCBjbGVhclRpbWVvdXQgPSDJtWdsb2JhbC5jbGVhclRpbWVvdXQ7XG5jb25zdCBzZXRJbW1lZGlhdGUgPSDJtWdsb2JhbC5zZXRJbW1lZGlhdGU7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cbmNvbnN0IG1lc3NhZ2VDaGFubmVsID0gybVnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG5cbmNvbnN0IGRlZmF1bHRab25lID0ge1xuICBydW46IChmbikgPT4gZm4oKSxcbn07XG5cbmZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgLy8gQ2hlY2sgZm9yIHRhc2tzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWxheWVkIGFuZCBhZGQgdGhlbSB0byB0aGUgcXVldWUuXG4gIGxldCB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcbiAgLy8gV2UnbGwgbmVlZCBhIGhvc3QgY2FsbGJhY2sgdGhlIG5leHQgdGltZSB3b3JrIGlzIHNjaGVkdWxlZC5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICBjb25zdCBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRUYXNrID0gbnVsbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ya0xvb3AoXG4gIGhhc1RpbWVSZW1haW5pbmc6IGJvb2xlYW4sXG4gIGluaXRpYWxUaW1lOiBudW1iZXIsXG4gIF9jdXJyZW50VGFzaz86IFJlYWN0U2NoZWR1bGVyVGFzayxcbikge1xuICBsZXQgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgaWYgKF9jdXJyZW50VGFzaykge1xuICAgIGN1cnJlbnRUYXNrID0gX2N1cnJlbnRUYXNrO1xuICB9IGVsc2Uge1xuICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9XG4gIGxldCB6b25lQ2hhbmdlZCA9IGZhbHNlO1xuICBjb25zdCBoaXREZWFkbGluZSA9ICgpID0+XG4gICAgY3VycmVudFRhc2sgJiZcbiAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmXG4gICAgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpO1xuXG4gIGlmICghaGl0RGVhZGxpbmUoKSkge1xuICAgIGNvbnN0IG5nWm9uZSA9IGN1cnJlbnRUYXNrLm5nWm9uZSB8fCBkZWZhdWx0Wm9uZTtcbiAgICBuZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhem9uZUNoYW5nZWQpIHtcbiAgICAgICAgaWYgKGhpdERlYWRsaW5lKCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICBjb25zdCBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID1cbiAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIGNvbnN0IGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBnZXRDdXJyZW50VGltZSgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgem9uZUNoYW5nZWQgPVxuICAgICAgICAgIGN1cnJlbnRUYXNrPy5uZ1pvbmUgIT0gbnVsbCAmJiBjdXJyZW50VGFzay5uZ1pvbmUgIT09IG5nWm9uZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGxlYXZpbmcgYE5nWm9uZWAgKHRpY2sgPT4gZGV0ZWN0Q2hhbmdlcykgY2F1c2VkIG90aGVyXG4gIC8vIGRpcmVjdGl2ZXMgdG8gYWRkIHRhc2tzIHRvIHRoZSBxdWV1ZS4gSWYgdGhlcmUgaXMgb25lIGFuZCB3ZSBzdGlsbCBkaWRuJ3RcbiAgLy8gaGl0IHRoZSBkZWFkbGluZSwgcnVuIHRoZSB3b3JrTG9vcCBhZ2FpbiBpbiBvcmRlciB0byBmbHVzaCBldmVyeXRoaW5nIHRoYXRzXG4gIC8vIGxlZnQuXG4gIC8vIE90aGVyd2lzZSwgbmV3bHkgYWRkZWQgdGFza3Mgd29uJ3QgcnVuIGFzIGBwZXJmb3JtaW5nV29ya2AgaXMgc3RpbGwgYHRydWVgXG4gIGN1cnJlbnRUYXNrID0gY3VycmVudFRhc2sgPz8gcGVlayh0YXNrUXVldWUpO1xuICAvLyBXZSBzaG91bGQgYWxzbyByZS1jYWxjdWxhdGUgdGhlIGN1cnJlbnRUaW1lLCBhcyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBleGVjdXRpb25cbiAgLy8gdGltZSBvZiB0aGUgTmdab25lIHRhc2tzIGFzIHdlbGwuXG4gIC8vIElmIHRoZXJlIGlzIHN0aWxsIGEgdGFzayBpbiB0aGUgcXVldWUsIGJ1dCBubyB0aW1lIGlzIGxlZnQgZm9yIGV4ZWN1dGluZyBpdCxcbiAgLy8gdGhlIHNjaGVkdWxlciB3aWxsIHJlLXNjaGVkdWxlIHRoZSBuZXh0IHRpY2sgYW55d2F5XG4gIGN1cnJlbnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcbiAgaWYgKHpvbmVDaGFuZ2VkIHx8IChjdXJyZW50VGFzayAmJiAhaGl0RGVhZGxpbmUoKSkpIHtcbiAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUsIGN1cnJlbnRUYXNrKTtcbiAgfVxuICAvLyBSZXR1cm4gd2hldGhlciB0aGVyZSdzIGFkZGl0aW9uYWwgd29ya1xuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuaW50ZXJmYWNlIFNjaGVkdWxlQ2FsbGJhY2tPcHRpb25zIHtcbiAgZGVsYXk/OiBudW1iZXI7XG4gIG5nWm9uZT86IFNjaGVkdWxlclRhc2tab25lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhcbiAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgY2FsbGJhY2s6IFZvaWRGdW5jdGlvbixcbiAgb3B0aW9ucz86IFNjaGVkdWxlQ2FsbGJhY2tPcHRpb25zLFxuKTogUmVhY3RTY2hlZHVsZXJUYXNrIHtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRDdXJyZW50VGltZSgpO1xuXG4gIGxldCBzdGFydFRpbWU6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgbGV0IHRpbWVvdXQ6IG51bWJlcjtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBQcmlvcml0eUxldmVsLkltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQcmlvcml0eUxldmVsLlVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUHJpb3JpdHlMZXZlbC5JZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQcmlvcml0eUxldmVsLkxvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQcmlvcml0eUxldmVsLk5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGNvbnN0IGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcblxuICBjb25zdCBuZXdUYXNrOiBSZWFjdFNjaGVkdWxlclRhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjayxcbiAgICBwcmlvcml0eUxldmVsLFxuICAgIHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZSxcbiAgICBzb3J0SW5kZXg6IC0xLFxuICAgIG5nWm9uZTogb3B0aW9ucz8ubmdab25lIHx8IG51bGwsXG4gIH07XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyBTY2hlZHVsZSBhIGhvc3QgY2FsbGJhY2ssIGlmIG5lZWRlZC4gSWYgd2UncmUgYWxyZWFkeSBwZXJmb3JtaW5nIHdvcmssXG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrKHRhc2spIHtcbiAgLy8gTnVsbCBvdXQgdGhlIGNhbGxiYWNrIHRvIGluZGljYXRlIHRoZSB0YXNrIGhhcyBiZWVuIGNhbmNlbGVkLiAoQ2FuJ3RcbiAgLy8gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlIGJlY2F1c2UgeW91IGNhbid0IHJlbW92ZSBhcmJpdHJhcnkgbm9kZXMgZnJvbSBhblxuICAvLyBhcnJheSBiYXNlZCBoZWFwLCBvbmx5IHRoZSBmaXJzdCBvbmUuKVxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxubGV0IGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG5sZXQgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbmxldCB0YXNrVGltZW91dElEID0gLTE7XG5cbi8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5sZXQgeWllbGRJbnRlcnZhbCA9IDE2O1xubGV0IG5lZWRzUGFpbnQgPSBmYWxzZTtcbmxldCBxdWV1ZVN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgaWYgKG5lZWRzUGFpbnQpIHtcbiAgICAvLyBUaGVyZSdzIGEgcGVuZGluZyBwYWludCAoc2lnbmFsZWQgYnkgYHJlcXVlc3RQYWludGApLiBZaWVsZCBub3cuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdGltZUVsYXBzZWQgPSBnZXRDdXJyZW50VGltZSgpIC0gcXVldWVTdGFydFRpbWU7XG4gIGlmICh0aW1lRWxhcHNlZCA8IHlpZWxkSW50ZXJ2YWwpIHtcbiAgICAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIG9ubHkgYmVlbiBibG9ja2VkIGZvciBhIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZTtcbiAgICAvLyBzbWFsbGVyIHRoYW4gYSBzaW5nbGUgZnJhbWUuIERvbid0IHlpZWxkIHlldC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBgaXNJbnB1dFBlbmRpbmdgIGlzbid0IGF2YWlsYWJsZS4gWWllbGQgbm93LlxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdFBhaW50KCkge1xuICBuZWVkc1BhaW50ID0gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmNlRnJhbWVSYXRlKGZwcykge1xuICBpZiAoZnBzIDwgMCB8fCBmcHMgPiAxMjUpIHtcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgK1xuICAgICAgICAgICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZwcyA+IDApIHtcbiAgICB5aWVsZEludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgeWllbGRJbnRlcnZhbCA9IDU7XG4gIH1cbiAgLy8gYmUgYXdhcmUgb2YgYnJvd3NlciBob3VzZWtlZXBpbmcgd29yayAofjZtcyBwZXIgZnJhbWUpXG4gIC8vIGFjY29yZGluZyB0byBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3BlcmZvcm1hbmNlL3JlbmRlcmluZ1xuICB5aWVsZEludGVydmFsID0gTWF0aC5tYXgoNSwgeWllbGRJbnRlcnZhbCAtIDYpO1xufVxuXG5jb25zdCBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSAoKSA9PiB7XG4gIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgLy8gWWllbGQgYWZ0ZXIgYHlpZWxkSW50ZXJ2YWxgIG1zLCByZWdhcmRsZXNzIG9mIHdoZXJlIHdlIGFyZSBpbiB0aGUgdnN5bmNcbiAgICAvLyBjeWNsZS4gVGhpcyBtZWFucyB0aGVyZSdzIGFsd2F5cyB0aW1lIHJlbWFpbmluZyBhdCB0aGUgYmVnaW5uaW5nIG9mXG4gICAgLy8gdGhlIG1lc3NhZ2UgZXZlbnQuXG4gICAgcXVldWVTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBjb25zdCBoYXNUaW1lUmVtYWluaW5nID0gdHJ1ZTtcblxuICAgIC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgLy9cbiAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xuICAgIC8vIHRlY2huaXF1ZXMgaGFyZGVyLiBJbnN0ZWFkLCBpZiBgc2NoZWR1bGVkSG9zdENhbGxiYWNrYCBlcnJvcnMsIHRoZW5cbiAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuICAgIGxldCBoYXNNb3JlV29yayA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGhhc01vcmVXb3JrID0gc2NoZWR1bGVkSG9zdENhbGxiYWNrKGhhc1RpbWVSZW1haW5pbmcsIGN1cnJlbnRUaW1lKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGhhc01vcmVXb3JrKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICB9XG4gIC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gIC8vIHJlc2V0IHRoaXMuXG4gIG5lZWRzUGFpbnQgPSBmYWxzZTtcbn07XG5cbmxldCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIE5vZGUuanMgYW5kIG9sZCBJRS5cbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgLy9cbiAgLy8gVW5saWtlIE1lc3NhZ2VDaGFubmVsLCBpdCBkb2Vzbid0IHByZXZlbnQgYSBOb2RlLmpzIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDc1NlxuICAvL1xuICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAvLyBJZiBvdGhlciBicm93c2VycyBldmVyIGltcGxlbWVudCBpdCwgaXQncyBiZXR0ZXIgdG8gdXNlIGl0LlxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9ICgpID0+IHtcbiAgICBzZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICBjb25zdCBjaGFubmVsOiBNZXNzYWdlQ2hhbm5lbCA9IG5ldyBtZXNzYWdlQ2hhbm5lbCgpO1xuICBjb25zdCBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcblxuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSAoKSA9PiB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9ICgpID0+IHtcbiAgICBzZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIGlmICghaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XG4gIHRhc2tUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYWxsYmFjayhnZXRDdXJyZW50VGltZSgpKTtcbiAgfSwgbXMpO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcbiAgY2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICB0YXNrVGltZW91dElEID0gLTE7XG59XG4iXX0=