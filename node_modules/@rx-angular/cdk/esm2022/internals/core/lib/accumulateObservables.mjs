import { coalesceWith } from '@rx-angular/cdk/coalescing';
import { combineLatest, from } from 'rxjs';
import { distinctUntilChanged, filter, map, shareReplay } from 'rxjs/operators';
import { getZoneUnPatchedApi } from './get-zone-unpatched-api';
const resolvedPromise = getZoneUnPatchedApi('Promise').resolve();
const resolvedPromise$ = from(resolvedPromise);
/**
 * @internal
 *
 * Used for typing
 */
function getEntriesToObjectReducerFn(keys) {
    return (accumulator, currentValue, currentIndex) => {
        return {
            ...accumulator,
            [keys[currentIndex]]: currentValue,
        };
    };
}
/**
 * This Observable creation function helps to accumulate an object of key & Observable of values to
 * an Observable of objects of key & value.
 * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.
 *
 * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.
 *
 * @example
 *
 * Default usage:
 *
 * const object$: Observable<{
 *   prop1: number,
 *   prop2: string,
 *   prop3: string
 * }> = accumulateObservables({
 *   prop1: interval(42),
 *   prop2: of('lorem'),
 *   prop3: 'test'
 * });
 *
 * Usage with custom duration selector:
 *
 * const object$: Observable<{
 *   prop1: number,
 *   prop2: string,
 *   prop3: string
 * }> = accumulateObservables({
 *   prop1: interval(42),
 *   prop2: of('lorem'),
 *   prop3: 'test'
 * }, timer(0, 20));
 *
 * @param obj - An object of key & Observable values pairs
 * @param durationSelector - An Observable determining the duration for the internal coalescing method
 */
export function accumulateObservables(
// @TODO type static or Observable to enable mixing of imperative and reatctive values
obj, durationSelector = resolvedPromise$) {
    const keys = Object.keys(obj);
    // @TODO better typing to enable static values => coerceObservable(obj[key])
    const observables = keys.map((key) => obj[key].pipe(
    // we avoid using the nullish operator later ;)
    filter((v) => v !== undefined), 
    // state "changes" differ from each other, this operator ensures distinct values
    distinctUntilChanged()));
    return combineLatest(observables).pipe(
    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions
    // together
    coalesceWith(durationSelector), 
    // mapping array of values to object
    map((values) => values.reduce(getEntriesToObjectReducerFn(keys), {})), 
    // by using shareReplay we share the last composition work done to create the accumulated object
    shareReplay({ refCount: true, bufferSize: 1 }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjdW11bGF0ZU9ic2VydmFibGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvaW50ZXJuYWxzL2NvcmUvc3JjL2xpYi9hY2N1bXVsYXRlT2JzZXJ2YWJsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzFELE9BQU8sRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3ZELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2hGLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBVS9ELE1BQU0sZUFBZSxHQUFHLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2pFLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBRS9DOzs7O0dBSUc7QUFDSCxTQUFTLDJCQUEyQixDQUNsQyxJQUFtQjtJQUVuQixPQUFPLENBQ0wsV0FBYyxFQUNkLFlBQTBCLEVBQzFCLFlBQXFCLEVBQ2xCLEVBQUU7UUFDTCxPQUFPO1lBQ0wsR0FBRyxXQUFXO1lBQ2QsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxZQUFZO1NBQ25DLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUNHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQjtBQUNuQyxzRkFBc0Y7QUFDdEYsR0FBTSxFQUNOLG1CQUFvQyxnQkFBZ0I7SUFFcEQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQWdCLENBQUM7SUFDN0MsNEVBQTRFO0lBQzVFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSTtJQUNYLCtDQUErQztJQUMvQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUM7SUFDOUIsZ0ZBQWdGO0lBQ2hGLG9CQUFvQixFQUFFLENBQ3ZCLENBQ0YsQ0FBQztJQUNGLE9BQU8sYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUk7SUFDcEMsNEdBQTRHO0lBQzVHLFdBQVc7SUFDWCxZQUFZLENBQUMsZ0JBQWdCLENBQUM7SUFDOUIsb0NBQW9DO0lBQ3BDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ2IsTUFBTSxDQUFDLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFTLENBQUMsQ0FDNUQ7SUFDRCxnR0FBZ0c7SUFDaEcsV0FBVyxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FDL0MsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2FsZXNjZVdpdGggfSBmcm9tICdAcngtYW5ndWxhci9jZGsvY29hbGVzY2luZyc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZ2V0Wm9uZVVuUGF0Y2hlZEFwaSB9IGZyb20gJy4vZ2V0LXpvbmUtdW5wYXRjaGVkLWFwaSc7XG5pbXBvcnQge1xuICBBcnJheVJlZHVjZXJGbixcbiAgRXh0cmFjdE9ic2VydmFibGVWYWx1ZSxcbiAgTm90RW1wdHksXG4gIE9ic2VydmFibGVNYXAsXG4gIFByb3BOYW1lLFxuICBQcm9wVHlwZSxcbn0gZnJvbSAnLi9tb2RlbCc7XG5cbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IGdldFpvbmVVblBhdGNoZWRBcGkoJ1Byb21pc2UnKS5yZXNvbHZlKCk7XG5jb25zdCByZXNvbHZlZFByb21pc2UkID0gZnJvbShyZXNvbHZlZFByb21pc2UpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFVzZWQgZm9yIHR5cGluZ1xuICovXG5mdW5jdGlvbiBnZXRFbnRyaWVzVG9PYmplY3RSZWR1Y2VyRm48VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KFxuICBrZXlzOiBQcm9wTmFtZTxUPltdXG4pOiBBcnJheVJlZHVjZXJGbjxUPiB7XG4gIHJldHVybiAoXG4gICAgYWNjdW11bGF0b3I6IFQsXG4gICAgY3VycmVudFZhbHVlPzogUHJvcFR5cGU8VD4sXG4gICAgY3VycmVudEluZGV4PzogbnVtYmVyXG4gICk6IFQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2N1bXVsYXRvcixcbiAgICAgIFtrZXlzW2N1cnJlbnRJbmRleF1dOiBjdXJyZW50VmFsdWUsXG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIE9ic2VydmFibGUgY3JlYXRpb24gZnVuY3Rpb24gaGVscHMgdG8gYWNjdW11bGF0ZSBhbiBvYmplY3Qgb2Yga2V5ICYgT2JzZXJ2YWJsZSBvZiB2YWx1ZXMgdG9cbiAqIGFuIE9ic2VydmFibGUgb2Ygb2JqZWN0cyBvZiBrZXkgJiB2YWx1ZS5cbiAqIFRoaXMgY29tZXMgaW4gaGFuZHkgaWYgeW91IHF1aWNrbHkgd2FudCB0byBjcmVhdGUgc3Vic2V0cyBhcyBvYmplY3RzL3N0YXRlLXNsaWNlcyBvZiBkaWZmZXJlbnQgT2JzZXJ2YWJsZXMuXG4gKlxuICogVGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlIGZpbHRlcnMgb3V0IHVuZGVmaW5lZCB2YWx1ZXMgZm9yd2FyZHMgb25seSBkaXN0aW5jdCB2YWx1ZXMgYW5kIHNoYXJlZCB0aGUgYWdncmVnYXRlZCBvdXRwdXQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBEZWZhdWx0IHVzYWdlOlxuICpcbiAqIGNvbnN0IG9iamVjdCQ6IE9ic2VydmFibGU8e1xuICogICBwcm9wMTogbnVtYmVyLFxuICogICBwcm9wMjogc3RyaW5nLFxuICogICBwcm9wMzogc3RyaW5nXG4gKiB9PiA9IGFjY3VtdWxhdGVPYnNlcnZhYmxlcyh7XG4gKiAgIHByb3AxOiBpbnRlcnZhbCg0MiksXG4gKiAgIHByb3AyOiBvZignbG9yZW0nKSxcbiAqICAgcHJvcDM6ICd0ZXN0J1xuICogfSk7XG4gKlxuICogVXNhZ2Ugd2l0aCBjdXN0b20gZHVyYXRpb24gc2VsZWN0b3I6XG4gKlxuICogY29uc3Qgb2JqZWN0JDogT2JzZXJ2YWJsZTx7XG4gKiAgIHByb3AxOiBudW1iZXIsXG4gKiAgIHByb3AyOiBzdHJpbmcsXG4gKiAgIHByb3AzOiBzdHJpbmdcbiAqIH0+ID0gYWNjdW11bGF0ZU9ic2VydmFibGVzKHtcbiAqICAgcHJvcDE6IGludGVydmFsKDQyKSxcbiAqICAgcHJvcDI6IG9mKCdsb3JlbScpLFxuICogICBwcm9wMzogJ3Rlc3QnXG4gKiB9LCB0aW1lcigwLCAyMCkpO1xuICpcbiAqIEBwYXJhbSBvYmogLSBBbiBvYmplY3Qgb2Yga2V5ICYgT2JzZXJ2YWJsZSB2YWx1ZXMgcGFpcnNcbiAqIEBwYXJhbSBkdXJhdGlvblNlbGVjdG9yIC0gQW4gT2JzZXJ2YWJsZSBkZXRlcm1pbmluZyB0aGUgZHVyYXRpb24gZm9yIHRoZSBpbnRlcm5hbCBjb2FsZXNjaW5nIG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjdW11bGF0ZU9ic2VydmFibGVzPFQgZXh0ZW5kcyBPYnNlcnZhYmxlTWFwICYgTm90RW1wdHk8VD4+KFxuICAvLyBAVE9ETyB0eXBlIHN0YXRpYyBvciBPYnNlcnZhYmxlIHRvIGVuYWJsZSBtaXhpbmcgb2YgaW1wZXJhdGl2ZSBhbmQgcmVhdGN0aXZlIHZhbHVlc1xuICBvYmo6IFQsXG4gIGR1cmF0aW9uU2VsZWN0b3I6IE9ic2VydmFibGU8YW55PiA9IHJlc29sdmVkUHJvbWlzZSRcbik6IE9ic2VydmFibGU8eyBbSyBpbiBrZXlvZiBUXTogRXh0cmFjdE9ic2VydmFibGVWYWx1ZTxUW0tdPiB9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopIGFzIChrZXlvZiBUKVtdO1xuICAvLyBAVE9ETyBiZXR0ZXIgdHlwaW5nIHRvIGVuYWJsZSBzdGF0aWMgdmFsdWVzID0+IGNvZXJjZU9ic2VydmFibGUob2JqW2tleV0pXG4gIGNvbnN0IG9ic2VydmFibGVzID0ga2V5cy5tYXAoKGtleSkgPT5cbiAgICBvYmpba2V5XS5waXBlKFxuICAgICAgLy8gd2UgYXZvaWQgdXNpbmcgdGhlIG51bGxpc2ggb3BlcmF0b3IgbGF0ZXIgOylcbiAgICAgIGZpbHRlcigodikgPT4gdiAhPT0gdW5kZWZpbmVkKSxcbiAgICAgIC8vIHN0YXRlIFwiY2hhbmdlc1wiIGRpZmZlciBmcm9tIGVhY2ggb3RoZXIsIHRoaXMgb3BlcmF0b3IgZW5zdXJlcyBkaXN0aW5jdCB2YWx1ZXNcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApXG4gICk7XG4gIHJldHVybiBjb21iaW5lTGF0ZXN0KG9ic2VydmFibGVzKS5waXBlKFxuICAgIC8vIEFzIGNvbWJpbmVMYXRlc3Qgd2lsbCBlbWl0IG11bHRpcGxlIHRpbWVzIGZvciBhIGNoYW5nZSBpbiBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdlIGNvYWxlc2NlIHRob3NlIGVtaXNzaW9uc1xuICAgIC8vIHRvZ2V0aGVyXG4gICAgY29hbGVzY2VXaXRoKGR1cmF0aW9uU2VsZWN0b3IpLFxuICAgIC8vIG1hcHBpbmcgYXJyYXkgb2YgdmFsdWVzIHRvIG9iamVjdFxuICAgIG1hcCgodmFsdWVzKSA9PlxuICAgICAgdmFsdWVzLnJlZHVjZShnZXRFbnRyaWVzVG9PYmplY3RSZWR1Y2VyRm4oa2V5cyksIHt9IGFzIGFueSlcbiAgICApLFxuICAgIC8vIGJ5IHVzaW5nIHNoYXJlUmVwbGF5IHdlIHNoYXJlIHRoZSBsYXN0IGNvbXBvc2l0aW9uIHdvcmsgZG9uZSB0byBjcmVhdGUgdGhlIGFjY3VtdWxhdGVkIG9iamVjdFxuICAgIHNoYXJlUmVwbGF5KHsgcmVmQ291bnQ6IHRydWUsIGJ1ZmZlclNpemU6IDEgfSlcbiAgKTtcbn1cbiJdfQ==