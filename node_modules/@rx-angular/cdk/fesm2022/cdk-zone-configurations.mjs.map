{"version":3,"file":"cdk-zone-configurations.mjs","sources":["../../../../libs/cdk/zone-configurations/src/lib/event-names.ts","../../../../libs/cdk/zone-configurations/src/lib/convenience-methods.ts","../../../../libs/cdk/zone-configurations/src/lib/model/configurations.types.ts","../../../../libs/cdk/zone-configurations/src/lib/zone-config.ts","../../../../libs/cdk/zone-configurations/src/cdk-zone-configurations.ts"],"sourcesContent":["// Standard Events\n\n// Focus Events\nexport const focusEvents = ['blur', 'focus', 'focusin', 'focusout'] as const;\n\n/**\n * Mouse Events\n * (MouseEvent)[https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent]\n */\nexport const mouseEvents = [\n  'mousedown',\n  'dblclick',\n  'mouseenter',\n  'mouseleave',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'mouseup',\n  'click',\n] as const;\n\n/**\n * Wheel Events\n * (WheelEvent)[https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent]\n */\nexport const wheelEvents = [\n  // (WheelEvent)[https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent]\n  'wheel',\n  'mousewheel',\n] as const;\n\n// Input Events\nexport const inputEvents = [\n  'input',\n  'invalid',\n  'change',\n  'reset',\n  'select',\n  'submit',\n] as const;\n\n/**\n * @deprecated\n */\nexport const formControlsEvents = inputEvents;\n\n// [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent)\nexport const keyboardEvents = ['keydown', 'keypress', 'keyup'] as const;\n\n// [VR]()\nexport const vrEvents = [\n  'vrdisplayactivate',\n  'vrdisplayblur',\n  'vrdisplayconnect',\n  'vrdisplaydeactivate',\n  'vrdisplaydisconnect',\n  'vrdisplayfocus',\n  'vrdisplaypointerrestricted',\n  'vrdisplaypointerunrestricted',\n  'vrdisplaypresentchange',\n] as const;\n\n// [MSGesture]()\nexport const mSGestureEvents = [\n  'MSGestureChange',\n  'MSGestureDoubleTap',\n  'MSGestureEnd',\n  'MSGestureHold',\n  'MSGestureStart',\n  'MSGestureTap',\n  'MSInertiaStart',\n  'MSPointerCancel',\n  'MSPointerDown',\n  'MSPointerEnter',\n  'MSPointerLeave',\n  'MSPointerMove',\n  'MSPointerOut',\n  'MSPointerOver',\n  'MSPointerUp',\n] as const;\n\n// [xPrint](https://developer.mozilla.org/en-US/docs/Web/API/Window/afterprint_event)\nexport const printEvents = ['afterprint', 'beforeprint'] as const;\n// [network]()\nexport const networkEvents = ['offline', 'online'] as const;\n\n// [network]()\nexport const audioEvents = [\n  'canplay',\n  'canplaythrough',\n  'pause',\n  'play',\n  'playing',\n  'volumechange',\n] as const;\n\n// Composition Events\nexport const compositionEvents = [\n  'compositionstart',\n  'compositionupdate',\n  'compositionend',\n] as const;\n\n/**\n * Touch Events\n * [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent)\n * [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)\n */\nexport const touchEvents = [\n  // [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent)\n  'pointerover',\n  'pointerenter',\n  'pointerdown',\n  'pointermove',\n  // 'pointerrawupdate',\n  'pointerup',\n  'pointercancel',\n  'pointerout',\n  'pointerleave',\n  'gotpointercapture',\n  'lostpointercapture',\n  'pointerup',\n\n  // [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)\n  'touchstart',\n  'touchend',\n  'touchmove',\n  'touchcancel',\n\n  // [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent)\n  'drag',\n  'dragend',\n  'dragexit',\n  'dragenter',\n  'dragleave',\n  'dragover',\n  'dragstart',\n  'drop',\n] as const;\n\nexport const globalEvents = [\n  'contextmenu',\n  'resize',\n  'scroll',\n\n  'abort',\n  'load',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'unload',\n\n  'error',\n] as const;\n\nexport const websocketEvents = ['close', 'error', 'message', 'open'] as const;\n\n/**\n * Basic XHR Events\n * [Load](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/load_event)\n * [Error](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/error_event)\n * There are more events you may want to unpatch https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\n// XHREvent (group is here to make it easier to target XHR in angular applications. It contains redundant events e.g. 'error')\nexport const xhrEvents = ['load', 'error'] as const;\n\n// @TODO\nexport const windowEvents = [\n  'compassneedscalibration',\n  'durationchange',\n  'emptied',\n  'ended',\n\n  'orientationchange',\n\n  'ratechange',\n\n  'seeked',\n  'seeking',\n  'stalled',\n\n  'suspend',\n  'timeupdate',\n  'waiting',\n] as const;\n\n/**\n * All Events combined\n */\nexport const allEvents = Array.from(\n  new Set([\n    ...focusEvents,\n    ...mouseEvents,\n    ...wheelEvents,\n    ...inputEvents,\n    ...keyboardEvents,\n    ...inputEvents,\n    ...vrEvents,\n    ...mSGestureEvents,\n    ...printEvents,\n    ...networkEvents,\n    ...audioEvents,\n    ...compositionEvents,\n    ...touchEvents,\n    ...globalEvents,\n    ...websocketEvents,\n    ...xhrEvents,\n    ...windowEvents,\n  ])\n);\n","import { xhrEvents } from './event-names';\nimport {\n  RxZoneConfigConfiguration,\n  RxZoneConfigConvenienceMethods,\n} from './model/zone-config.types';\n\nexport const convenienceMethods = (\n  config: RxZoneConfigConfiguration\n): RxZoneConfigConvenienceMethods => ({\n  unpatchXHR: () => {\n    config.global.disable.XHR();\n    config.events.disable.UNPATCHED_EVENTS([...xhrEvents]);\n  },\n  useUnpatchedPassiveScrollEvents: () => {\n    config.events.disable.PASSIVE_EVENTS(['scroll']);\n    config.events.disable.UNPATCHED_EVENTS(['scroll']);\n  },\n});\n","// prefix: __Zone_disable_\nexport interface RxZoneGlobalDisableConfigurations {\n  /**\n   * Disable the monkey patch of the `Node.js` `EventEmitter` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `EventEmitter` APIs to make asynchronous\n   * callbacks of those APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const EventEmitter = require('events');\n   * class MyEmitter extends EventEmitter {}\n   * const myEmitter = new MyEmitter();\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   myEmitter.on('event', () => {\n   *     console.log('an event occurs in the zone', Zone.current.name);\n   *     // the callback runs in the zone when it is scheduled,\n   *     // so the output is 'an event occurs in the zone myZone'.\n   *   });\n   * });\n   * myEmitter.emit('event');\n   * ```\n   *\n   * If you set `__Zone_disable_EventEmitter = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `EventEmitter` APIs and the above code\n   * outputs 'an event occurred <root>'.\n   */\n  EventEmitter?: boolean;\n  /**\n   * Disable the monkey patch of the `Node.js` `fs` API.\n   *\n   * By default, `zone.js` monkey patches `Node.js` `fs` APIs to make asynchronous callbacks of\n   * those APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const fs = require('fs');\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   fs.stat('/tmp/world', (err, stats) => {\n   *     console.log('fs.stats() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of the `fs.stat()` runs in the same zone\n   *     // when it is called, so the output is 'fs.stats() callback is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_fs = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `fs` API and the above code\n   * outputs 'get stats occurred <root>'.\n   */\n  fs?: boolean;\n  /**\n   * Disable the monkey patch of the `Node.js` `timer` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `timer` APIs to make asynchronous\n   * callbacks of those APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   setTimeout(() => {\n   *     console.log('setTimeout() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `setTimeout()` runs in the same zone\n   *     // when it is scheduled, so the output is 'setTimeout() callback is invoked in the zone\n   *     // myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_timers = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `timer` APIs and the above code\n   * outputs 'timeout <root>'.\n   */\n  node_timers?: boolean;\n  /**\n   * Disable the monkey patch of the `Node.js` `process.nextTick()` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `process.nextTick()` API to make the\n   * callback in the same zone when calling `process.nextTick()`.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   process.nextTick(() => {\n   *     console.log('process.nextTick() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `process.nextTick()` runs in the same zone\n   *     // when it is scheduled, so the output is 'process.nextTick() callback is invoked in the\n   *     // zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_nextTick = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `process.nextTick()` API and the above code\n   * outputs 'nextTick <root>'.\n   */\n  nextTick?: boolean;\n  /**\n   * Disable the monkey patch of the `Node.js` `crypto` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `crypto` APIs to make asynchronous callbacks\n   * of those APIs in the same zone when called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const crypto = require('crypto');\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   crypto.randomBytes(() => {\n   *     console.log('crypto.randomBytes() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `crypto.randomBytes()` runs in the same zone\n   *     // when it is called, so the output is 'crypto.randomBytes() callback is invoked in the\n   *     // zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_crypto = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `crypto` API and the above code\n   * outputs 'crypto <root>'.\n   */\n  crypto?: boolean;\n  /**\n   * Disable the monkey patch of the `Object.defineProperty()` API.\n   *\n   * Note: This configuration is available only in the legacy bundle (dist/zone.js). This module is\n   * not available in the evergreen bundle (zone-evergreen.js).\n   *\n   * In the legacy browser, the default behavior of `zone.js` is to monkey patch\n   * `Object.defineProperty()` and `Object.create()` to try to ensure PropertyDescriptor parameter's\n   * configurable property to be true. This patch is only needed in some old mobile browsers.\n   *\n   * If you set `__Zone_disable_defineProperty = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `Object.defineProperty()` API and does not\n   * modify desc.configurable to true.\n   *\n   */\n  defineProperty?: boolean;\n  /**\n   * Disable the monkey patch of the browser `registerElement()` API.\n   *\n   * NOTE: This configuration is only available in the legacy bundle (dist/zone.js), this\n   * module is not available in the evergreen bundle (zone-evergreen.js).\n   *\n   * In the legacy browser, the default behavior of `zone.js` is to monkey patch the\n   * `registerElement()` API to make asynchronous callbacks of the API in the same zone when\n   * `registerElement()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const proto = Object.create(HTMLElement.prototype);\n   * proto.createdCallback = function() {\n   *   console.log('createdCallback is invoked in the zone', Zone.current.name);\n   * };\n   * proto.attachedCallback = function() {\n   *   console.log('attachedCallback is invoked in the zone', Zone.current.name);\n   * };\n   * proto.detachedCallback = function() {\n   *   console.log('detachedCallback is invoked in the zone', Zone.current.name);\n   * };\n   * proto.attributeChangedCallback = function() {\n   *   console.log('attributeChangedCallback is invoked in the zone', Zone.current.name);\n   * };\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   document.registerElement('x-elem', {prototype: proto});\n   * });\n   * ```\n   *\n   * When these callbacks are invoked, those callbacks will be in the zone when\n   * `registerElement()` is called.\n   *\n   * If you set `__Zone_disable_registerElement = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `registerElement()` API and the above code\n   * outputs '<root>'.\n   */\n  registerElement?: boolean;\n  /**\n   * Disable the monkey patch of the browser legacy `EventTarget` API.\n   *\n   * NOTE: This configuration is only available in the legacy bundle (dist/zone.js), this module\n   * is not available in the evergreen bundle (zone-evergreen.js).\n   *\n   * In some old browsers, the `EventTarget` is not available, so `zone.js` cannot directly monkey\n   * patch the `EventTarget`. Instead, `zone.js` patches all known HTML elements' prototypes (such\n   * as `HtmlDivElement`). The callback of the `addEventListener()` will be in the same zone when\n   * the `addEventListener()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   div.addEventListener('click', () => {\n   *     console.log('div click event listener is invoked in the zone', Zone.current.name);\n   *     // the output is 'div click event listener is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_EventTargetLegacy = true` before importing `zone.js`\n   * In some old browsers, where `EventTarget` is not available, if you set\n   * `__Zone_disable_EventTargetLegacy = true` before importing `zone.js`, `zone.js` does not monkey\n   * patch all HTML element APIs and the above code outputs 'clicked <root>'.\n   */\n  EventTargetLegacy?: boolean;\n  /**\n   * Disable the monkey patch of the browser `timer` APIs.\n   *\n   * By default, `zone.js` monkey patches browser timer\n   * APIs (`setTimeout()`/`setInterval()`/`setImmediate()`) to make asynchronous callbacks of those\n   * APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   setTimeout(() => {\n   *     console.log('setTimeout() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `setTimeout()` runs in the same zone\n   *     // when it is scheduled, so the output is 'setTimeout() callback is invoked in the zone\n   *     // myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_timers = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `timer` API and the above code\n   * outputs 'timeout <root>'.\n   *\n   */\n  timers?: boolean;\n  /**\n   * Disable the monkey patch of the browser `requestAnimationFrame()` API.\n   *\n   * By default, `zone.js` monkey patches the browser `requestAnimationFrame()` API\n   * to make the asynchronous callback of the `requestAnimationFrame()` in the same zone when\n   * scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   requestAnimationFrame(() => {\n   *     console.log('requestAnimationFrame() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `requestAnimationFrame()` will be in the same zone\n   *     // when it is scheduled, so the output will be 'requestAnimationFrame() callback is invoked\n   *     // in the zone myZone'\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_requestAnimationFrame = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `requestAnimationFrame()` API and the above code\n   * outputs 'raf <root>'.\n   */\n  requestAnimationFrame?: boolean;\n  /**\n   *\n   * Disable the monkey patch of the browser blocking APIs(`alert()`/`prompt()`/`confirm()`).\n   */\n  blocking?: boolean;\n  /**\n   * Disable the monkey patch of the browser `EventTarget` APIs.\n   *\n   * By default, `zone.js` monkey patches EventTarget APIs. The callbacks of the\n   * `addEventListener()` run in the same zone when the `addEventListener()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   div.addEventListener('click', () => {\n   *     console.log('div event listener is invoked in the zone', Zone.current.name);\n   *     // the output is 'div event listener is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_EventTarget = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch EventTarget API and the above code\n   * outputs 'clicked <root>'.\n   *\n   */\n  EventTarget?: boolean;\n  /**\n   * Disable the monkey patch of the browser `FileReader` APIs.\n   */\n  FileReader?: boolean;\n  /**\n   * Disable the monkey patch of the browser `MutationObserver` APIs.\n   */\n  MutationObserver?: boolean;\n  /**\n   * Disable the monkey patch of the browser `IntersectionObserver` APIs.\n   */\n  IntersectionObserver?: boolean;\n  /**\n   * Disable the monkey patch of the browser onProperty APIs(such as onclick).\n   *\n   * By default, `zone.js` monkey patches onXXX properties (such as onclick). The callbacks of onXXX\n   * properties run in the same zone when the onXXX properties is set.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   div.onclick = () => {\n   *     console.log('div click event listener is invoked in the zone', Zone.current.name);\n   *     // the output will be 'div click event listener is invoked in the zone myZone'\n   *   }\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_on_property = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch onXXX properties and the above code\n   * outputs 'clicked <root>'.\n   *\n   */\n  on_property?: boolean;\n  /**\n   * Disable the monkey patch of the browser `customElements` APIs.\n   *\n   * By default, `zone.js` monkey patches `customElements` APIs to make callbacks run in the\n   * same zone when the `customElements.define()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * class TestCustomElement extends HTMLElement {\n   *   constructor() { super(); }\n   *   connectedCallback() {}\n   *   disconnectedCallback() {}\n   *   attributeChangedCallback(attrName, oldVal, newVal) {}\n   *   adoptedCallback() {}\n   * }\n   *\n   * const zone = Zone.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   customElements.define('x-elem', TestCustomElement);\n   * });\n   * ```\n   *\n   * All those callbacks defined in TestCustomElement runs in the zone when\n   * the `customElements.define()` is called.\n   *\n   * If you set `__Zone_disable_customElements = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `customElements` APIs and the above code\n   * runs inside <root> zone.\n   */\n  customElements?: boolean;\n  /**\n   * Disable the monkey patch of the browser `XMLHttpRequest` APIs.\n   *\n   * By default, `zone.js` monkey patches `XMLHttpRequest` APIs to make XMLHttpRequest act\n   * as macroTask.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({\n   *   name: 'myZone',\n   *   onScheduleTask: (delegate, curr, target, task) => {\n   *     console.log('task is scheduled', task.type, task.source, task.zone.name);\n   *     return delegate.scheduleTask(target, task);\n   *   }\n   * })\n   * const xhr = new XMLHttpRequest();\n   * zone.run(() => {\n   *   xhr.onload = function() {};\n   *   xhr.open('get', '/', true);\n   *   xhr.send();\n   * });\n   * ```\n   *\n   * In this example, the instance of XMLHttpRequest runs in the zone and acts as a macroTask. The\n   * output is 'task is scheduled macroTask, XMLHttpRequest.send, zone'.\n   *\n   * If you set `__Zone_disable_XHR = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `XMLHttpRequest` APIs and the above onScheduleTask callback\n   * will not be called.\n   *\n   */\n  XHR?: boolean;\n  /**\n   * Disable the monkey patch of the browser geolocation APIs.\n   *\n   * By default, `zone.js` monkey patches geolocation APIs to make callbacks run in the same zone\n   * when those APIs are called.\n   *\n   * Consider the following examples:\n   *\n   * ```\n   * const zone = Zone.current.fork({\n   *   name: 'myZone'\n   * });\n   *\n   * zone.run(() => {\n   *   navigator.geolocation.getCurrentPosition(pos => {\n   *     console.log('navigator.getCurrentPosition() callback is invoked in the zone',\n   *     Zone.current.name);\n   *     // output is 'navigator.getCurrentPosition() callback is invoked in the zone myZone'.\n   *   }\n   * });\n   * ```\n   *\n   * If set you `__Zone_disable_geolocation = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch geolocation APIs and the above code\n   * outputs 'getCurrentPosition <root>'.\n   *\n   */\n  geolocation?: boolean;\n  /**\n   * Disable the monkey patch of the browser `canvas` APIs.\n   *\n   * By default, `zone.js` monkey patches `canvas` APIs to make callbacks run in the same zone when\n   * those APIs are called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({\n   *   name: 'myZone'\n   * });\n   *\n   * zone.run(() => {\n   *   canvas.toBlob(blog => {\n   *     console.log('canvas.toBlob() callback is invoked in the zone', Zone.current.name);\n   *     // output is 'canvas.toBlob() callback is invoked in the zone myZone'.\n   *   }\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_canvas = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `canvas` APIs and the above code\n   * outputs 'canvas.toBlob <root>'.\n   */\n  canvas?: boolean;\n  /**\n   * Disable the `Promise` monkey patch.\n   *\n   * By default, `zone.js` monkey patches `Promise` APIs to make the `then()/catch()` callbacks in\n   * the same zone when those callbacks are called.\n   *\n   * Consider the following examples:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   *\n   * const p = Promise.resolve(1);\n   *\n   * zone.run(() => {\n   *   p.then(() => {\n   *     console.log('then() callback is invoked in the zone', Zone.current.name);\n   *     // output is 'then() callback is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_ZoneAwarePromise = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `Promise` APIs and the above code\n   * outputs 'promise then callback <root>'.\n   */\n  ZoneAwarePromise?: boolean;\n}\nexport type RxZoneGlobalDisableConfigurationsKey =\n  keyof RxZoneGlobalDisableConfigurations;\nexport const zoneGlobalDisableConfigurationsKeys: RxZoneGlobalDisableConfigurationsKey[] =\n  [\n    'EventEmitter',\n    'fs',\n    'node_timers',\n    'nextTick',\n    'crypto',\n    'defineProperty',\n    'registerElement',\n    'EventTargetLegacy',\n    'timers',\n    'requestAnimationFrame',\n    'blocking',\n    'EventTarget',\n    'FileReader',\n    'MutationObserver',\n    'IntersectionObserver',\n    'on_property',\n    'customElements',\n    'XHR',\n    'geolocation',\n    'canvas',\n    'ZoneAwarePromise',\n  ];\n\n// prefix: __zone_symbol__\nexport interface RxZoneGlobalEventsConfigurations {\n  /**\n   * Define event names that users don't want monkey patched by the `zone.js`.\n   *\n   * By default, `zone.js` monkey patches EventTarget.addEventListener(). The event listener\n   * callback runs in the same zone when the addEventListener() is called.\n   *\n   * Sometimes, you don't want all of the event names used in this patched version because it\n   * impacts performance. For example, you might want `scroll` or `mousemove` event listeners to run\n   * the native `addEventListener()` for better performance.\n   *\n   * Users can achieve this goal by defining `__zone_symbol__UNPATCHED_EVENTS = ['scroll',\n   * 'mousemove'];` before importing `zone.js`.\n   */\n  UNPATCHED_EVENTS?: string[];\n  /**\n   * Define the event names of the passive listeners.\n   *\n   * To add passive event listeners, you can use `elem.addEventListener('scroll', listener,\n   * {passive: true});` or implement your own `EventManagerPlugin`.\n   *\n   * You can also define a global variable as follows:\n   *\n   * ```\n   * __zone_symbol__PASSIVE_EVENTS = ['scroll'];\n   * ```\n   *\n   * The preceding code makes all scroll event listeners passive.\n   */\n  PASSIVE_EVENTS?: string[];\n}\nexport type RxZoneGlobalEventsConfigurationsKey =\n  keyof RxZoneGlobalEventsConfigurations;\nexport const zoneGlobalEventsConfigurationsKeys: RxZoneGlobalEventsConfigurationsKey[] =\n  ['UNPATCHED_EVENTS', 'PASSIVE_EVENTS'];\n\n// prefix: __zone_symbol__\nexport interface RxZoneGlobalSettingsConfigurations {\n  /**\n   * Disable wrapping uncaught promise rejection.\n   *\n   * By default, `zone.js` wraps the uncaught promise rejection in a new `Error` object\n   * which contains additional information such as a value of the rejection and a stack trace.\n   *\n   * If you set `__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = true;` before\n   * importing `zone.js`, `zone.js` will not wrap the uncaught promise rejection.\n   */\n  DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION?: boolean;\n}\nexport type RxZoneGlobalSettingsConfigurationsKey =\n  keyof RxZoneGlobalSettingsConfigurations;\nexport const zoneGlobalSettingsConfigurationsKeys: RxZoneGlobalSettingsConfigurationsKey[] =\n  ['DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION'];\n\n// prefix: __zone_symbol__\nexport interface RxZoneRuntimeConfigurations {\n  ignoreConsoleErrorUncaughtError?: boolean;\n}\nexport type RxZoneRuntimeConfigurationsKey = keyof RxZoneRuntimeConfigurations;\nexport const zoneRuntimeConfigurationsKeys: RxZoneRuntimeConfigurationsKey[] = [\n  'ignoreConsoleErrorUncaughtError',\n];\n\n// prefix: __Zone_disable_\nexport interface RxZoneTestDisableConfigurations {\n  /**\n   * Disable the Jasmine integration.\n   *\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches Jasmine APIs\n   * to make Jasmine APIs run in specified zone.\n   *\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`beforeAll()`/`afterAll()`\n   * methods run in the ProxyZone.\n   *\n   * With this patch, `async()`/`fakeAsync()` can work with the Jasmine runner.\n   *\n   * If you set `__Zone_disable_jasmine = true` before importing `zone-testing.js`,\n   * `zone-testing.js` does not monkey patch the jasmine APIs and the `async()`/`fakeAsync()` cannot\n   * work with the Jasmine runner any longer.\n   */\n  jasmine?: boolean;\n  /**\n   * Disable the Mocha integration.\n   *\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches the Mocha APIs\n   * to make Mocha APIs run in the specified zone.\n   *\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`beforeAll()`/`afterAll()`\n   * methods run in the ProxyZone.\n   *\n   * With this patch, `async()`/`fakeAsync()` can work with the Mocha runner.\n   *\n   * If you set `__Zone_disable_mocha = true` before importing `zone-testing.js`,\n   * `zone-testing.js` does not monkey patch the Mocha APIs and the `async()/`fakeAsync()` can not\n   * work with the Mocha runner any longer.\n   */\n  mocha?: boolean;\n  /**\n   * Disable the Jest integration.\n   *\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches Jest APIs\n   * to make Jest APIs run in the specified zone.\n   *\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`before()`/`after()` methods\n   * run in the ProxyZone.\n   *\n   * With this patch, `async()`/`fakeAsync()` can work with the Jest runner.\n   *\n   * If you set `__Zone_disable_jest = true` before importing `zone-testing.js`,\n   * `zone-testing.js` does not monkey patch the jest APIs and `async()`/`fakeAsync()` cannot\n   * work with the Jest runner any longer.\n   */\n  jest?: boolean;\n}\nexport type RxZoneTestDisableConfigurationsKey =\n  keyof RxZoneTestDisableConfigurations;\nexport const zoneTestDisableConfigurationsKeys: RxZoneTestDisableConfigurationsKey[] =\n  ['jasmine', 'mocha', 'jest'];\n\n// prefix: __zone_symbol__\nexport interface RxZoneTestSettingsConfigurations {\n  /**\n   * Disable monkey patch the jasmine clock APIs.\n   *\n   * By default, `zone-testing.js` monkey patches the `jasmine.clock()` API,\n   * so the `jasmine.clock()` can work with the `fakeAsync()/tick()` API.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('jasmine.clock integration', () => {\n   *   beforeEach(() => {\n   *     jasmine.clock().install();\n   *   });\n   *   afterEach(() => {\n   *     jasmine.clock().uninstall();\n   *   });\n   *   it('fakeAsync test', fakeAsync(() => {\n   *     setTimeout(spy, 100);\n   *     expect(spy).not.toHaveBeenCalled();\n   *     jasmine.clock().tick(100);\n   *     expect(spy).toHaveBeenCalled();\n   *   }));\n   * });\n   * ```\n   *\n   * In the `fakeAsync()` method, `jasmine.clock().tick()` works just like `tick()`.\n   *\n   * If you set `__zone_symbol__fakeAsyncDisablePatchingClock = true` before importing\n   * `zone-testing.js`,`zone-testing.js` does not monkey patch the `jasmine.clock()` APIs and the\n   * `jasmine.clock()` cannot work with `fakeAsync()` any longer.\n   */\n  fakeAsyncDisablePatchingClock?: boolean;\n  /**\n   * Enable auto running into `fakeAsync()` when installing the `jasmine.clock()`.\n   *\n   * By default, `zone-testing.js` does not automatically run into `fakeAsync()`\n   * if the `jasmine.clock().install()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('jasmine.clock integration', () => {\n   *   beforeEach(() => {\n   *     jasmine.clock().install();\n   *   });\n   *   afterEach(() => {\n   *     jasmine.clock().uninstall();\n   *   });\n   *   it('fakeAsync test', fakeAsync(() => {\n   *     setTimeout(spy, 100);\n   *     expect(spy).not.toHaveBeenCalled();\n   *     jasmine.clock().tick(100);\n   *     expect(spy).toHaveBeenCalled();\n   *   }));\n   * });\n   * ```\n   *\n   * You must run `fakeAsync()` to make test cases in the `FakeAsyncTestZone`.\n   *\n   * If you set `__zone_symbol__fakeAsyncAutoFakeAsyncWhenClockPatched = true` before importing\n   * `zone-testing.js`, `zone-testing.js` can run test case automatically in the\n   * `FakeAsyncTestZone` without calling the `fakeAsync()`.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('jasmine.clock integration', () => {\n   *   beforeEach(() => {\n   *     jasmine.clock().install();\n   *   });\n   *   afterEach(() => {\n   *     jasmine.clock().uninstall();\n   *   });\n   *   it('fakeAsync test', () => { // here we don't need to call fakeAsync\n   *     setTimeout(spy, 100);\n   *     expect(spy).not.toHaveBeenCalled();\n   *     jasmine.clock().tick(100);\n   *     expect(spy).toHaveBeenCalled();\n   *   });\n   * });\n   * ```\n   *\n   */\n  fakeAsyncAutoFakeAsyncWhenClockPatched?: boolean;\n  /**\n   * Enable waiting for the unresolved promise in the `async()` test.\n   *\n   * In the `async()` test, `AsyncTestZone` waits for all the asynchronous tasks to finish. By\n   * default, if some promises remain unresolved, `AsyncTestZone` does not wait and reports that it\n   * received an unexpected result.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('wait never resolved promise', () => {\n   *   it('async with never resolved promise test', async(() => {\n   *     const p = new Promise(() => {});\n   *     p.then(() => {\n   *       // do some expectation.\n   *     });\n   *   }))\n   * });\n   * ```\n   *\n   * By default, this case passes, because the callback of `p.then()` is never called. Because `p`\n   * is an unresolved promise, there is no pending asynchronous task, which means the `async()`\n   * method does not wait.\n   *\n   * If you set `__zone_symbol__supportWaitUnResolvedChainedPromise = true`, the above case\n   * times out, because `async()` will wait for the unresolved promise.\n   */\n  supportWaitUnResolvedChainedPromise?: boolean;\n}\nexport type RxZoneTestSettingsConfigurationsKey =\n  keyof RxZoneTestSettingsConfigurations;\nexport const zoneTestSettingsConfigurationsKeys: RxZoneTestSettingsConfigurationsKey[] =\n  [\n    'fakeAsyncDisablePatchingClock',\n    'fakeAsyncAutoFakeAsyncWhenClockPatched',\n    'supportWaitUnResolvedChainedPromise',\n  ];\n\nexport interface RxZoneFlagsHelperFunctions {\n  /**\n   * Logs all zone.js configurations in the console.\n   */\n  __rxa_zone_config__log?: () => void;\n}\n","import { convenienceMethods } from './convenience-methods';\nimport {\n  RxZoneFlagsHelperFunctions,\n  zoneGlobalDisableConfigurationsKeys,\n  zoneGlobalEventsConfigurationsKeys,\n  zoneGlobalSettingsConfigurationsKeys,\n  zoneRuntimeConfigurationsKeys,\n  zoneTestDisableConfigurationsKeys,\n  zoneTestSettingsConfigurationsKeys,\n} from './model/configurations.types';\nimport { RxZoneGlobalConfigurations } from './model/zone.configurations.api';\nimport {\n  RxGlobalDisableConfigurationMethods,\n  RxRuntimeConfigurationMethods,\n  RxTestDisableConfigurationMethods,\n  RxZoneConfig,\n  RxZoneConfigConfiguration,\n  RxZoneGlobalEventsConfigurationsMethods,\n} from './model/zone-config.types';\n\nconst zoneDisable = '__Zone_disable_';\nconst zoneSymbol = '__zone_symbol__';\n\n/**\n * https://angular.io/guide/zone#setting-up-zonejs\n **/\nfunction assertZoneConfig() {\n  if ((window as any).Zone !== undefined) {\n    // @TODO link to docs\n    console.error('zone-flags file needs to get imported before zone.js');\n  }\n}\n\nconst addDisableFlag = (prop: string) => ({\n  [prop]: () => {\n    assertZoneConfig();\n    return ((window as any)[zoneDisable + prop] = true);\n  },\n});\n\nconst addSymbolFlag = (prop: string) => ({\n  [prop]: () => {\n    assertZoneConfig();\n    return ((window as any)[zoneSymbol + prop] = true);\n  },\n});\n\nconst addArraySymbolFlag = (prop: string) => ({\n  [prop]: (eventNames: string[]) => {\n    assertZoneConfig();\n    const w: any = window as any;\n    return (w[zoneSymbol + prop] = [\n      ...(Array.isArray(w[zoneSymbol + prop]) ? w[zoneSymbol + prop] : []),\n      ...eventNames,\n    ]);\n  },\n});\n\nconst reduceToObject = <T>(methodsArray: any[]): T => {\n  return methodsArray.reduce((map, item) => ({ ...map, ...item }), {} as T);\n};\n\n/**\n * factory function to create a `RxZoneConfig` object.\n *\n * @Example\n * import { globalEvents,xhrEvent, zoneConfig} from '@rx-angular/cdk/zone-flags';\n *\n * const zoneConfig = createZoneFlagsConfigurator();\n *\n * zoneConfig.global.disable.requestAnimationFrame();\n * zoneConfig.global.disable.timers();\n * zoneConfig.events.disable.UNPATCHED_EVENTS([...globalEvents, ...xhrEvent]);\n *\n */\nfunction createZoneFlagsConfigurator(): RxZoneConfig {\n  const cfg = globalThis as unknown as RxZoneGlobalConfigurations;\n  const configProps = [\n    ...[\n      ...zoneGlobalDisableConfigurationsKeys,\n      ...zoneTestDisableConfigurationsKeys,\n    ].map((prop) => zoneDisable + prop),\n    ...[\n      ...zoneGlobalSettingsConfigurationsKeys,\n      ...zoneTestSettingsConfigurationsKeys,\n      ...zoneGlobalEventsConfigurationsKeys,\n      ...zoneRuntimeConfigurationsKeys,\n    ].map((prop) => zoneSymbol + prop),\n  ];\n\n  // append as global method for easy debugging\n  (cfg as RxZoneFlagsHelperFunctions).__rxa_zone_config__log = (): void => {\n    configProps.forEach((flag) => {\n      cfg[flag] && console.log(flag, cfg[flag]);\n    });\n  };\n\n  const zoneConfigObj: RxZoneConfigConfiguration = {\n    global: {\n      disable: reduceToObject<RxGlobalDisableConfigurationMethods>([\n        ...zoneGlobalDisableConfigurationsKeys.map(addDisableFlag),\n        ...zoneGlobalSettingsConfigurationsKeys.map(addSymbolFlag),\n      ]),\n    },\n    test: {\n      disable: reduceToObject<RxTestDisableConfigurationMethods>([\n        ...zoneTestDisableConfigurationsKeys.map(addDisableFlag),\n        ...zoneTestSettingsConfigurationsKeys.map(addSymbolFlag),\n      ]),\n    },\n    events: {\n      disable: reduceToObject<RxZoneGlobalEventsConfigurationsMethods>(\n        zoneGlobalEventsConfigurationsKeys.map(addArraySymbolFlag)\n      ),\n    },\n    runtime: {\n      disable: reduceToObject<RxRuntimeConfigurationMethods>(\n        zoneRuntimeConfigurationsKeys.map(addSymbolFlag)\n      ),\n    },\n  };\n\n  return {\n    ...zoneConfigObj,\n    ...convenienceMethods(zoneConfigObj),\n  };\n}\n\n/**\n * An object for typed zone-flags configuration.\n *\n * @Example\n *\n * create file `zone-flags.ts` parallel to your `polyfills.ts` and insert following content:\n * ```typescript\n * import { globalEvents, xhrEvent, zoneConfig} from '@rx-angular/cdk/zone-flags';\n *\n * zoneConfig.global.disable.requestAnimationFrame();\n * zoneConfig.global.disable.timers();\n * zoneConfig.events.disable.UNPATCHED_EVENTS([...globalEvents, ...xhrEvent]);\n * ```\n * In `polyfills.ts` above the zone import, import `zone-flags.ts`\n *\n * ```typescript\n * import './zone-flags';\n * // Zone JS is required by default for Angular itself.\n * import 'zone.js';\n * ```\n *\n */\nexport const zoneConfig = createZoneFlagsConfigurator();\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}