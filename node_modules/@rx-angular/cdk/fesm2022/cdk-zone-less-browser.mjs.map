{"version":3,"file":"cdk-zone-less-browser.mjs","sources":["../../../../libs/cdk/zone-less/browser/src/browser.ts","../../../../libs/cdk/zone-less/browser/src/cdk-zone-less-browser.ts"],"sourcesContent":["import { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';\n\n/**\n * This file provides unpatched versions of APIs patched in the following file: https://github.com/angular/angular/blob/master/packages/zone.js/lib/browser/browser.ts\n */\n\n/**\n * This function is a zone un-patched implementation of Window#queueMicrotask() method.\n * It is which is exposed on the Window or Worker interface,\n * queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.\n * The microtask is a short function which will run after the current task has completed its\n * work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.\n */\nexport function queueMicrotask() {\n  return getZoneUnPatchedApi('queueMicrotask');\n}\n\nexport const Promise: PromiseConstructor = getZoneUnPatchedApi('Promise');\n\n/**\n * requestAnimationFrame\n *\n * @description\n *\n * This function is a zone un-patched implementation of Window#requestAnimationFrame() method\n *\n * The requestAnimationFrame() method calls a function or evaluates an expression on the next animationFrame.\n * The requestAnimationFrame() method will not continue calling the function after executed once.\n * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.\n *\n * requestAnimationFrame(cb, ms);\n *\n * @param cb - Required. The function that will be executed\n *\n */\nexport function requestAnimationFrame(cb: FrameRequestCallback): number {\n  return getZoneUnPatchedApi('requestAnimationFrame')(cb);\n}\n\n/**\n * cancelAnimationFrame\n *\n * @description\n *\n * This function is a zone un-patched implementation of Window cancelAnimationFrame() method\n *\n * The cancelAnimationFrame() method clears a timer set with the requestAnimationFrame() method.\n * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.\n *\n * To be able to use the cancelAnimationFrame() method, you must use a variable when creating the requestAnimationFrame method:\n *\n * const id = requestAnimationFrame(\"javascript function\");\n * Then you will be able to stop the execution by calling the cancelAnimationFrame() method.\n *\n * cancelAnimationFrame(id);\n *\n * @param id {number} - Required. The ID value of the timer returned by the requestAnimationFrame() method\n *\n */\n\nexport function cancelAnimationFrame(id: number): void {\n  getZoneUnPatchedApi('cancelAnimationFrame')(id);\n}\n\n/**\n * setInterval\n *\n * @description\n *\n * This function is a zone un-patched implementation of Window setInterval() method\n *\n * The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds).\n * The setInterval() method will continue calling the function until clearInterval() is called, or the window is closed.\n * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.\n *\n * setInterval(cb, ms);\n *\n * @param cb - Required. The function that will be executed\n * @param ms - Required. The intervals (in milliseconds) on how often to execute the code. If the value is less than 10, the value 10 is used\n *\n */\nexport function setInterval(cb: TimerHandler, ms = 0): number {\n  return getZoneUnPatchedApi('setInterval')(cb, ms);\n}\n\n/**\n * clearInterval\n *\n * @description\n *\n * This function is a zone un-patched implementation of Window clearInterval() method\n *\n * The clearInterval() method clears a timer set with the setInterval() method.\n * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.\n *\n * To be able to use the clearInterval() method, you must use a variable when creating the interval method:\n *\n * const id = setInterval(\"javascript function\", milliseconds);\n * Then you will be able to stop the execution by calling the clearInterval() method.\n *\n * clearInterval(id);\n *\n * @param id {number} - Required. The ID value of the timer returned by the setInterval() method\n *\n */\nexport function clearInterval(id: number): void {\n  return getZoneUnPatchedApi('clearInterval')(id);\n}\n\n/**\n * setTimeout\n *\n * @description\n *\n * This function is a zone un-patched implementation of Window setTimeout() method\n *\n * The setTimeout() method calls a function or evaluates an expression after a specified number of milliseconds.\n * The function is only executed once. If you need to repeat execution, use the setInterval() method.\n * Use the clearTimeout() method to prevent the function from running.\n *\n * setTimeout(cb, ms);\n *\n * @param cb - Required. The function that will be executed\n * @param ms - Optional. The number of milliseconds to wait before executing the code. If omitted, the value 0 is used\n *\n */\nexport function setTimeout(cb: TimerHandler, ms = 0): number {\n  return getZoneUnPatchedApi('setTimeout')(cb, ms);\n}\n\n/**\n * clearTimeout\n *\n * @description\n *\n * This function is a zone un-patched implementation of Window#clearTimeout() method\n *\n * The clearTimeout() method clears a timer set with the setTimeout() method.\n * The ID value returned by setTimeout() is used as the parameter for the clearTimeout() method.\n *\n * const id = setTimeout(\"javascript function\", milliseconds);\n * Then, if the function has not already been executed, you will be able to stop the execution by calling the clearTimeout() method.\n *\n * clearTimeout(id);\n *\n * @param id {number} -\tRequired. The ID value of the timer returned by the setTimeout() method\n *\n */\nexport function clearTimeout(id: number): void {\n  getZoneUnPatchedApi('clearTimeout')(id);\n}\n\n/**\n * This function is a zone un-patched implementation of Element#addEventListener() method.\n * @param target\n */\nexport function unpatchAddEventListener<T extends EventTarget>(target: T): T {\n  target.addEventListener = getZoneUnPatchedApi(\n    target,\n    'addEventListener'\n  ).bind(target);\n\n  return target;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["Promise"],"mappings":";;AAEA;;AAEG;AAEH;;;;;;AAMG;SACa,cAAc,GAAA;AAC5B,IAAA,OAAO,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;AAC/C,CAAC;MAEYA,SAAO,GAAuB,mBAAmB,CAAC,SAAS,EAAE;AAE1E;;;;;;;;;;;;;;;AAeG;AACG,SAAU,qBAAqB,CAAC,EAAwB,EAAA;AAC5D,IAAA,OAAO,mBAAmB,CAAC,uBAAuB,CAAC,CAAC,EAAE,CAAC,CAAC;AAC1D,CAAC;AAED;;;;;;;;;;;;;;;;;;;AAmBG;AAEG,SAAU,oBAAoB,CAAC,EAAU,EAAA;AAC7C,IAAA,mBAAmB,CAAC,sBAAsB,CAAC,CAAC,EAAE,CAAC,CAAC;AAClD,CAAC;AAED;;;;;;;;;;;;;;;;AAgBG;SACa,WAAW,CAAC,EAAgB,EAAE,EAAE,GAAG,CAAC,EAAA;IAClD,OAAO,mBAAmB,CAAC,aAAa,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AACpD,CAAC;AAED;;;;;;;;;;;;;;;;;;;AAmBG;AACG,SAAU,aAAa,CAAC,EAAU,EAAA;AACtC,IAAA,OAAO,mBAAmB,CAAC,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;AAClD,CAAC;AAED;;;;;;;;;;;;;;;;AAgBG;SACa,UAAU,CAAC,EAAgB,EAAE,EAAE,GAAG,CAAC,EAAA;IACjD,OAAO,mBAAmB,CAAC,YAAY,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AACnD,CAAC;AAED;;;;;;;;;;;;;;;;;AAiBG;AACG,SAAU,YAAY,CAAC,EAAU,EAAA;AACrC,IAAA,mBAAmB,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC;AAC1C,CAAC;AAED;;;AAGG;AACG,SAAU,uBAAuB,CAAwB,MAAS,EAAA;AACtE,IAAA,MAAM,CAAC,gBAAgB,GAAG,mBAAmB,CAC3C,MAAM,EACN,kBAAkB,CACnB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAEf,IAAA,OAAO,MAAM,CAAC;AAChB;;ACnKA;;AAEG;;;;"}