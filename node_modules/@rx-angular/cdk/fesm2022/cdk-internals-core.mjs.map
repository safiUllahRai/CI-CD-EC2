{"version":3,"file":"cdk-internals-core.mjs","sources":["../../../../libs/cdk/internals/core/src/lib/get-zone-unpatched-api.ts","../../../../libs/cdk/internals/core/src/lib/accumulateObservables.ts","../../../../libs/cdk/internals/core/src/lib/timeout.ts","../../../../libs/cdk/internals/core/src/cdk-internals-core.ts"],"sourcesContent":["import { ɵglobal } from '@angular/core';\n\n/**\n * @description\n *\n * This function returns the zone un-patched API for the a specific Browser API.\n * If no target is passed the window is used instead\n *\n * @param name - The name of the API to check.\n * @param target - The target to get un-patched API from.\n * @return {Function} - The zone un-patched API in question.\n *\n */\nexport function getZoneUnPatchedApi<\n  N extends keyof (Window & typeof globalThis)\n>(name: N): (Window & typeof globalThis)[N];\n\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\n  target: T,\n  name: N\n): T[N];\n\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\n  targetOrName: T | string,\n  name?: N\n) {\n  // If the user has provided the API name as the first argument, for instance:\n  // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n  // Then we just swap arguments and make `global` or `window` as the default target.\n  if (typeof targetOrName === 'string') {\n    name = targetOrName as N;\n    targetOrName = ɵglobal as T;\n  }\n  return targetOrName['__zone_symbol__' + String(name)] || targetOrName[name];\n}\n","import { coalesceWith } from '@rx-angular/cdk/coalescing';\nimport { combineLatest, from, Observable } from 'rxjs';\nimport { distinctUntilChanged, filter, map, shareReplay } from 'rxjs/operators';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\nimport {\n  ArrayReducerFn,\n  ExtractObservableValue,\n  NotEmpty,\n  ObservableMap,\n  PropName,\n  PropType,\n} from './model';\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn<T extends Record<string, any>>(\n  keys: PropName<T>[]\n): ArrayReducerFn<T> {\n  return (\n    accumulator: T,\n    currentValue?: PropType<T>,\n    currentIndex?: number\n  ): T => {\n    return {\n      ...accumulator,\n      [keys[currentIndex]]: currentValue,\n    };\n  };\n}\n\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nexport function accumulateObservables<T extends ObservableMap & NotEmpty<T>>(\n  // @TODO type static or Observable to enable mixing of imperative and reatctive values\n  obj: T,\n  durationSelector: Observable<any> = resolvedPromise$\n): Observable<{ [K in keyof T]: ExtractObservableValue<T[K]> }> {\n  const keys = Object.keys(obj) as (keyof T)[];\n  // @TODO better typing to enable static values => coerceObservable(obj[key])\n  const observables = keys.map((key) =>\n    obj[key].pipe(\n      // we avoid using the nullish operator later ;)\n      filter((v) => v !== undefined),\n      // state \"changes\" differ from each other, this operator ensures distinct values\n      distinctUntilChanged()\n    )\n  );\n  return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector),\n    // mapping array of values to object\n    map((values) =>\n      values.reduce(getEntriesToObjectReducerFn(keys), {} as any)\n    ),\n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({ refCount: true, bufferSize: 1 })\n  );\n}\n","import { Observable, Subscriber } from 'rxjs';\nimport { concatMap, mapTo } from 'rxjs/operators';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(delay = 0) {\n  return new Observable<number>((subscriber: Subscriber<number>) => {\n    const asyncID = getZoneUnPatchedApi('setTimeout')(\n      () => subscriber.next(0),\n      delay\n    );\n    return () => {\n      getZoneUnPatchedApi('clearTimeout')(asyncID);\n    };\n  });\n}\n\n/**\n *\n */\nexport function timeoutSwitchMapWith<T>() {\n  return (o$: Observable<T>) =>\n    o$.pipe(concatMap((v) => timeout().pipe(mapTo(v))));\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["ɵglobal"],"mappings":";;;;;AAsBgB,SAAA,mBAAmB,CACjC,YAAwB,EACxB,IAAQ,EAAA;;;;AAKR,IAAA,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;QACpC,IAAI,GAAG,YAAiB,CAAC;QACzB,YAAY,GAAGA,OAAY,CAAC;KAC7B;AACD,IAAA,OAAO,YAAY,CAAC,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;AAC9E;;ACrBA,MAAM,eAAe,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;AACjE,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;AAE/C;;;;AAIG;AACH,SAAS,2BAA2B,CAClC,IAAmB,EAAA;AAEnB,IAAA,OAAO,CACL,WAAc,EACd,YAA0B,EAC1B,YAAqB,KAChB;QACL,OAAO;AACL,YAAA,GAAG,WAAW;AACd,YAAA,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,YAAY;SACnC,CAAC;AACJ,KAAC,CAAC;AACJ,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCG;SACa,qBAAqB;AACnC;AACA,GAAM,EACN,mBAAoC,gBAAgB,EAAA;IAEpD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAgB,CAAC;;AAE7C,IAAA,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAC/B,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI;;IAEX,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC;;IAE9B,oBAAoB,EAAE,CACvB,CACF,CAAC;AACF,IAAA,OAAO,aAAa,CAAC,WAAW,CAAC,CAAC,IAAI;;;IAGpC,YAAY,CAAC,gBAAgB,CAAC;;AAE9B,IAAA,GAAG,CAAC,CAAC,MAAM,KACT,MAAM,CAAC,MAAM,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,EAAS,CAAC,CAC5D;;AAED,IAAA,WAAW,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,CAC/C,CAAC;AACJ;;AC9FA;;;;AAIG;AACH,SAAS,OAAO,CAAC,KAAK,GAAG,CAAC,EAAA;AACxB,IAAA,OAAO,IAAI,UAAU,CAAS,CAAC,UAA8B,KAAI;AAC/D,QAAA,MAAM,OAAO,GAAG,mBAAmB,CAAC,YAAY,CAAC,CAC/C,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EACxB,KAAK,CACN,CAAC;AACF,QAAA,OAAO,MAAK;AACV,YAAA,mBAAmB,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC;AAC/C,SAAC,CAAC;AACJ,KAAC,CAAC,CAAC;AACL,CAAC;AAED;;AAEG;SACa,oBAAoB,GAAA;AAClC,IAAA,OAAO,CAAC,EAAiB,KACvB,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD;;AC3BA;;AAEG;;;;"}