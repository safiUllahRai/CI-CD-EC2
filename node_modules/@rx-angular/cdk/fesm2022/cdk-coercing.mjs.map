{"version":3,"file":"cdk-coercing.mjs","sources":["../../../../libs/cdk/coercing/src/lib/coerceObservable.ts","../../../../libs/cdk/coercing/src/lib/coerceObservableWith.ts","../../../../libs/cdk/coercing/src/lib/coerceDistinctObservableWith.ts","../../../../libs/cdk/coercing/src/lib/coerce-all-factory.ts","../../../../libs/cdk/coercing/src/lib/coerceDistinctObservable.ts","../../../../libs/cdk/coercing/src/cdk-coercing.ts"],"sourcesContent":["import { isObservable, Observable, of } from 'rxjs';\n\n/**\n * This Observable factory creates an Observable out of a static value or an Observable.\n *\n * @param o - the value to coerce\n */\nexport function coerceObservable<T>(o: Observable<T> | T): Observable<T> {\n  return isObservable(o) ? o : of(o);\n}\n","import { Observable, OperatorFunction } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { coerceObservable } from './coerceObservable';\n\n/**\n * This operator maps an Observable out of a static value or an Observable.\n *\n */\nexport function coerceObservableWith<T>(): OperatorFunction<\n  Observable<T | null | undefined> | T | null | undefined,\n  Observable<T | null | undefined>\n> {\n  return (o$: Observable<Observable<T> | T>) => map(coerceObservable)(o$);\n}\n","import { Observable, OperatorFunction } from 'rxjs';\nimport { distinctUntilChanged, switchAll } from 'rxjs/operators';\nimport { coerceObservableWith } from './coerceObservableWith';\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nexport function coerceDistinctWith<T>(\n  flattenOperator?: OperatorFunction<Observable<T>, T>\n) {\n  flattenOperator = flattenOperator || switchAll();\n  return (o$: Observable<Observable<T> | T>) =>\n    o$.pipe(\n      coerceObservableWith(),\n      distinctUntilChanged(),\n      flattenOperator,\n      distinctUntilChanged()\n    );\n}\n","import { Observable, OperatorFunction, Subject } from 'rxjs';\nimport { switchAll } from 'rxjs/operators';\nimport { coerceDistinctWith } from './coerceDistinctObservableWith';\n\n/**\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distinct values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\nexport function coerceAllFactory<U, R = U>(\n  subjectFactory?: () => Subject<Observable<U> | U>,\n  flattenOperator?: OperatorFunction<Observable<U>, R>\n): {\n  values$: Observable<R>;\n  next(observable: Observable<U> | U): void;\n} {\n  const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n  flattenOperator = flattenOperator || (switchAll() as any);\n  const values$ = observablesSubject.pipe(\n    coerceDistinctWith(flattenOperator as any)\n  ) as Observable<R>;\n\n  return {\n    next(observable: Observable<U> | U) {\n      observablesSubject.next(observable);\n    },\n    values$,\n  };\n}\n","import { Observable, OperatorFunction } from 'rxjs';\nimport { distinctUntilChanged, switchAll } from 'rxjs/operators';\nimport { coerceObservable } from './coerceObservable';\n\n/**\n * This Observable factory creates an Observable out of a static value or an Observable.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nexport function coerceDistinctObservable<T>(\n  o$: Observable<Observable<T> | T>,\n  flattenOperator?: OperatorFunction<Observable<T>, T>\n) {\n  flattenOperator = flattenOperator || switchAll();\n  return coerceObservable(o$).pipe(\n    distinctUntilChanged(),\n    flattenOperator,\n    distinctUntilChanged()\n  );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;AAEA;;;;AAIG;AACG,SAAU,gBAAgB,CAAI,CAAoB,EAAA;AACtD,IAAA,OAAO,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACrC;;ACLA;;;AAGG;SACa,oBAAoB,GAAA;AAIlC,IAAA,OAAO,CAAC,EAAiC,KAAK,GAAG,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,CAAC;AAC1E;;ACTA;;;;;;;;;AASG;AACG,SAAU,kBAAkB,CAChC,eAAoD,EAAA;AAEpD,IAAA,eAAe,GAAG,eAAe,IAAI,SAAS,EAAE,CAAC;IACjD,OAAO,CAAC,EAAiC,KACvC,EAAE,CAAC,IAAI,CACL,oBAAoB,EAAE,EACtB,oBAAoB,EAAE,EACtB,eAAe,EACf,oBAAoB,EAAE,CACvB,CAAC;AACN;;ACrBA;;;;;;;;;;AAUG;AACa,SAAA,gBAAgB,CAC9B,cAAiD,EACjD,eAAoD,EAAA;AAKpD,IAAA,MAAM,kBAAkB,GAAG,cAAc,GAAG,cAAc,EAAE,GAAG,IAAI,OAAO,EAAE,CAAC;AAC7E,IAAA,eAAe,GAAG,eAAe,IAAK,SAAS,EAAU,CAAC;IAC1D,MAAM,OAAO,GAAG,kBAAkB,CAAC,IAAI,CACrC,kBAAkB,CAAC,eAAsB,CAAC,CAC1B,CAAC;IAEnB,OAAO;AACL,QAAA,IAAI,CAAC,UAA6B,EAAA;AAChC,YAAA,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SACrC;QACD,OAAO;KACR,CAAC;AACJ;;AC9BA;;;;;;;;;AASG;AACa,SAAA,wBAAwB,CACtC,EAAiC,EACjC,eAAoD,EAAA;AAEpD,IAAA,eAAe,GAAG,eAAe,IAAI,SAAS,EAAE,CAAC;AACjD,IAAA,OAAO,gBAAgB,CAAC,EAAE,CAAC,CAAC,IAAI,CAC9B,oBAAoB,EAAE,EACtB,eAAe,EACf,oBAAoB,EAAE,CACvB,CAAC;AACJ;;ACxBA;;AAEG;;;;"}