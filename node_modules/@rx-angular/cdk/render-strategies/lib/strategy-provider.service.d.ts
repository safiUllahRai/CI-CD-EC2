import { ChangeDetectorRef } from '@angular/core';
import { MonoTypeOperatorFunction, Observable } from 'rxjs';
import { RxRenderStrategiesConfig } from './config';
import { RxStrategies, RxStrategyCredentials, RxStrategyNames, ScheduleOnStrategyOptions } from './model';
import * as i0 from "@angular/core";
/**
 * @description
 * RxStrategyProvider is a wrapper service that you can use to consume strategies and schedule your code execution.
 *
 * @example
 * Component({
 *   selector: 'app-service-communicator',
 *   template: ``
 * });
 * export class ServiceCommunicationComponent {
 *   private currentUserSettings;
 *
 *   constructor(
 *     private strategyProvider: RxStrategyProvider,
 *     private userService: UserService,
 *     private backgroundSync: BackgroundSyncService
 *   ) {
 *     this.userService.fetchCurrentUserSettings
 *       .pipe(
 *         tap(settings => (this.currentUserSettings = settings)),
 *         this.strategyProvider.scheduleWith(
 *           settings => this.backgroundSync.openConnection(settings),
 *           { strategy: 'idle' }
 *         )
 *       )
 *       .subscribe();
 *   }
 * }
 *
 * @docsCategory RxStrategyProvider
 * @docsPage RxStrategyProvider
 */
export declare class RxStrategyProvider<T extends string = string> {
    private _strategies$;
    private _primaryStrategy$;
    private readonly _cfg;
    /**
     * @description
     * Returns current `RxAngularConfig` used in the service.
     * Config includes:
     * - strategy that currently in use - `primaryStrategy`
     * - array of custom user defined strategies - `customStrategies`
     * - setting that is responsible for running in our outside of the zone.js - `patchZone`
     */
    get config(): Required<RxRenderStrategiesConfig<T>>;
    /**
     * @description
     * Returns object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
     */
    get strategies(): RxStrategies<T>;
    /**
     * @description
     * Returns an array of strategy names available in the service.
     */
    get strategyNames(): string[];
    /**
     * @description
     * Returns current strategy of the service.
     */
    get primaryStrategy(): RxStrategyNames<T>;
    /**
     * @description
     * Set's the strategy that will be used by the service.
     */
    set primaryStrategy(strategyName: RxStrategyNames<T>);
    /**
     * @description
     * Current strategy of the service as an observable.
     */
    readonly primaryStrategy$: Observable<RxStrategyCredentials>;
    /**
     * @description
     * Returns observable of an object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
     */
    readonly strategies$: Observable<RxStrategies<T>>;
    /**
     * @description
     * Returns an observable of an array of strategy names available in the service.
     */
    readonly strategyNames$: Observable<string[]>;
    /**
     * @internal
     */
    constructor(cfg: RxRenderStrategiesConfig<T>);
    /**
     * @description
     * Allows to schedule a work inside rxjs `pipe`. Accepts the work and configuration options object.
     * - work is any function that should be executed
     * - (optional) options includes strategy, patchZone and scope
     *
     * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
     * Scope setup is useful if your work is some of the methods of `ChangeDetectorRef`. Only one change detection will be triggered if you have multiple schedules of change detection methods and scope is set to `this`.
     *
     * @example
     * myObservable$.pipe(
     *    this.strategyProvider.scheduleWith(() => myWork(), {strategy: 'idle', patchZone: false})
     * ).subscribe();
     *
     * @return MonoTypeOperatorFunction<R>
     */
    scheduleWith<R>(work: (v?: R) => void, options?: ScheduleOnStrategyOptions): MonoTypeOperatorFunction<R>;
    /**
     * @description
     * Allows to schedule a work as an observable. Accepts the work and configuration options object.
     * - work is any function that should be executed
     * - (optional) options includes strategy, patchZone and scope
     *
     * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
     * Scope setup is especially useful if you provide work that will trigger a change detection.
     *
     * @example
     * this.strategyProvider.schedule(() => myWork(), {strategy: 'idle', patchZone: false}).subscribe();
     *
     * @return Observable<R>
     */
    schedule<R>(work: () => R, options?: ScheduleOnStrategyOptions): Observable<R>;
    /**
     * @description
     * Allows to schedule a change detection cycle. Accepts the ChangeDetectorRef and configuration options object.
     * Options include:
     * - afterCD which is the work that should be executed after change detection cycle.
     * - abortCtrl is an AbortController that you can use to cancel the scheduled cycle.
     *
     * @example
     * this.strategyProvider.scheduleCd(this.changeDetectorRef, {afterCD: myWork()});
     *
     * @return AbortController
     */
    scheduleCD(cdRef: ChangeDetectorRef, options?: ScheduleOnStrategyOptions & {
        afterCD?: () => void;
        abortCtrl?: AbortController;
    }): AbortController;
    static ɵfac: i0.ɵɵFactoryDeclaration<RxStrategyProvider<any>, [{ optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RxStrategyProvider<any>>;
}
